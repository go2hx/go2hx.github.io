<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>go2hx stdgo</title>
    <link rel="shortcut icon" href="logo.svg">
    <meta property="og:title" content="go2hx stdgo"/>
    <meta property="og:type" content="Website"/>
    <meta property="og:url" content="https://go2hx.github.io"/>
    <meta property="og:description" content="go2hx is a Go to Haxe compiler"/>
    <meta property="og:image" content="logo.png"/>
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:width" content="512">
    <meta property="og:image:height" content="512">
    <meta property="og:image:alt" content="go2hx logo">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="go2hx">
    <meta name="twitter:description" content="go2hx, The Go to Haxe compiler">
    <meta name="twitter:image" content="logo.png">
    <meta name="twitter:image:alt" content="go2hx logo">
    <link href="../../prism.css" rel="stylesheet" />
    <link rel="stylesheet" href="../../style.css" />
		<style>
			body {
				box-sizing: border-box;
				min-width: 200px;
				max-width: 980px;
				margin: 0 auto;
				padding: 45px;
			}
			@media (prefers-color-scheme: dark) {
				body {
					background-color: #0d1117;
				}
			}
		</style>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css">
		<style>
			.github-fork-ribbon:before {
				background-color: #121612;
			}
		</style>
</head>
<body>
    <a class="markdown-body"><div class="header">
    <table>
            <thead>
            <th><h2><a href="https://go2hx.github.io/"><font color="#357b99">go</font><font color="#cad0d8">2</font><font color="#e2ac3f">hx</font></a></h2></th>
            <th><h2><a href="https://go2hx.github.io/manual">manual</a></h2></th>
            <th><h2><a href="https://github.com/go2hx/go2hx">github</a></h2></th>
        </thead>
    </table>
</div></a>
    <script src="../../prism.js"></script>
    <article class="markdown-body">
        <h1>Module: <code>stdgo.reflect</code></h1>
<p><a href="../index.html">(view library index)</a></p>
<h1><a name="overview">Overview</a></h1>
<p>Package reflect implements run-time reflection, allowing a program to��// manipulate objects with arbitrary types. The typical use is to take a value��// with static type interface{} and extract its dynamic type information by��// calling TypeOf, which returns a Type.��//��// A call to ValueOf returns a Value representing the run-time data.��// Zero takes a Type and returns a Value representing a zero value��// for that type.��//��// See "The Laws of Reflection" for an introduction to reflection in Go:��// https://golang.org/doc/articles/laws_of_reflection.html </p>
<h1><a name="index">Index</a></h1><ul><li>
<p><a href="#constants">Constants</a></p></li><li>
<p><a href="#function-append"><code>function append(_s:stdgo.reflect.Value, _x:haxe.Rest&lt;stdgo.reflect.Value&gt;):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#function-appendslice"><code>function appendSlice(_s:stdgo.reflect.Value, _t:stdgo.reflect.Value):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#function-arrayof"><code>function arrayOf(_length:stdgo.GoInt, _elem:stdgo.reflect.Type):stdgo.reflect.Type</code></a></p></li><li>
<p><a href="#function-chanof"><code>function chanOf(_dir:stdgo.reflect.ChanDir, _t:stdgo.reflect.Type):stdgo.reflect.Type</code></a></p></li><li>
<p><a href="#function-copy"><code>function copy(_dst:stdgo.reflect.Value, _src:stdgo.reflect.Value):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-deepequal"><code>function deepEqual(_x:stdgo.AnyInterface, _y:stdgo.AnyInterface):Bool</code></a></p></li><li>
<p><a href="#function-funcof"><code>function funcOf(_in:stdgo.Slice&lt;stdgo.reflect.Type&gt;, _out:stdgo.Slice&lt;stdgo.reflect.Type&gt;, _variadic:Bool):stdgo.reflect.Type</code></a></p></li><li>
<p><a href="#function-indirect"><code>function indirect(_v:stdgo.reflect.Value):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#function-makechan"><code>function makeChan(_typ:stdgo.reflect.Type, _buffer:stdgo.GoInt):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#function-makefunc"><code>function makeFunc(_typ:stdgo.reflect.Type, _fn:(_args:stdgo.Slice&lt;stdgo.reflect.Value&gt;):stdgo.Slice&lt;stdgo.reflect.Value&gt;):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#function-makemap"><code>function makeMap(_typ:stdgo.reflect.Type):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#function-makemapwithsize"><code>function makeMapWithSize(_typ:stdgo.reflect.Type, _n:stdgo.GoInt):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#function-makeslice"><code>function makeSlice(_typ:stdgo.reflect.Type, _len:stdgo.GoInt, _cap:stdgo.GoInt):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#function-mapof"><code>function mapOf(_key:stdgo.reflect.Type, _elem:stdgo.reflect.Type):stdgo.reflect.Type</code></a></p></li><li>
<p><a href="#function-newat"><code>function newAt(_typ:stdgo.reflect.Type, _p:stdgo.unsafe.UnsafePointer):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#function-new_"><code>function new_(_typ:stdgo.reflect.Type):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#function-pointerto"><code>function pointerTo(_t:stdgo.reflect.Type):stdgo.reflect.Type</code></a></p></li><li>
<p><a href="#function-ptrto"><code>function ptrTo(_t:stdgo.reflect.Type):stdgo.reflect.Type</code></a></p></li><li>
<p><a href="#function-select"><code>function select(_cases:stdgo.Slice&lt;stdgo.reflect.SelectCase&gt;):{_2:Bool, _1:stdgo.reflect.Value, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-sliceof"><code>function sliceOf(_t:stdgo.reflect.Type):stdgo.reflect.Type</code></a></p></li><li>
<p><a href="#function-structof"><code>function structOf(_fields:stdgo.Slice&lt;stdgo.reflect.StructField&gt;):stdgo.reflect.Type</code></a></p></li><li>
<p><a href="#function-swapper"><code>function swapper(_slice:stdgo.AnyInterface):(_i:stdgo.GoInt, _j:stdgo.GoInt):Void</code></a></p></li><li>
<p><a href="#function-typeof"><code>function typeOf(_i:stdgo.AnyInterface):stdgo.reflect.Type</code></a></p></li><li>
<p><a href="#function-valueof"><code>function valueOf(_i:stdgo.AnyInterface):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#function-visiblefields"><code>function visibleFields(_t:stdgo.reflect.Type):stdgo.Slice&lt;stdgo.reflect.StructField&gt;</code></a></p></li><li>
<p><a href="#function-zero"><code>function zero(_typ:stdgo.reflect.Type):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#class-chandir_static_extension">class ChanDir_static_extension</a></p></li><li>
<p><a href="#chandir_static_extension-function-string"><code>function string():stdgo.GoString</code></a></p></li><li>
<p><a href="#class-kind_static_extension">class Kind_static_extension</a></p></li><li>
<p><a href="#kind_static_extension-function-string"><code>function string():stdgo.GoString</code></a></p></li><li>
<p><a href="#class-mapiter">class MapIter</a></p></li><li>
<p><a href="#mapiter-function-new"><code>function new():Void</code></a></p></li><li>
<p><a href="#mapiter-function-key"><code>function key():stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#mapiter-function-next"><code>function next():Bool</code></a></p></li><li>
<p><a href="#mapiter-function-reset"><code>function reset( _v:stdgo.reflect.Value):Void</code></a></p></li><li>
<p><a href="#mapiter-function-value"><code>function value():stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#class-mapiter_static_extension">class MapIter_static_extension</a></p></li><li>
<p><a href="#mapiter_static_extension-function-key"><code>function key():stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#mapiter_static_extension-function-next"><code>function next():Bool</code></a></p></li><li>
<p><a href="#mapiter_static_extension-function-reset"><code>function reset( _v:stdgo.reflect.Value):Void</code></a></p></li><li>
<p><a href="#mapiter_static_extension-function-value"><code>function value():stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#class-method">class Method</a></p></li><li>
<p><a href="#method-function-new"><code>function new(?name:stdgo.GoString, ?pkgPath:stdgo.GoString, ?type:Null&lt;stdgo.reflect.Type&gt;, ?func:stdgo.reflect.Value, ?index:Null&lt;stdgo.GoInt&gt;):Void</code></a></p></li><li>
<p><a href="#method-function-isexported"><code>function isExported():Bool</code></a></p></li><li>
<p><a href="#class-method_static_extension">class Method_static_extension</a></p></li><li>
<p><a href="#method_static_extension-function-isexported"><code>function isExported():Bool</code></a></p></li><li>
<p><a href="#class-selectcase">class SelectCase</a></p></li><li>
<p><a href="#selectcase-function-new"><code>function new(?dir:Null&lt;stdgo.reflect.SelectDir&gt;, ?chan:stdgo.reflect.Value, ?send:stdgo.reflect.Value):Void</code></a></p></li><li>
<p><a href="#class-sliceheader">class SliceHeader</a></p></li><li>
<p><a href="#sliceheader-function-new"><code>function new(?data:stdgo.GoUIntptr, ?len:Null&lt;stdgo.GoInt&gt;, ?cap:Null&lt;stdgo.GoInt&gt;):Void</code></a></p></li><li>
<p><a href="#class-stringheader">class StringHeader</a></p></li><li>
<p><a href="#stringheader-function-new"><code>function new(?data:stdgo.GoUIntptr, ?len:Null&lt;stdgo.GoInt&gt;):Void</code></a></p></li><li>
<p><a href="#class-structfield">class StructField</a></p></li><li>
<p><a href="#structfield-function-new"><code>function new(?name:stdgo.GoString, ?pkgPath:stdgo.GoString, ?type:Null&lt;stdgo.reflect.Type&gt;, ?tag:Null&lt;stdgo.reflect.StructTag&gt;, ?offset:stdgo.GoUIntptr, ?index:stdgo.Slice&lt;stdgo.GoInt&gt;, ?anonymous:Bool):Void</code></a></p></li><li>
<p><a href="#structfield-function-isexported"><code>function isExported():Bool</code></a></p></li><li>
<p><a href="#class-structfield_static_extension">class StructField_static_extension</a></p></li><li>
<p><a href="#structfield_static_extension-function-isexported"><code>function isExported():Bool</code></a></p></li><li>
<p><a href="#class-structtag_static_extension">class StructTag_static_extension</a></p></li><li>
<p><a href="#structtag_static_extension-function-get"><code>function get( _key:stdgo.GoString):stdgo.GoString</code></a></p></li><li>
<p><a href="#structtag_static_extension-function-lookup"><code>function lookup( _key:stdgo.GoString):{_1:Bool, _0:stdgo.GoString}</code></a></p></li><li>
<p><a href="#class-value">class Value</a></p></li><li>
<p><a href="#value-function-new"><code>function new(?value:stdgo.AnyInterface, ?underlyingValue:Dynamic, ?underlyingIndex:Null&lt;stdgo.GoInt&gt;, ?underlyingKey:Dynamic, ?canAddrBool:Bool, ?notSetBool:Bool):Void</code></a></p></li><li>
<p><a href="#value-function-addr"><code>function addr():stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value-function-bool_"><code>function bool_():Bool</code></a></p></li><li>
<p><a href="#value-function-bytes"><code>function bytes():stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#value-function-call"><code>function call( _in:stdgo.Slice&lt;stdgo.reflect.Value&gt;):stdgo.Slice&lt;stdgo.reflect.Value&gt;</code></a></p></li><li>
<p><a href="#value-function-callslice"><code>function callSlice( _in:stdgo.Slice&lt;stdgo.reflect.Value&gt;):stdgo.Slice&lt;stdgo.reflect.Value&gt;</code></a></p></li><li>
<p><a href="#value-function-canaddr"><code>function canAddr():Bool</code></a></p></li><li>
<p><a href="#value-function-cancomplex"><code>function canComplex():Bool</code></a></p></li><li>
<p><a href="#value-function-canconvert"><code>function canConvert( _t:stdgo.reflect.Type):Bool</code></a></p></li><li>
<p><a href="#value-function-canfloat"><code>function canFloat():Bool</code></a></p></li><li>
<p><a href="#value-function-canint"><code>function canInt():Bool</code></a></p></li><li>
<p><a href="#value-function-caninterface"><code>function canInterface():Bool</code></a></p></li><li>
<p><a href="#value-function-canset"><code>function canSet():Bool</code></a></p></li><li>
<p><a href="#value-function-canuint"><code>function canUint():Bool</code></a></p></li><li>
<p><a href="#value-function-cap"><code>function cap():stdgo.GoInt</code></a></p></li><li>
<p><a href="#value-function-close"><code>function close():Void</code></a></p></li><li>
<p><a href="#value-function-complex"><code>function complex():stdgo.GoComplex128</code></a></p></li><li>
<p><a href="#value-function-convert"><code>function convert( _t:stdgo.reflect.Type):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value-function-elem"><code>function elem():stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value-function-field"><code>function field( _i:stdgo.GoInt):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value-function-fieldbyindex"><code>function fieldByIndex( _index:stdgo.Slice&lt;stdgo.GoInt&gt;):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value-function-fieldbyindexerr"><code>function fieldByIndexErr( _index:stdgo.Slice&lt;stdgo.GoInt&gt;):{_1:stdgo.Error, _0:stdgo.reflect.Value}</code></a></p></li><li>
<p><a href="#value-function-fieldbyname"><code>function fieldByName( _name:stdgo.GoString):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value-function-fieldbynamefunc"><code>function fieldByNameFunc( _match:()):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value-function-float_"><code>function float_():stdgo.GoFloat64</code></a></p></li><li>
<p><a href="#value-function-index"><code>function index( _i:stdgo.GoInt):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value-function-int_"><code>function int_():stdgo.GoInt64</code></a></p></li><li>
<p><a href="#value-function-interfacedata"><code>function interfaceData():stdgo.GoArray&lt;stdgo.GoUIntptr&gt;</code></a></p></li><li>
<p><a href="#value-function-interface_"><code>function interface_():stdgo.AnyInterface</code></a></p></li><li>
<p><a href="#value-function-isnil"><code>function isNil():Bool</code></a></p></li><li>
<p><a href="#value-function-isvalid"><code>function isValid():Bool</code></a></p></li><li>
<p><a href="#value-function-iszero"><code>function isZero():Bool</code></a></p></li><li>
<p><a href="#value-function-kind"><code>function kind():stdgo.reflect.Kind</code></a></p></li><li>
<p><a href="#value-function-len"><code>function len():stdgo.GoInt</code></a></p></li><li>
<p><a href="#value-function-mapindex"><code>function mapIndex( _key:stdgo.reflect.Value):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value-function-mapkeys"><code>function mapKeys():stdgo.Slice&lt;stdgo.reflect.Value&gt;</code></a></p></li><li>
<p><a href="#value-function-maprange"><code>function mapRange():stdgo.Ref&lt;stdgo.reflect.MapIter&gt;</code></a></p></li><li>
<p><a href="#value-function-method"><code>function method( _i:stdgo.GoInt):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value-function-methodbyname"><code>function methodByName( _name:stdgo.GoString):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value-function-numfield"><code>function numField():stdgo.GoInt</code></a></p></li><li>
<p><a href="#value-function-nummethod"><code>function numMethod():stdgo.GoInt</code></a></p></li><li>
<p><a href="#value-function-overflowcomplex"><code>function overflowComplex( _x:stdgo.GoComplex128):Bool</code></a></p></li><li>
<p><a href="#value-function-overflowfloat"><code>function overflowFloat( _x:stdgo.GoFloat64):Bool</code></a></p></li><li>
<p><a href="#value-function-overflowint"><code>function overflowInt( _x:stdgo.GoInt64):Bool</code></a></p></li><li>
<p><a href="#value-function-overflowuint"><code>function overflowUint( _x:stdgo.GoUInt64):Bool</code></a></p></li><li>
<p><a href="#value-function-pointer"><code>function pointer():stdgo.GoUIntptr</code></a></p></li><li>
<p><a href="#value-function-recv"><code>function recv():{_1:Bool, _0:stdgo.reflect.Value}</code></a></p></li><li>
<p><a href="#value-function-send"><code>function send( _x:stdgo.reflect.Value):Void</code></a></p></li><li>
<p><a href="#value-function-set"><code>function set( _x:stdgo.reflect.Value):Void</code></a></p></li><li>
<p><a href="#value-function-setbool"><code>function setBool( _x:Bool):Void</code></a></p></li><li>
<p><a href="#value-function-setbytes"><code>function setBytes( _x:stdgo.Slice&lt;stdgo.GoByte&gt;):Void</code></a></p></li><li>
<p><a href="#value-function-setcap"><code>function setCap( _n:stdgo.GoInt):Void</code></a></p></li><li>
<p><a href="#value-function-setcomplex"><code>function setComplex( _x:stdgo.GoComplex128):Void</code></a></p></li><li>
<p><a href="#value-function-setfloat"><code>function setFloat( _x:stdgo.GoFloat64):Void</code></a></p></li><li>
<p><a href="#value-function-setint"><code>function setInt( _x:stdgo.GoInt64):Void</code></a></p></li><li>
<p><a href="#value-function-setiterkey"><code>function setIterKey( _iter:stdgo.Ref&lt;stdgo.reflect.MapIter&gt;):Void</code></a></p></li><li>
<p><a href="#value-function-setitervalue"><code>function setIterValue( _iter:stdgo.Ref&lt;stdgo.reflect.MapIter&gt;):Void</code></a></p></li><li>
<p><a href="#value-function-setlen"><code>function setLen( _n:stdgo.GoInt):Void</code></a></p></li><li>
<p><a href="#value-function-setmapindex"><code>function setMapIndex( _key:stdgo.reflect.Value, _elem:stdgo.reflect.Value):Void</code></a></p></li><li>
<p><a href="#value-function-setpointer"><code>function setPointer( _x:stdgo.unsafe.UnsafePointer):Void</code></a></p></li><li>
<p><a href="#value-function-setstring"><code>function setString( _x:stdgo.GoString):Void</code></a></p></li><li>
<p><a href="#value-function-setuint"><code>function setUint( _x:stdgo.GoUInt64):Void</code></a></p></li><li>
<p><a href="#value-function-slice"><code>function slice( _i:stdgo.GoInt, _j:stdgo.GoInt):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value-function-slice3"><code>function slice3( _i:stdgo.GoInt, _j:stdgo.GoInt, _k:stdgo.GoInt):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value-function-string"><code>function string():stdgo.GoString</code></a></p></li><li>
<p><a href="#value-function-tryrecv"><code>function tryRecv():{_1:Bool, _0:stdgo.reflect.Value}</code></a></p></li><li>
<p><a href="#value-function-trysend"><code>function trySend( _x:stdgo.reflect.Value):Bool</code></a></p></li><li>
<p><a href="#value-function-type"><code>function type():stdgo.reflect.Type</code></a></p></li><li>
<p><a href="#value-function-uint"><code>function uint():stdgo.GoUInt64</code></a></p></li><li>
<p><a href="#value-function-unsafeaddr"><code>function unsafeAddr():stdgo.GoUIntptr</code></a></p></li><li>
<p><a href="#value-function-unsafepointer"><code>function unsafePointer():stdgo.unsafe.UnsafePointer</code></a></p></li><li>
<p><a href="#class-valueerror">class ValueError</a></p></li><li>
<p><a href="#valueerror-function-new"><code>function new(?method:stdgo.GoString, ?kind:Null&lt;stdgo.reflect.Kind&gt;):Void</code></a></p></li><li>
<p><a href="#valueerror-function-error"><code>function error():stdgo.GoString</code></a></p></li><li>
<p><a href="#class-valueerror_static_extension">class ValueError_static_extension</a></p></li><li>
<p><a href="#valueerror_static_extension-function-error"><code>function error():stdgo.GoString</code></a></p></li><li>
<p><a href="#class-value_static_extension">class Value_static_extension</a></p></li><li>
<p><a href="#value_static_extension-function-addr"><code>function addr():stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value_staticextension-function-bool"><code>function bool_():Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-bytes"><code>function bytes():stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#value_static_extension-function-call"><code>function call( _in:stdgo.Slice&lt;stdgo.reflect.Value&gt;):stdgo.Slice&lt;stdgo.reflect.Value&gt;</code></a></p></li><li>
<p><a href="#value_static_extension-function-callslice"><code>function callSlice( _in:stdgo.Slice&lt;stdgo.reflect.Value&gt;):stdgo.Slice&lt;stdgo.reflect.Value&gt;</code></a></p></li><li>
<p><a href="#value_static_extension-function-canaddr"><code>function canAddr():Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-cancomplex"><code>function canComplex():Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-canconvert"><code>function canConvert( _t:stdgo.reflect.Type):Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-canfloat"><code>function canFloat():Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-canint"><code>function canInt():Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-caninterface"><code>function canInterface():Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-canset"><code>function canSet():Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-canuint"><code>function canUint():Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-cap"><code>function cap():stdgo.GoInt</code></a></p></li><li>
<p><a href="#value_static_extension-function-close"><code>function close():Void</code></a></p></li><li>
<p><a href="#value_static_extension-function-complex"><code>function complex():stdgo.GoComplex128</code></a></p></li><li>
<p><a href="#value_static_extension-function-convert"><code>function convert( _t:stdgo.reflect.Type):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value_static_extension-function-elem"><code>function elem():stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value_static_extension-function-field"><code>function field( _i:stdgo.GoInt):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value_static_extension-function-fieldbyindex"><code>function fieldByIndex( _index:stdgo.Slice&lt;stdgo.GoInt&gt;):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value_static_extension-function-fieldbyindexerr"><code>function fieldByIndexErr( _index:stdgo.Slice&lt;stdgo.GoInt&gt;):{_1:stdgo.Error, _0:stdgo.reflect.Value}</code></a></p></li><li>
<p><a href="#value_static_extension-function-fieldbyname"><code>function fieldByName( _name:stdgo.GoString):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value_static_extension-function-fieldbynamefunc"><code>function fieldByNameFunc( _match:()):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value_staticextension-function-float"><code>function float_():stdgo.GoFloat64</code></a></p></li><li>
<p><a href="#value_static_extension-function-index"><code>function index( _i:stdgo.GoInt):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value_staticextension-function-int"><code>function int_():stdgo.GoInt64</code></a></p></li><li>
<p><a href="#value_static_extension-function-interfacedata"><code>function interfaceData():stdgo.GoArray&lt;stdgo.GoUIntptr&gt;</code></a></p></li><li>
<p><a href="#value_staticextension-function-interface"><code>function interface_():stdgo.AnyInterface</code></a></p></li><li>
<p><a href="#value_static_extension-function-isnil"><code>function isNil():Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-isvalid"><code>function isValid():Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-iszero"><code>function isZero():Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-kind"><code>function kind():stdgo.reflect.Kind</code></a></p></li><li>
<p><a href="#value_static_extension-function-len"><code>function len():stdgo.GoInt</code></a></p></li><li>
<p><a href="#value_static_extension-function-mapindex"><code>function mapIndex( _key:stdgo.reflect.Value):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value_static_extension-function-mapkeys"><code>function mapKeys():stdgo.Slice&lt;stdgo.reflect.Value&gt;</code></a></p></li><li>
<p><a href="#value_static_extension-function-maprange"><code>function mapRange():stdgo.Ref&lt;stdgo.reflect.MapIter&gt;</code></a></p></li><li>
<p><a href="#value_static_extension-function-method"><code>function method( _i:stdgo.GoInt):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value_static_extension-function-methodbyname"><code>function methodByName( _name:stdgo.GoString):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value_static_extension-function-numfield"><code>function numField():stdgo.GoInt</code></a></p></li><li>
<p><a href="#value_static_extension-function-nummethod"><code>function numMethod():stdgo.GoInt</code></a></p></li><li>
<p><a href="#value_static_extension-function-overflowcomplex"><code>function overflowComplex( _x:stdgo.GoComplex128):Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-overflowfloat"><code>function overflowFloat( _x:stdgo.GoFloat64):Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-overflowint"><code>function overflowInt( _x:stdgo.GoInt64):Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-overflowuint"><code>function overflowUint( _x:stdgo.GoUInt64):Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-pointer"><code>function pointer():stdgo.GoUIntptr</code></a></p></li><li>
<p><a href="#value_static_extension-function-recv"><code>function recv():{_1:Bool, _0:stdgo.reflect.Value}</code></a></p></li><li>
<p><a href="#value_static_extension-function-send"><code>function send( _x:stdgo.reflect.Value):Void</code></a></p></li><li>
<p><a href="#value_static_extension-function-set"><code>function set( _x:stdgo.reflect.Value):Void</code></a></p></li><li>
<p><a href="#value_static_extension-function-setbool"><code>function setBool( _x:Bool):Void</code></a></p></li><li>
<p><a href="#value_static_extension-function-setbytes"><code>function setBytes( _x:stdgo.Slice&lt;stdgo.GoByte&gt;):Void</code></a></p></li><li>
<p><a href="#value_static_extension-function-setcap"><code>function setCap( _n:stdgo.GoInt):Void</code></a></p></li><li>
<p><a href="#value_static_extension-function-setcomplex"><code>function setComplex( _x:stdgo.GoComplex128):Void</code></a></p></li><li>
<p><a href="#value_static_extension-function-setfloat"><code>function setFloat( _x:stdgo.GoFloat64):Void</code></a></p></li><li>
<p><a href="#value_static_extension-function-setint"><code>function setInt( _x:stdgo.GoInt64):Void</code></a></p></li><li>
<p><a href="#value_static_extension-function-setiterkey"><code>function setIterKey( _iter:stdgo.Ref&lt;stdgo.reflect.MapIter&gt;):Void</code></a></p></li><li>
<p><a href="#value_static_extension-function-setitervalue"><code>function setIterValue( _iter:stdgo.Ref&lt;stdgo.reflect.MapIter&gt;):Void</code></a></p></li><li>
<p><a href="#value_static_extension-function-setlen"><code>function setLen( _n:stdgo.GoInt):Void</code></a></p></li><li>
<p><a href="#value_static_extension-function-setmapindex"><code>function setMapIndex( _key:stdgo.reflect.Value, _elem:stdgo.reflect.Value):Void</code></a></p></li><li>
<p><a href="#value_static_extension-function-setpointer"><code>function setPointer( _x:stdgo.unsafe.UnsafePointer):Void</code></a></p></li><li>
<p><a href="#value_static_extension-function-setstring"><code>function setString( _x:stdgo.GoString):Void</code></a></p></li><li>
<p><a href="#value_static_extension-function-setuint"><code>function setUint( _x:stdgo.GoUInt64):Void</code></a></p></li><li>
<p><a href="#value_static_extension-function-slice"><code>function slice( _i:stdgo.GoInt, _j:stdgo.GoInt):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value_static_extension-function-slice3"><code>function slice3( _i:stdgo.GoInt, _j:stdgo.GoInt, _k:stdgo.GoInt):stdgo.reflect.Value</code></a></p></li><li>
<p><a href="#value_static_extension-function-string"><code>function string():stdgo.GoString</code></a></p></li><li>
<p><a href="#value_static_extension-function-tryrecv"><code>function tryRecv():{_1:Bool, _0:stdgo.reflect.Value}</code></a></p></li><li>
<p><a href="#value_static_extension-function-trysend"><code>function trySend( _x:stdgo.reflect.Value):Bool</code></a></p></li><li>
<p><a href="#value_static_extension-function-type"><code>function type():stdgo.reflect.Type</code></a></p></li><li>
<p><a href="#value_static_extension-function-uint"><code>function uint():stdgo.GoUInt64</code></a></p></li><li>
<p><a href="#value_static_extension-function-unsafeaddr"><code>function unsafeAddr():stdgo.GoUIntptr</code></a></p></li><li>
<p><a href="#value_static_extension-function-unsafepointer"><code>function unsafePointer():stdgo.unsafe.UnsafePointer</code></a></p></li><li>
<p><a href="#typedef-chandir">typedef ChanDir</a></p></li><li>
<p><a href="#chandir-function-string"><code>function string():stdgo.GoString</code></a></p></li><li>
<p><a href="#typedef-kind">typedef Kind</a></p></li><li>
<p><a href="#kind-function-string"><code>function string():stdgo.GoString</code></a></p></li><li>
<p><a href="#typedef-selectdir">typedef SelectDir</a></p></li><li>
<p><a href="#typedef-structtag">typedef StructTag</a></p></li><li>
<p><a href="#structtag-function-get"><code>function get( _key:stdgo.GoString):stdgo.GoString</code></a></p></li><li>
<p><a href="#structtag-function-lookup"><code>function lookup( _key:stdgo.GoString):{_1:Bool, _0:stdgo.GoString}</code></a></p></li><li>
<p><a href="#typedef-type">typedef Type</a></p></li></ul>
<h1><a name="constants">Constants</a></h1>
<pre><code class="language-haxe">import stdgo.reflect.Reflect</code></pre>
<pre><code class="language-haxe">final array:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final bool_:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final bothDir:stdgo.reflect.ChanDir = ((((0 : GoInt)) : ChanDir))</code></pre>
<p>chan </p>
<pre><code class="language-haxe">final chan:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final complex128:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final complex64:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final float32:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final float64:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final func:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final int16:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final int32:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final int64:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final int8:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final int_:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final interface_:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final invalid:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final map:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final pointer:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final ptr:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<p>Ptr is the old name for the Pointer kind. </p>
<pre><code class="language-haxe">final recvDir:stdgo.reflect.ChanDir = ((((0 : GoInt)) : ChanDir))</code></pre>
<p>\&lt;-chan </p>
<pre><code class="language-haxe">final selectDefault:stdgo.InvalidType = @:unknown_default_value null</code></pre>
<p>default </p>
<pre><code class="language-haxe">final selectRecv:stdgo.InvalidType = @:unknown_default_value null</code></pre>
<p>case \&lt;-Chan: </p>
<pre><code class="language-haxe">final selectSend:stdgo.InvalidType = @:unknown_default_value null</code></pre>
<p>case Chan \&lt;- Send </p>
<pre><code class="language-haxe">final sendDir:stdgo.reflect.ChanDir = ((((0 : GoInt)) : ChanDir))</code></pre>
<p>chan\&lt;- </p>
<pre><code class="language-haxe">final slice:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final string:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final struct_:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final uint:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final uint16:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final uint32:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final uint64:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final uint8:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final uintptr:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<pre><code class="language-haxe">final unsafePointer:stdgo.reflect.Kind = ((((0 : GoUInt)) : Kind))</code></pre>
<h1><a name="functions">Functions</a></h1>
<pre><code class="language-haxe">import stdgo.reflect.Reflect</code></pre>
<h2><a name="function-append">function append</a></h2>
<pre><code class="language-haxe">function append(_s:stdgo.reflect.Value, _x:haxe.Rest&lt;stdgo.reflect.Value&gt;):stdgo.reflect.Value</code></pre>
<p>Append appends the values x to a slice s and returns the resulting slice.��// As in Go, each x's value must be assignable to the slice's element type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L877"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-appendslice">function appendSlice</a></h2>
<pre><code class="language-haxe">function appendSlice(_s:stdgo.reflect.Value, _t:stdgo.reflect.Value):stdgo.reflect.Value</code></pre>
<p>AppendSlice appends a slice t to a slice s and returns the resulting slice.��// The slices s and t must have the same element type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L884"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-arrayof">function arrayOf</a></h2>
<pre><code class="language-haxe">function arrayOf(_length:stdgo.GoInt, _elem:stdgo.reflect.Type):stdgo.reflect.Type</code></pre>
<p>ArrayOf returns the array type with the given length and element type.��// For example, if t represents int, ArrayOf(5, t) represents [5]int.��//��// If the resulting type would be larger than the available address space,��// ArrayOf panics. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L870"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-chanof">function chanOf</a></h2>
<pre><code class="language-haxe">function chanOf(_dir:stdgo.reflect.ChanDir, _t:stdgo.reflect.Type):stdgo.reflect.Type</code></pre>
<p>ChanOf returns the channel type with the given direction and element type.��// For example, if t represents int, ChanOf(RecvDir, t) represents \&lt;-chan int.��//��// The gc runtime imposes a limit of 64 kB on channel element types.��// If t's size is equal to or exceeds this limit, ChanOf panics. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L818"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-copy">function copy</a></h2>
<pre><code class="language-haxe">function copy(_dst:stdgo.reflect.Value, _src:stdgo.reflect.Value):stdgo.GoInt</code></pre>
<p>Copy copies the contents of src into dst until either��// dst has been filled or src has been exhausted.��// It returns the number of elements copied.��// Dst and src each must have kind Slice or Array, and��// dst and src must have the same element type.��//��// As a special case, src can have kind String if the element type of dst is kind Uint8. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L896"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-deepequal">function deepEqual</a></h2>
<pre><code class="language-haxe">function deepEqual(_x:stdgo.AnyInterface, _y:stdgo.AnyInterface):Bool</code></pre>
<p>DeepEqual reports whether x and y are “deeply equal,” defined as follows.��// Two values of identical type are deeply equal if one of the following cases applies.��// Values of distinct types are never deeply equal.��//��// Array values are deeply equal when their corresponding elements are deeply equal.��//��// Struct values are deeply equal if their corresponding fields,��// both exported and unexported, are deeply equal.��//��// Func values are deeply equal if both are nil; otherwise they are not deeply equal.��//��// Interface values are deeply equal if they hold deeply equal concrete values.��//��// Map values are deeply equal when all of the following are true:��// they are both nil or both non-nil, they have the same length,��// and either they are the same map object or their corresponding keys��// (matched using Go equality) map to deeply equal values.��//��// Pointer values are deeply equal if they are equal using Go's == operator��// or if they point to deeply equal values.��//��// Slice values are deeply equal when all of the following are true:��// they are both nil or both non-nil, they have the same length,��// and either they point to the same initial entry of the same underlying array��// (that is, &amp;x[0] == &amp;y[0]) or their corresponding elements (up to length) are deeply equal.��// Note that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil))��// are not deeply equal.��//��// Other values - numbers, bools, strings, and channels - are deeply equal��// if they are equal using Go's == operator.��//��// In general DeepEqual is a recursive relaxation of Go's == operator.��// However, this idea is impossible to implement without some inconsistency.��// Specifically, it is possible for a value to be unequal to itself,��// either because it is of func type (uncomparable in general)��// or because it is a floating-point NaN value (not equal to itself in floating-point comparison),��// or because it is an array, struct, or interface containing��// such a value.��// On the other hand, pointer values are always equal to themselves,��// even if they point at or contain such problematic values,��// because they compare equal using Go's == operator, and that��// is a sufficient condition to be deeply equal, regardless of content.��// DeepEqual has been defined so that the same short-cut applies��// to slices and maps: if x and y are the same slice or the same map,��// they are deeply equal regardless of content.��//��// As DeepEqual traverses the data values it may find a cycle. The��// second and subsequent times that DeepEqual compares two pointer��// values that have been compared before, it treats the values as��// equal rather than examining the values to which they point.��// This ensures that DeepEqual terminates. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L736"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-funcof">function funcOf</a></h2>
<pre><code class="language-haxe">function funcOf(_in:stdgo.Slice&lt;stdgo.reflect.Type&gt;, _out:stdgo.Slice&lt;stdgo.reflect.Type&gt;, _variadic:Bool):stdgo.reflect.Type</code></pre>
<p>FuncOf returns the function type with the given argument and result types.��// For example if k represents int and e represents string,��// FuncOf([]Type{k}, []Type{e}, false) represents func(int) string.��//��// The variadic argument controls whether the function is variadic. FuncOf��// panics if the in[len(in)-1] does not represent a slice and variadic is��// true. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L841"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-indirect">function indirect</a></h2>
<pre><code class="language-haxe">function indirect(_v:stdgo.reflect.Value):stdgo.reflect.Value</code></pre>
<p>Indirect returns the value that v points to.��// If v is a nil pointer, Indirect returns a zero Value.��// If v is not a pointer, Indirect returns v. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L943"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-makechan">function makeChan</a></h2>
<pre><code class="language-haxe">function makeChan(_typ:stdgo.reflect.Type, _buffer:stdgo.GoInt):stdgo.reflect.Value</code></pre>
<p>MakeChan creates a new channel with the specified type and buffer size. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L922"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-makefunc">function makeFunc</a></h2>
<pre><code class="language-haxe">function makeFunc(_typ:stdgo.reflect.Type, _fn:(_args:stdgo.Slice&lt;stdgo.reflect.Value&gt;):stdgo.Slice&lt;stdgo.reflect.Value&gt;):stdgo.reflect.Value</code></pre>
<p>MakeFunc returns a new function of the given Type��// that wraps the function fn. When called, that new function��// does the following:��//��//   - converts its arguments to a slice of Values.��//   - runs results := fn(args).��//   - returns the results as a slice of Values, one per formal result.��//��// The implementation fn can assume that the argument Value slice��// has the number and type of arguments given by typ.��// If typ describes a variadic function, the final Value is itself��// a slice representing the variadic arguments, as in the��// body of a variadic function. The result Value slice returned by fn��// must have the number and type of results given by typ.��//��// The Value.Call method allows the caller to invoke a typed function��// in terms of Values; in contrast, MakeFunc allows the caller to implement��// a typed function in terms of Values.��//��// The Examples section of the documentation includes an illustration��// of how to use MakeFunc to build a swap function for different types. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L771"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-makemap">function makeMap</a></h2>
<pre><code class="language-haxe">function makeMap(_typ:stdgo.reflect.Type):stdgo.reflect.Value</code></pre>
<p>MakeMap creates a new map with the specified type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L928"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-makemapwithsize">function makeMapWithSize</a></h2>
<pre><code class="language-haxe">function makeMapWithSize(_typ:stdgo.reflect.Type, _n:stdgo.GoInt):stdgo.reflect.Value</code></pre>
<p>MakeMapWithSize creates a new map with the specified type��// and initial space for approximately n elements. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L935"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-makeslice">function makeSlice</a></h2>
<pre><code class="language-haxe">function makeSlice(_typ:stdgo.reflect.Type, _len:stdgo.GoInt, _cap:stdgo.GoInt):stdgo.reflect.Value</code></pre>
<p>MakeSlice creates a new zero-initialized slice value��// for the specified slice type, length, and capacity. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L916"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-mapof">function mapOf</a></h2>
<pre><code class="language-haxe">function mapOf(_key:stdgo.reflect.Type, _elem:stdgo.reflect.Type):stdgo.reflect.Type</code></pre>
<p>MapOf returns the map type with the given key and element types.��// For example, if k represents int and e represents string,��// MapOf(k, e) represents map[int]string.��//��// If the key type is not a valid map key type (that is, if it does��// not implement Go's == operator), MapOf panics. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L829"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-newat">function newAt</a></h2>
<pre><code class="language-haxe">function newAt(_typ:stdgo.reflect.Type, _p:stdgo.unsafe.UnsafePointer):stdgo.reflect.Value</code></pre>
<p>NewAt returns a Value representing a pointer to a value of the��// specified type, using p as that pointer. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L979"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-new_">function new_</a></h2>
<pre><code class="language-haxe">function new_(_typ:stdgo.reflect.Type):stdgo.reflect.Value</code></pre>
<p>New returns a Value representing a pointer to a new zero value��// for the specified type. That is, the returned Value's Type is PointerTo(typ). </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L967"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-pointerto">function pointerTo</a></h2>
<pre><code class="language-haxe">function pointerTo(_t:stdgo.reflect.Type):stdgo.reflect.Type</code></pre>
<p>PointerTo returns the pointer type with element t.��// For example, if t represents type Foo, PointerTo(t) represents *Foo. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L808"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-ptrto">function ptrTo</a></h2>
<pre><code class="language-haxe">function ptrTo(_t:stdgo.reflect.Type):stdgo.reflect.Type</code></pre>
<p>PtrTo returns the pointer type with element t.��// For example, if t represents type Foo, PtrTo(t) represents *Foo.��//��// PtrTo is the old spelling of PointerTo.��// The two functions behave identically. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L801"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-select">function select</a></h2>
<pre><code class="language-haxe">function select(_cases:stdgo.Slice&lt;stdgo.reflect.SelectCase&gt;):{_2:Bool, _1:stdgo.reflect.Value, _0:stdgo.GoInt}</code></pre>
<p>Select executes a select operation described by the list of cases.��// Like the Go select statement, it blocks until at least one of the cases��// can proceed, makes a uniform pseudo-random choice,��// and then executes that case. It returns the index of the chosen case��// and, if that case was a receive operation, the value received and a��// boolean indicating whether the value corresponds to a send on the channel��// (as opposed to a zero value received because the channel is closed).��// Select supports a maximum of 65536 cases. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L909"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-sliceof">function sliceOf</a></h2>
<pre><code class="language-haxe">function sliceOf(_t:stdgo.reflect.Type):stdgo.reflect.Type</code></pre>
<p>SliceOf returns the slice type with element type t.��// For example, if t represents int, SliceOf(t) represents []int. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L848"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-structof">function structOf</a></h2>
<pre><code class="language-haxe">function structOf(_fields:stdgo.Slice&lt;stdgo.reflect.StructField&gt;):stdgo.reflect.Type</code></pre>
<p>StructOf returns the struct type containing fields.��// The Offset and Index fields are ignored and computed as they would be��// by the compiler.��//��// StructOf currently does not generate wrapper methods for embedded��// fields and panics if passed unexported StructFields.��// These limitations may be lifted in a future version. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L860"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-swapper">function swapper</a></h2>
<pre><code class="language-haxe">function swapper(_slice:stdgo.AnyInterface):(_i:stdgo.GoInt, _j:stdgo.GoInt):Void</code></pre>
<p>Swapper returns a function that swaps the elements in the provided��// slice.��//��// Swapper panics if the provided interface is not a slice. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L780"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-typeof">function typeOf</a></h2>
<pre><code class="language-haxe">function typeOf(_i:stdgo.AnyInterface):stdgo.reflect.Type</code></pre>
<p>TypeOf returns the reflection Type that represents the dynamic type of i.��// If i is a nil interface value, TypeOf returns nil. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L786"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-valueof">function valueOf</a></h2>
<pre><code class="language-haxe">function valueOf(_i:stdgo.AnyInterface):stdgo.reflect.Value</code></pre>
<p>ValueOf returns a new Value initialized to the concrete value��// stored in the interface i. ValueOf(nil) returns the zero Value. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L949"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-visiblefields">function visibleFields</a></h2>
<pre><code class="language-haxe">function visibleFields(_t:stdgo.reflect.Type):stdgo.Slice&lt;stdgo.reflect.StructField&gt;</code></pre>
<p>VisibleFields returns all the visible fields in t, which must be a��// struct type. A field is defined as visible if it's accessible��// directly with a FieldByName call. The returned fields include fields��// inside anonymous struct members and unexported fields. They follow��// the same order found in the struct, with anonymous fields followed��// immediately by their promoted fields.��//��// For each element e of the returned slice, the corresponding field��// can be retrieved from a value v of type t by calling v.FieldByIndex(e.Index). </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L993"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-zero">function zero</a></h2>
<pre><code class="language-haxe">function zero(_typ:stdgo.reflect.Type):stdgo.reflect.Value</code></pre>
<p>Zero returns a Value representing the zero value for the specified type.��// The result is different from the zero value of the Value struct,��// which represents no value at all.��// For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.��// The returned value is neither addressable nor settable. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L961"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h1><a name="classes">Classes</a></h1>
<pre><code class="language-haxe">import stdgo.reflect.*</code></pre>
<h2>class ChanDir_static_extension</h2>
<h3>ChanDir_static_extension function string</h3>
<pre><code class="language-haxe">function string():stdgo.GoString</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2839"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class Kind_static_extension</h2>
<h3>Kind_static_extension function string</h3>
<pre><code class="language-haxe">function string():stdgo.GoString</code></pre>
<p>String returns the name of k. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2754"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="class-mapiter">class MapIter</a></h2>
<p>A MapIter is an iterator for ranging over a map.��// See Value.MapRange. </p>
<h3><a name="mapiter-function-new">MapIter function new</a></h3>
<pre><code class="language-haxe">function new():Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L537"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="mapiter-function-key">MapIter function key</a></h3>
<pre><code class="language-haxe">function key():stdgo.reflect.Value</code></pre>
<p>Key returns the key of iter's current map entry. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2724"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="mapiter-function-next">MapIter function next</a></h3>
<pre><code class="language-haxe">function next():Bool</code></pre>
<p>Next advances the map iterator and reports whether there is another���// entry. It returns false when iter is exhausted; subsequent���// calls to Key, Value, or Next will panic. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2710"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="mapiter-function-reset">MapIter function reset</a></h3>
<pre><code class="language-haxe">function reset( _v:stdgo.reflect.Value):Void</code></pre>
<p>Reset modifies iter to iterate over v.���// It panics if v's Kind is not Map and v is not the zero Value.���// Reset(Value{}) causes iter to not to refer to any map,���// which may allow the previously iterated-over map to be garbage collected. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2701"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="mapiter-function-value">MapIter function value</a></h3>
<pre><code class="language-haxe">function value():stdgo.reflect.Value</code></pre>
<p>Value returns the value of iter's current map entry. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2717"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class MapIter_static_extension</h2>
<h3>MapIter_static_extension function key</h3>
<pre><code class="language-haxe">function key():stdgo.reflect.Value</code></pre>
<p>Key returns the key of iter's current map entry. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2724"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>MapIter_static_extension function next</h3>
<pre><code class="language-haxe">function next():Bool</code></pre>
<p>Next advances the map iterator and reports whether there is another���// entry. It returns false when iter is exhausted; subsequent���// calls to Key, Value, or Next will panic. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2710"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>MapIter_static_extension function reset</h3>
<pre><code class="language-haxe">function reset( _v:stdgo.reflect.Value):Void</code></pre>
<p>Reset modifies iter to iterate over v.���// It panics if v's Kind is not Map and v is not the zero Value.���// Reset(Value{}) causes iter to not to refer to any map,���// which may allow the previously iterated-over map to be garbage collected. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2701"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>MapIter_static_extension function value</h3>
<pre><code class="language-haxe">function value():stdgo.reflect.Value</code></pre>
<p>Value returns the value of iter's current map entry. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2717"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="class-method">class Method</a></h2>
<p>Method represents a single method. </p>
<pre><code class="language-haxe">var func:stdgo.reflect.Value</code></pre>
<p>func with receiver as first argument </p>
<pre><code class="language-haxe">var index:stdgo.GoInt</code></pre>
<p>index for Type.Method </p>
<pre><code class="language-haxe">var name:stdgo.GoString</code></pre>
<p>Name is the method name. </p>
<pre><code class="language-haxe">var pkgPath:stdgo.GoString</code></pre>
<p>PkgPath is the package path that qualifies a lower case (unexported)���// method name. It is empty for upper case (exported) method names.���// The combination of PkgPath and Name uniquely identifies a method���// in a method set.���// See https://golang.org/ref/spec#Uniqueness_of_identifiers </p>
<pre><code class="language-haxe">var type:stdgo.reflect.Type</code></pre>
<p>method type </p>
<h3><a name="method-function-new">Method function new</a></h3>
<pre><code class="language-haxe">function new(?name:stdgo.GoString, ?pkgPath:stdgo.GoString, ?type:Null&lt;stdgo.reflect.Type&gt;, ?func:stdgo.reflect.Value, ?index:Null&lt;stdgo.GoInt&gt;):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L364"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="method-function-isexported">Method function isExported</a></h3>
<pre><code class="language-haxe">function isExported():Bool</code></pre>
<p>IsExported reports whether the method is exported. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1023"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class Method_static_extension</h2>
<h3>Method_static_extension function isExported</h3>
<pre><code class="language-haxe">function isExported():Bool</code></pre>
<p>IsExported reports whether the method is exported. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1023"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="class-selectcase">class SelectCase</a></h2>
<p>A SelectCase describes a single case in a select operation.��// The kind of case depends on Dir, the communication direction.��//��// If Dir is SelectDefault, the case represents a default case.��// Chan and Send must be zero Values.��//��// If Dir is SelectSend, the case represents a send operation.��// Normally Chan's underlying value must be a channel, and Send's underlying value must be��// assignable to the channel's element type. As a special case, if Chan is a zero Value,��// then the case is ignored, and the field Send will also be ignored and may be either zero��// or non-zero.��//��// If Dir is SelectRecv, the case represents a receive operation.��// Normally Chan's underlying value must be a channel and Send must be a zero Value.��// If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value.��// When a receive operation is selected, the received Value is returned by Select. </p>
<pre><code class="language-haxe">var chan:stdgo.reflect.Value</code></pre>
<p>channel to use (for send or receive) </p>
<pre><code class="language-haxe">var dir:stdgo.reflect.SelectDir</code></pre>
<p>direction of case </p>
<pre><code class="language-haxe">var send:stdgo.reflect.Value</code></pre>
<p>value to send (for send) </p>
<h3><a name="selectcase-function-new">SelectCase function new</a></h3>
<pre><code class="language-haxe">function new(?dir:Null&lt;stdgo.reflect.SelectDir&gt;, ?chan:stdgo.reflect.Value, ?send:stdgo.reflect.Value):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L638"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="class-sliceheader">class SliceHeader</a></h2>
<p>SliceHeader is the runtime representation of a slice.��// It cannot be used safely or portably and its representation may��// change in a later release.��// Moreover, the Data field is not sufficient to guarantee the data��// it references will not be garbage collected, so programs must keep��// a separate, correctly typed pointer to the underlying data. </p>
<pre><code class="language-haxe">var cap:stdgo.GoInt</code></pre>
<pre><code class="language-haxe">var data:stdgo.GoUIntptr</code></pre>
<pre><code class="language-haxe">var len:stdgo.GoInt</code></pre>
<h3><a name="sliceheader-function-new">SliceHeader function new</a></h3>
<pre><code class="language-haxe">function new(?data:stdgo.GoUIntptr, ?len:Null&lt;stdgo.GoInt&gt;, ?cap:Null&lt;stdgo.GoInt&gt;):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L587"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="class-stringheader">class StringHeader</a></h2>
<p>StringHeader is the runtime representation of a string.��// It cannot be used safely or portably and its representation may��// change in a later release.��// Moreover, the Data field is not sufficient to guarantee the data��// it references will not be garbage collected, so programs must keep��// a separate, correctly typed pointer to the underlying data. </p>
<pre><code class="language-haxe">var data:stdgo.GoUIntptr</code></pre>
<pre><code class="language-haxe">var len:stdgo.GoInt</code></pre>
<h3><a name="stringheader-function-new">StringHeader function new</a></h3>
<pre><code class="language-haxe">function new(?data:stdgo.GoUIntptr, ?len:Null&lt;stdgo.GoInt&gt;):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L559"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="class-structfield">class StructField</a></h2>
<p>A StructField describes a single field in a struct. </p>
<pre><code class="language-haxe">var anonymous:Bool</code></pre>
<p>is an embedded field </p>
<pre><code class="language-haxe">var index:stdgo.Slice&lt;stdgo.GoInt&gt;</code></pre>
<p>index sequence for Type.FieldByIndex </p>
<pre><code class="language-haxe">var name:stdgo.GoString</code></pre>
<p>Name is the field name. </p>
<pre><code class="language-haxe">var offset:stdgo.GoUIntptr</code></pre>
<p>offset within struct, in bytes </p>
<pre><code class="language-haxe">var pkgPath:stdgo.GoString</code></pre>
<p>PkgPath is the package path that qualifies a lower case (unexported)���// field name. It is empty for upper case (exported) field names.���// See https://golang.org/ref/spec#Uniqueness_of_identifiers </p>
<pre><code class="language-haxe">var tag:stdgo.reflect.StructTag</code></pre>
<p>field tag string </p>
<pre><code class="language-haxe">var type:stdgo.reflect.Type</code></pre>
<p>field type </p>
<h3><a name="structfield-function-new">StructField function new</a></h3>
<pre><code class="language-haxe">function new(?name:stdgo.GoString, ?pkgPath:stdgo.GoString, ?type:Null&lt;stdgo.reflect.Type&gt;, ?tag:Null&lt;stdgo.reflect.StructTag&gt;, ?offset:stdgo.GoUIntptr, ?index:stdgo.Slice&lt;stdgo.GoInt&gt;, ?anonymous:Bool):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L426"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="structfield-function-isexported">StructField function isExported</a></h3>
<pre><code class="language-haxe">function isExported():Bool</code></pre>
<p>IsExported reports whether the field is exported. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1054"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class StructField_static_extension</h2>
<h3>StructField_static_extension function isExported</h3>
<pre><code class="language-haxe">function isExported():Bool</code></pre>
<p>IsExported reports whether the field is exported. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1054"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class StructTag_static_extension</h2>
<h3>StructTag_static_extension function get</h3>
<pre><code class="language-haxe">function get( _key:stdgo.GoString):stdgo.GoString</code></pre>
<p>Get returns the value associated with key in the tag string.���// If there is no such key in the tag, Get returns the empty string.���// If the tag does not have the conventional format, the value���// returned by Get is unspecified. To determine whether a tag is���// explicitly set to the empty string, use Lookup. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2902"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>StructTag_static_extension function lookup</h3>
<pre><code class="language-haxe">function lookup( _key:stdgo.GoString):{_1:Bool, _0:stdgo.GoString}</code></pre>
<p>Lookup returns the value associated with key in the tag string.���// If the key is present in the tag the value (which may be empty)���// is returned. Otherwise the returned value will be the empty string.���// The ok return value reports whether the value was explicitly set in���// the tag string. If the tag does not have the conventional format,���// the value returned by Lookup is unspecified. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2891"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="class-value">class Value</a></h2>
<p>Value is the reflection interface to a Go value.��//��// Not all methods apply to all kinds of values. Restrictions,��// if any, are noted in the documentation for each method.��// Use the Kind method to find out the kind of value before��// calling kind-specific methods. Calling a method��// inappropriate to the kind of type causes a run time panic.��//��// The zero Value represents no value.��// Its IsValid method returns false, its Kind method returns Invalid,��// its String method returns "\<invalid Value\>", and all other methods panic.��// Most functions and methods never return an invalid value.��// If one does, its documentation states the conditions explicitly.��//��// A Value can be used concurrently by multiple goroutines provided that��// the underlying Go value can be used concurrently for the equivalent��// direct operations.��//��// To compare two Values, compare the results of the Interface method.��// Using == on two Values does not compare the underlying values��// they represent. </p>
<h3><a name="value-function-new">Value function new</a></h3>
<pre><code class="language-haxe">function new(?value:stdgo.AnyInterface, ?underlyingValue:Dynamic, ?underlyingIndex:Null&lt;stdgo.GoInt&gt;, ?underlyingKey:Dynamic, ?canAddrBool:Bool, ?notSetBool:Bool):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L484"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-addr">Value function addr</a></h3>
<pre><code class="language-haxe">function addr():stdgo.reflect.Value</code></pre>
<p>Addr returns a pointer value representing the address of v.���// It panics if CanAddr() returns false.���// Addr is typically used to obtain a pointer to a struct field���// or slice element in order to call a method that requires a���// pointer receiver. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2616"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-bool_">Value function bool_</a></h3>
<pre><code class="language-haxe">function bool_():Bool</code></pre>
<p>Bool returns v's underlying value.���// It panics if v's kind is not Bool. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2605"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-bytes">Value function bytes</a></h3>
<pre><code class="language-haxe">function bytes():stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>Bytes returns v's underlying value.���// It panics if v's underlying value is not a slice of bytes or���// an addressable array of bytes. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2597"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-call">Value function call</a></h3>
<pre><code class="language-haxe">function call( _in:stdgo.Slice&lt;stdgo.reflect.Value&gt;):stdgo.Slice&lt;stdgo.reflect.Value&gt;</code></pre>
<p>Call calls the function v with the input arguments in.���// For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]).���// Call panics if v's Kind is not Func.���// It returns the output results as Values.���// As in Go, each input argument must be assignable to the���// type of the function's corresponding input parameter.���// If v is a variadic function, Call creates the variadic slice parameter���// itself, copying in the corresponding values. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2566"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-callslice">Value function callSlice</a></h3>
<pre><code class="language-haxe">function callSlice( _in:stdgo.Slice&lt;stdgo.reflect.Value&gt;):stdgo.Slice&lt;stdgo.reflect.Value&gt;</code></pre>
<p>CallSlice calls the variadic function v with the input arguments in,���// assigning the slice in[len(in)-1] to v's final variadic argument.���// For example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0], in[1], in[2]...).���// CallSlice panics if v's Kind is not Func or if v is not variadic.���// It returns the output results as Values.���// As in Go, each input argument must be assignable to the���// type of the function's corresponding input parameter. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2552"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-canaddr">Value function canAddr</a></h3>
<pre><code class="language-haxe">function canAddr():Bool</code></pre>
<p>CanAddr reports whether the value's address can be obtained with Addr.���// Such values are called addressable. A value is addressable if it is���// an element of a slice, an element of an addressable array,���// a field of an addressable struct, or the result of dereferencing a pointer.���// If CanAddr returns false, calling Addr will panic. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2588"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-cancomplex">Value function canComplex</a></h3>
<pre><code class="language-haxe">function canComplex():Bool</code></pre>
<p>CanComplex reports whether Complex can be used without panicking. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2523"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-canconvert">Value function canConvert</a></h3>
<pre><code class="language-haxe">function canConvert( _t:stdgo.reflect.Type):Bool</code></pre>
<p>CanConvert reports whether the value v can be converted to type t.���// If v.CanConvert(t) returns true then v.Convert(t) will not panic. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1758"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-canfloat">Value function canFloat</a></h3>
<pre><code class="language-haxe">function canFloat():Bool</code></pre>
<p>CanFloat reports whether Float can be used without panicking. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2410"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-canint">Value function canInt</a></h3>
<pre><code class="language-haxe">function canInt():Bool</code></pre>
<p>CanInt reports whether Int can be used without panicking. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2362"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-caninterface">Value function canInterface</a></h3>
<pre><code class="language-haxe">function canInterface():Bool</code></pre>
<p>CanInterface reports whether Interface can be used without panicking. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2347"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-canset">Value function canSet</a></h3>
<pre><code class="language-haxe">function canSet():Bool</code></pre>
<p>CanSet reports whether the value of v can be changed.���// A Value can be changed only if it is addressable and was not���// obtained by the use of unexported struct fields.���// If CanSet returns false, calling Set or any type-specific���// setter (e.g., SetBool, SetInt) will panic. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2577"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-canuint">Value function canUint</a></h3>
<pre><code class="language-haxe">function canUint():Bool</code></pre>
<p>CanUint reports whether Uint can be used without panicking. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1810"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-cap">Value function cap</a></h3>
<pre><code class="language-haxe">function cap():stdgo.GoInt</code></pre>
<p>Cap returns v's capacity.���// It panics if v's Kind is not Array, Chan, Slice or pointer to Array. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2539"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-close">Value function close</a></h3>
<pre><code class="language-haxe">function close():Void</code></pre>
<p>Close closes the channel v.���// It panics if v's Kind is not Chan. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2531"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-complex">Value function complex</a></h3>
<pre><code class="language-haxe">function complex():stdgo.GoComplex128</code></pre>
<p>Complex returns v's underlying value, as a complex128.���// It panics if v's Kind is not Complex64 or Complex128 </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2516"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-convert">Value function convert</a></h3>
<pre><code class="language-haxe">function convert( _t:stdgo.reflect.Type):stdgo.reflect.Value</code></pre>
<p>Convert returns the value v converted to type t.���// If the usual Go conversion rules do not allow conversion���// of the value v to type t, or if converting v to type t panics, Convert panics. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1767"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-elem">Value function elem</a></h3>
<pre><code class="language-haxe">function elem():stdgo.reflect.Value</code></pre>
<p>Elem returns the value that the interface v contains���// or that the pointer v points to.���// It panics if v's Kind is not Interface or Pointer.���// It returns the zero Value if v is nil. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2478"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-field">Value function field</a></h3>
<pre><code class="language-haxe">function field( _i:stdgo.GoInt):stdgo.reflect.Value</code></pre>
<p>Field returns the i'th field of the struct v.���// It panics if v's Kind is not Struct or i is out of range. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2455"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-fieldbyindex">Value function fieldByIndex</a></h3>
<pre><code class="language-haxe">function fieldByIndex( _index:stdgo.Slice&lt;stdgo.GoInt&gt;):stdgo.reflect.Value</code></pre>
<p>FieldByIndex returns the nested field corresponding to index.���// It panics if evaluation requires stepping through a nil���// pointer or a field that is not a struct. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2448"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-fieldbyindexerr">Value function fieldByIndexErr</a></h3>
<pre><code class="language-haxe">function fieldByIndexErr( _index:stdgo.Slice&lt;stdgo.GoInt&gt;):{_1:stdgo.Error, _0:stdgo.reflect.Value}</code></pre>
<p>FieldByIndexErr returns the nested field corresponding to index.���// It returns an error if evaluation requires stepping through a nil���// pointer, but panics if it must step through a field that���// is not a struct. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2439"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-fieldbyname">Value function fieldByName</a></h3>
<pre><code class="language-haxe">function fieldByName( _name:stdgo.GoString):stdgo.reflect.Value</code></pre>
<p>FieldByName returns the struct field with the given name.���// It returns the zero Value if no field was found.���// It panics if v's Kind is not struct. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2429"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-fieldbynamefunc">Value function fieldByNameFunc</a></h3>
<pre><code class="language-haxe">function fieldByNameFunc( _match:()):stdgo.reflect.Value</code></pre>
<p>FieldByNameFunc returns the struct field with a name���// that satisfies the match function.���// It panics if v's Kind is not struct.���// It returns the zero Value if no field was found. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2420"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-float_">Value function float_</a></h3>
<pre><code class="language-haxe">function float_():stdgo.GoFloat64</code></pre>
<p>Float returns v's underlying value, as a float64.���// It panics if v's Kind is not Float32 or Float64 </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2403"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-index">Value function index</a></h3>
<pre><code class="language-haxe">function index( _i:stdgo.GoInt):stdgo.reflect.Value</code></pre>
<p>Index returns v's i'th element.���// It panics if v's Kind is not Array, Slice, or String or i is out of range. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2369"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-int_">Value function int_</a></h3>
<pre><code class="language-haxe">function int_():stdgo.GoInt64</code></pre>
<p>Int returns v's underlying value, as an int64.���// It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2355"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-interfacedata">Value function interfaceData</a></h3>
<pre><code class="language-haxe">function interfaceData():stdgo.GoArray&lt;stdgo.GoUIntptr&gt;</code></pre>
<p>InterfaceData returns a pair of unspecified uintptr values.���// It panics if v's Kind is not Interface.���//���// In earlier versions of Go, this function returned the interface's���// value as a uintptr pair. As of Go 1.4, the implementation of���// interface values precludes any defined use of InterfaceData.���//���// Deprecated: The memory representation of interface values is not���// compatible with InterfaceData. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2327"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-interface_">Value function interface_</a></h3>
<pre><code class="language-haxe">function interface_():stdgo.AnyInterface</code></pre>
<p>Interface returns v's current value as an interface{}.���// It is equivalent to:���//���//�var i interface{} = (v's underlying value)���//���// It panics if the Value was obtained by accessing���// unexported struct fields. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2340"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-isnil">Value function isNil</a></h3>
<pre><code class="language-haxe">function isNil():Bool</code></pre>
<p>IsNil reports whether its argument v is nil. The argument must be���// a chan, func, interface, map, pointer, or slice value; if it is���// not, IsNil panics. Note that IsNil is not always equivalent to a���// regular comparison with nil in Go. For example, if v was created���// by calling ValueOf with an uninitialized interface variable i,���// i==nil will be true but v.IsNil will panic as v will be the zero���// Value. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2281"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-isvalid">Value function isValid</a></h3>
<pre><code class="language-haxe">function isValid():Bool</code></pre>
<p>IsValid reports whether v represents a value.���// It returns false if v is the zero Value.���// If IsValid returns false, all other methods except String panic.���// Most functions and methods never return an invalid Value.���// If one does, its documentation states the conditions explicitly. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2269"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-iszero">Value function isZero</a></h3>
<pre><code class="language-haxe">function isZero():Bool</code></pre>
<p>IsZero reports whether v is the zero value for its type.���// It panics if the argument is invalid. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2258"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-kind">Value function kind</a></h3>
<pre><code class="language-haxe">function kind():stdgo.reflect.Kind</code></pre>
<p>Kind returns v's Kind.���// If v is the zero Value (IsValid returns false), Kind returns Invalid. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2250"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-len">Value function len</a></h3>
<pre><code class="language-haxe">function len():stdgo.GoInt</code></pre>
<p>Len returns v's length.���// It panics if v's Kind is not Array, Chan, Map, Slice, String, or pointer to Array. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2216"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-mapindex">Value function mapIndex</a></h3>
<pre><code class="language-haxe">function mapIndex( _key:stdgo.reflect.Value):stdgo.reflect.Value</code></pre>
<p>MapIndex returns the value associated with key in the map v.���// It panics if v's Kind is not Map.���// It returns the zero Value if key is not found in the map or if v represents a nil map.���// As in Go, the key's value must be assignable to the map's key type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2209"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-mapkeys">Value function mapKeys</a></h3>
<pre><code class="language-haxe">function mapKeys():stdgo.Slice&lt;stdgo.reflect.Value&gt;</code></pre>
<p>MapKeys returns a slice containing all the keys present in the map,���// in unspecified order.���// It panics if v's Kind is not Map.���// It returns an empty slice if v represents a nil map. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2199"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-maprange">Value function mapRange</a></h3>
<pre><code class="language-haxe">function mapRange():stdgo.Ref&lt;stdgo.reflect.MapIter&gt;</code></pre>
<p>MapRange returns a range iterator for a map.���// It panics if v's Kind is not Map.���//���// Call Next to advance the iterator, and Key/Value to access each entry.���// Next returns false when the iterator is exhausted.���// MapRange follows the same iteration semantics as a range statement.���//���// Example:���//���//�iter := reflect.ValueOf(m).MapRange()���//�for iter.Next() {���//��k := iter.Key()���//��v := iter.Value()���//��...���//�} </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2171"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-method">Value function method</a></h3>
<pre><code class="language-haxe">function method( _i:stdgo.GoInt):stdgo.reflect.Value</code></pre>
<p>Method returns a function value corresponding to v's i'th method.���// The arguments to a Call on the returned function should not include���// a receiver; the returned function will always use v as the receiver.���// Method panics if i is out of range or if v is a nil interface value. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2150"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-methodbyname">Value function methodByName</a></h3>
<pre><code class="language-haxe">function methodByName( _name:stdgo.GoString):stdgo.reflect.Value</code></pre>
<p>MethodByName returns a function value corresponding to the method���// of v with the given name.���// The arguments to a Call on the returned function should not include���// a receiver; the returned function will always use v as the receiver.���// It returns the zero Value if no method was found. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2129"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-numfield">Value function numField</a></h3>
<pre><code class="language-haxe">function numField():stdgo.GoInt</code></pre>
<p>NumField returns the number of fields in the struct v.���// It panics if v's Kind is not Struct. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2118"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-nummethod">Value function numMethod</a></h3>
<pre><code class="language-haxe">function numMethod():stdgo.GoInt</code></pre>
<p>NumMethod returns the number of methods in the value's method set.���//���// For a non-interface type, it returns the number of exported methods.���//���// For an interface type, it returns the number of exported and unexported methods. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2140"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-overflowcomplex">Value function overflowComplex</a></h3>
<pre><code class="language-haxe">function overflowComplex( _x:stdgo.GoComplex128):Bool</code></pre>
<p>OverflowComplex reports whether the complex128 x cannot be represented by v's type.���// It panics if v's Kind is not Complex64 or Complex128. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2110"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-overflowfloat">Value function overflowFloat</a></h3>
<pre><code class="language-haxe">function overflowFloat( _x:stdgo.GoFloat64):Bool</code></pre>
<p>OverflowFloat reports whether the float64 x cannot be represented by v's type.���// It panics if v's Kind is not Float32 or Float64. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2102"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-overflowint">Value function overflowInt</a></h3>
<pre><code class="language-haxe">function overflowInt( _x:stdgo.GoInt64):Bool</code></pre>
<p>OverflowInt reports whether the int64 x cannot be represented by v's type.���// It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2094"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-overflowuint">Value function overflowUint</a></h3>
<pre><code class="language-haxe">function overflowUint( _x:stdgo.GoUInt64):Bool</code></pre>
<p>OverflowUint reports whether the uint64 x cannot be represented by v's type.���// It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2086"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-pointer">Value function pointer</a></h3>
<pre><code class="language-haxe">function pointer():stdgo.GoUIntptr</code></pre>
<p>Pointer returns v's value as a uintptr.���// It returns uintptr instead of unsafe.Pointer so that���// code using reflect cannot obtain unsafe.Pointers���// without importing the unsafe package explicitly.���// It panics if v's Kind is not Chan, Func, Map, Pointer, Slice, or UnsafePointer.���//���// If v's Kind is Func, the returned pointer is an underlying���// code pointer, but not necessarily enough to identify a���// single function uniquely. The only guarantee is that the���// result is zero if and only if v is a nil func Value.���//���// If v's Kind is Slice, the returned pointer is to the first���// element of the slice. If the slice is nil the returned value���// is 0.  If the slice is empty but non-nil the return value is non-zero.���//���// It's preferred to use uintptr(Value.UnsafePointer()) to get the equivalent result. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2073"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-recv">Value function recv</a></h3>
<pre><code class="language-haxe">function recv():{_1:Bool, _0:stdgo.reflect.Value}</code></pre>
<p>Recv receives and returns a value from the channel v.���// It panics if v's Kind is not Chan.���// The receive blocks until a value is ready.���// The boolean value ok is true if the value x corresponds to a send���// on the channel, false if it is a zero value received because the channel is closed. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2052"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-send">Value function send</a></h3>
<pre><code class="language-haxe">function send( _x:stdgo.reflect.Value):Void</code></pre>
<p>Send sends x on the channel v.���// It panics if v's kind is not Chan or if x's type is not the same type as v's element type.���// As in Go, x's value must be assignable to the channel's element type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2041"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-set">Value function set</a></h3>
<pre><code class="language-haxe">function set( _x:stdgo.reflect.Value):Void</code></pre>
<p>Set assigns x to the value v.���// It panics if CanSet returns false.���// As in Go, x's value must be assignable to v's type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1985"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-setbool">Value function setBool</a></h3>
<pre><code class="language-haxe">function setBool( _x:Bool):Void</code></pre>
<p>SetBool sets v's underlying value.���// It panics if v's Kind is not Bool or if CanSet() is false. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1977"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-setbytes">Value function setBytes</a></h3>
<pre><code class="language-haxe">function setBytes( _x:stdgo.Slice&lt;stdgo.GoByte&gt;):Void</code></pre>
<p>SetBytes sets v's underlying value.���// It panics if v's underlying value is not a slice of bytes. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1969"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-setcap">Value function setCap</a></h3>
<pre><code class="language-haxe">function setCap( _n:stdgo.GoInt):Void</code></pre>
<p>SetCap sets v's capacity to n.���// It panics if v's Kind is not Slice or if n is smaller than the length or���// greater than the capacity of the slice. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1928"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-setcomplex">Value function setComplex</a></h3>
<pre><code class="language-haxe">function setComplex( _x:stdgo.GoComplex128):Void</code></pre>
<p>SetComplex sets v's underlying value to x.���// It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1961"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-setfloat">Value function setFloat</a></h3>
<pre><code class="language-haxe">function setFloat( _x:stdgo.GoFloat64):Void</code></pre>
<p>SetFloat sets v's underlying value to x.���// It panics if v's Kind is not Float32 or Float64, or if CanSet() is false. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1953"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-setint">Value function setInt</a></h3>
<pre><code class="language-haxe">function setInt( _x:stdgo.GoInt64):Void</code></pre>
<p>SetInt sets v's underlying value to x.���// It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1945"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-setiterkey">Value function setIterKey</a></h3>
<pre><code class="language-haxe">function setIterKey( _iter:stdgo.Ref&lt;stdgo.reflect.MapIter&gt;):Void</code></pre>
<p>SetIterKey assigns to v the key of iter's current map entry.���// It is equivalent to v.Set(iter.Key()), but it avoids allocating a new Value.���// As in Go, the key must be assignable to v's type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2189"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-setitervalue">Value function setIterValue</a></h3>
<pre><code class="language-haxe">function setIterValue( _iter:stdgo.Ref&lt;stdgo.reflect.MapIter&gt;):Void</code></pre>
<p>SetIterValue assigns to v the value of iter's current map entry.���// It is equivalent to v.Set(iter.Value()), but it avoids allocating a new Value.���// As in Go, the value must be assignable to v's type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2180"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-setlen">Value function setLen</a></h3>
<pre><code class="language-haxe">function setLen( _n:stdgo.GoInt):Void</code></pre>
<p>SetLen sets v's length to n.���// It panics if v's Kind is not Slice or if n is negative or���// greater than the capacity of the slice. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1937"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-setmapindex">Value function setMapIndex</a></h3>
<pre><code class="language-haxe">function setMapIndex( _key:stdgo.reflect.Value, _elem:stdgo.reflect.Value):Void</code></pre>
<p>SetMapIndex sets the element associated with key in the map v to elem.���// It panics if v's Kind is not Map.���// If elem is the zero Value, SetMapIndex deletes the key from the map.���// Otherwise if v holds a nil map, SetMapIndex will panic.���// As in Go, key's elem must be assignable to the map's key type,���// and elem's value must be assignable to the map's elem type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1919"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-setpointer">Value function setPointer</a></h3>
<pre><code class="language-haxe">function setPointer( _x:stdgo.unsafe.UnsafePointer):Void</code></pre>
<p>SetPointer sets the unsafe.Pointer value v to x.���// It panics if v's Kind is not UnsafePointer. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1899"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-setstring">Value function setString</a></h3>
<pre><code class="language-haxe">function setString( _x:stdgo.GoString):Void</code></pre>
<p>SetString sets v's underlying value to x.���// It panics if v's Kind is not String or if CanSet() is false. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1891"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-setuint">Value function setUint</a></h3>
<pre><code class="language-haxe">function setUint( _x:stdgo.GoUInt64):Void</code></pre>
<p>SetUint sets v's underlying value to x.���// It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1907"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-slice">Value function slice</a></h3>
<pre><code class="language-haxe">function slice( _i:stdgo.GoInt, _j:stdgo.GoInt):stdgo.reflect.Value</code></pre>
<p>Slice returns v[i:j].���// It panics if v's Kind is not Array, Slice or String, or if v is an unaddressable array,���// or if the indexes are out of bounds. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1883"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-slice3">Value function slice3</a></h3>
<pre><code class="language-haxe">function slice3( _i:stdgo.GoInt, _j:stdgo.GoInt, _k:stdgo.GoInt):stdgo.reflect.Value</code></pre>
<p>Slice3 is the 3-index form of the slice operation: it returns v[i:j:k].���// It panics if v's Kind is not Array or Slice, or if v is an unaddressable array,���// or if the indexes are out of bounds. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1874"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-string">Value function string</a></h3>
<pre><code class="language-haxe">function string():stdgo.GoString</code></pre>
<p>String returns the string v's underlying value, as a string.���// String is a special case because of Go's String method convention.���// Unlike the other getters, it does not panic if v's Kind is not String.���// Instead, it returns a string of the form "\<T value\>" where T is v's type.���// The fmt package treats Values specially. It does not call their String���// method implicitly but instead prints the concrete values they hold. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1849"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-tryrecv">Value function tryRecv</a></h3>
<pre><code class="language-haxe">function tryRecv():{_1:Bool, _0:stdgo.reflect.Value}</code></pre>
<p>TryRecv attempts to receive a value from the channel v but will not block.���// It panics if v's Kind is not Chan.���// If the receive delivers a value, x is the transferred value and ok is true.���// If the receive cannot finish without blocking, x is the zero Value and ok is false.���// If the channel is closed, x is the zero value for the channel's element type and ok is false. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1838"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-trysend">Value function trySend</a></h3>
<pre><code class="language-haxe">function trySend( _x:stdgo.reflect.Value):Bool</code></pre>
<p>TrySend attempts to send x on the channel v but will not block.���// It panics if v's Kind is not Chan.���// It reports whether the value was sent.���// As in Go, x's value must be assignable to the channel's element type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1827"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-type">Value function type</a></h3>
<pre><code class="language-haxe">function type():stdgo.reflect.Type</code></pre>
<p>Type returns v's type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1817"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-uint">Value function uint</a></h3>
<pre><code class="language-haxe">function uint():stdgo.GoUInt64</code></pre>
<p>Uint returns v's underlying value, as a uint64.���// It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1803"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-unsafeaddr">Value function unsafeAddr</a></h3>
<pre><code class="language-haxe">function unsafeAddr():stdgo.GoUIntptr</code></pre>
<p>UnsafeAddr returns a pointer to v's data, as a uintptr.���// It is for advanced clients that also import the "unsafe" package.���// It panics if v is not addressable.���//���// It's preferred to use uintptr(Value.Addr().UnsafePointer()) to get the equivalent result. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1795"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="value-function-unsafepointer">Value function unsafePointer</a></h3>
<pre><code class="language-haxe">function unsafePointer():stdgo.unsafe.UnsafePointer</code></pre>
<p>UnsafePointer returns v's value as a unsafe.Pointer.���// It panics if v's Kind is not Chan, Func, Map, Pointer, Slice, or UnsafePointer.���//���// If v's Kind is Func, the returned pointer is an underlying���// code pointer, but not necessarily enough to identify a���// single function uniquely. The only guarantee is that the���// result is zero if and only if v is a nil func Value.���//���// If v's Kind is Slice, the returned pointer is to the first���// element of the slice. If the slice is nil the returned value���// is nil.  If the slice is empty but non-nil the return value is non-nil. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1784"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="class-valueerror">class ValueError</a></h2>
<p>A ValueError occurs when a Value method is invoked on��// a Value that does not support it. Such cases are documented��// in the description of each method. </p>
<pre><code class="language-haxe">var kind:stdgo.reflect.Kind</code></pre>
<pre><code class="language-haxe">var method:stdgo.GoString</code></pre>
<h3><a name="valueerror-function-new">ValueError function new</a></h3>
<pre><code class="language-haxe">function new(?method:stdgo.GoString, ?kind:Null&lt;stdgo.reflect.Kind&gt;):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L517"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="valueerror-function-error">ValueError function error</a></h3>
<pre><code class="language-haxe">function error():stdgo.GoString</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2641"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class ValueError_static_extension</h2>
<h3>ValueError_static_extension function error</h3>
<pre><code class="language-haxe">function error():stdgo.GoString</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2641"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class Value_static_extension</h2>
<h3>Value_static_extension function addr</h3>
<pre><code class="language-haxe">function addr():stdgo.reflect.Value</code></pre>
<p>Addr returns a pointer value representing the address of v.���// It panics if CanAddr() returns false.���// Addr is typically used to obtain a pointer to a struct field���// or slice element in order to call a method that requires a���// pointer receiver. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2616"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static\<em>extension function bool\</em></h3>
<pre><code class="language-haxe">function bool_():Bool</code></pre>
<p>Bool returns v's underlying value.���// It panics if v's kind is not Bool. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2605"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function bytes</h3>
<pre><code class="language-haxe">function bytes():stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>Bytes returns v's underlying value.���// It panics if v's underlying value is not a slice of bytes or���// an addressable array of bytes. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2597"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function call</h3>
<pre><code class="language-haxe">function call( _in:stdgo.Slice&lt;stdgo.reflect.Value&gt;):stdgo.Slice&lt;stdgo.reflect.Value&gt;</code></pre>
<p>Call calls the function v with the input arguments in.���// For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]).���// Call panics if v's Kind is not Func.���// It returns the output results as Values.���// As in Go, each input argument must be assignable to the���// type of the function's corresponding input parameter.���// If v is a variadic function, Call creates the variadic slice parameter���// itself, copying in the corresponding values. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2566"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function callSlice</h3>
<pre><code class="language-haxe">function callSlice( _in:stdgo.Slice&lt;stdgo.reflect.Value&gt;):stdgo.Slice&lt;stdgo.reflect.Value&gt;</code></pre>
<p>CallSlice calls the variadic function v with the input arguments in,���// assigning the slice in[len(in)-1] to v's final variadic argument.���// For example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0], in[1], in[2]...).���// CallSlice panics if v's Kind is not Func or if v is not variadic.���// It returns the output results as Values.���// As in Go, each input argument must be assignable to the���// type of the function's corresponding input parameter. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2552"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function canAddr</h3>
<pre><code class="language-haxe">function canAddr():Bool</code></pre>
<p>CanAddr reports whether the value's address can be obtained with Addr.���// Such values are called addressable. A value is addressable if it is���// an element of a slice, an element of an addressable array,���// a field of an addressable struct, or the result of dereferencing a pointer.���// If CanAddr returns false, calling Addr will panic. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2588"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function canComplex</h3>
<pre><code class="language-haxe">function canComplex():Bool</code></pre>
<p>CanComplex reports whether Complex can be used without panicking. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2523"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function canConvert</h3>
<pre><code class="language-haxe">function canConvert( _t:stdgo.reflect.Type):Bool</code></pre>
<p>CanConvert reports whether the value v can be converted to type t.���// If v.CanConvert(t) returns true then v.Convert(t) will not panic. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1758"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function canFloat</h3>
<pre><code class="language-haxe">function canFloat():Bool</code></pre>
<p>CanFloat reports whether Float can be used without panicking. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2410"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function canInt</h3>
<pre><code class="language-haxe">function canInt():Bool</code></pre>
<p>CanInt reports whether Int can be used without panicking. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2362"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function canInterface</h3>
<pre><code class="language-haxe">function canInterface():Bool</code></pre>
<p>CanInterface reports whether Interface can be used without panicking. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2347"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function canSet</h3>
<pre><code class="language-haxe">function canSet():Bool</code></pre>
<p>CanSet reports whether the value of v can be changed.���// A Value can be changed only if it is addressable and was not���// obtained by the use of unexported struct fields.���// If CanSet returns false, calling Set or any type-specific���// setter (e.g., SetBool, SetInt) will panic. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2577"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function canUint</h3>
<pre><code class="language-haxe">function canUint():Bool</code></pre>
<p>CanUint reports whether Uint can be used without panicking. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1810"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function cap</h3>
<pre><code class="language-haxe">function cap():stdgo.GoInt</code></pre>
<p>Cap returns v's capacity.���// It panics if v's Kind is not Array, Chan, Slice or pointer to Array. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2539"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function close</h3>
<pre><code class="language-haxe">function close():Void</code></pre>
<p>Close closes the channel v.���// It panics if v's Kind is not Chan. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2531"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function complex</h3>
<pre><code class="language-haxe">function complex():stdgo.GoComplex128</code></pre>
<p>Complex returns v's underlying value, as a complex128.���// It panics if v's Kind is not Complex64 or Complex128 </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2516"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function convert</h3>
<pre><code class="language-haxe">function convert( _t:stdgo.reflect.Type):stdgo.reflect.Value</code></pre>
<p>Convert returns the value v converted to type t.���// If the usual Go conversion rules do not allow conversion���// of the value v to type t, or if converting v to type t panics, Convert panics. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1767"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function elem</h3>
<pre><code class="language-haxe">function elem():stdgo.reflect.Value</code></pre>
<p>Elem returns the value that the interface v contains���// or that the pointer v points to.���// It panics if v's Kind is not Interface or Pointer.���// It returns the zero Value if v is nil. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2478"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function field</h3>
<pre><code class="language-haxe">function field( _i:stdgo.GoInt):stdgo.reflect.Value</code></pre>
<p>Field returns the i'th field of the struct v.���// It panics if v's Kind is not Struct or i is out of range. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2455"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function fieldByIndex</h3>
<pre><code class="language-haxe">function fieldByIndex( _index:stdgo.Slice&lt;stdgo.GoInt&gt;):stdgo.reflect.Value</code></pre>
<p>FieldByIndex returns the nested field corresponding to index.���// It panics if evaluation requires stepping through a nil���// pointer or a field that is not a struct. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2448"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function fieldByIndexErr</h3>
<pre><code class="language-haxe">function fieldByIndexErr( _index:stdgo.Slice&lt;stdgo.GoInt&gt;):{_1:stdgo.Error, _0:stdgo.reflect.Value}</code></pre>
<p>FieldByIndexErr returns the nested field corresponding to index.���// It returns an error if evaluation requires stepping through a nil���// pointer, but panics if it must step through a field that���// is not a struct. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2439"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function fieldByName</h3>
<pre><code class="language-haxe">function fieldByName( _name:stdgo.GoString):stdgo.reflect.Value</code></pre>
<p>FieldByName returns the struct field with the given name.���// It returns the zero Value if no field was found.���// It panics if v's Kind is not struct. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2429"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function fieldByNameFunc</h3>
<pre><code class="language-haxe">function fieldByNameFunc( _match:()):stdgo.reflect.Value</code></pre>
<p>FieldByNameFunc returns the struct field with a name���// that satisfies the match function.���// It panics if v's Kind is not struct.���// It returns the zero Value if no field was found. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2420"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static\<em>extension function float\</em></h3>
<pre><code class="language-haxe">function float_():stdgo.GoFloat64</code></pre>
<p>Float returns v's underlying value, as a float64.���// It panics if v's Kind is not Float32 or Float64 </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2403"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function index</h3>
<pre><code class="language-haxe">function index( _i:stdgo.GoInt):stdgo.reflect.Value</code></pre>
<p>Index returns v's i'th element.���// It panics if v's Kind is not Array, Slice, or String or i is out of range. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2369"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static\<em>extension function int\</em></h3>
<pre><code class="language-haxe">function int_():stdgo.GoInt64</code></pre>
<p>Int returns v's underlying value, as an int64.���// It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2355"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function interfaceData</h3>
<pre><code class="language-haxe">function interfaceData():stdgo.GoArray&lt;stdgo.GoUIntptr&gt;</code></pre>
<p>InterfaceData returns a pair of unspecified uintptr values.���// It panics if v's Kind is not Interface.���//���// In earlier versions of Go, this function returned the interface's���// value as a uintptr pair. As of Go 1.4, the implementation of���// interface values precludes any defined use of InterfaceData.���//���// Deprecated: The memory representation of interface values is not���// compatible with InterfaceData. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2327"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static\<em>extension function interface\</em></h3>
<pre><code class="language-haxe">function interface_():stdgo.AnyInterface</code></pre>
<p>Interface returns v's current value as an interface{}.���// It is equivalent to:���//���//�var i interface{} = (v's underlying value)���//���// It panics if the Value was obtained by accessing���// unexported struct fields. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2340"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function isNil</h3>
<pre><code class="language-haxe">function isNil():Bool</code></pre>
<p>IsNil reports whether its argument v is nil. The argument must be���// a chan, func, interface, map, pointer, or slice value; if it is���// not, IsNil panics. Note that IsNil is not always equivalent to a���// regular comparison with nil in Go. For example, if v was created���// by calling ValueOf with an uninitialized interface variable i,���// i==nil will be true but v.IsNil will panic as v will be the zero���// Value. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2281"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function isValid</h3>
<pre><code class="language-haxe">function isValid():Bool</code></pre>
<p>IsValid reports whether v represents a value.���// It returns false if v is the zero Value.���// If IsValid returns false, all other methods except String panic.���// Most functions and methods never return an invalid Value.���// If one does, its documentation states the conditions explicitly. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2269"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function isZero</h3>
<pre><code class="language-haxe">function isZero():Bool</code></pre>
<p>IsZero reports whether v is the zero value for its type.���// It panics if the argument is invalid. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2258"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function kind</h3>
<pre><code class="language-haxe">function kind():stdgo.reflect.Kind</code></pre>
<p>Kind returns v's Kind.���// If v is the zero Value (IsValid returns false), Kind returns Invalid. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2250"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function len</h3>
<pre><code class="language-haxe">function len():stdgo.GoInt</code></pre>
<p>Len returns v's length.���// It panics if v's Kind is not Array, Chan, Map, Slice, String, or pointer to Array. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2216"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function mapIndex</h3>
<pre><code class="language-haxe">function mapIndex( _key:stdgo.reflect.Value):stdgo.reflect.Value</code></pre>
<p>MapIndex returns the value associated with key in the map v.���// It panics if v's Kind is not Map.���// It returns the zero Value if key is not found in the map or if v represents a nil map.���// As in Go, the key's value must be assignable to the map's key type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2209"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function mapKeys</h3>
<pre><code class="language-haxe">function mapKeys():stdgo.Slice&lt;stdgo.reflect.Value&gt;</code></pre>
<p>MapKeys returns a slice containing all the keys present in the map,���// in unspecified order.���// It panics if v's Kind is not Map.���// It returns an empty slice if v represents a nil map. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2199"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function mapRange</h3>
<pre><code class="language-haxe">function mapRange():stdgo.Ref&lt;stdgo.reflect.MapIter&gt;</code></pre>
<p>MapRange returns a range iterator for a map.���// It panics if v's Kind is not Map.���//���// Call Next to advance the iterator, and Key/Value to access each entry.���// Next returns false when the iterator is exhausted.���// MapRange follows the same iteration semantics as a range statement.���//���// Example:���//���//�iter := reflect.ValueOf(m).MapRange()���//�for iter.Next() {���//��k := iter.Key()���//��v := iter.Value()���//��...���//�} </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2171"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function method</h3>
<pre><code class="language-haxe">function method( _i:stdgo.GoInt):stdgo.reflect.Value</code></pre>
<p>Method returns a function value corresponding to v's i'th method.���// The arguments to a Call on the returned function should not include���// a receiver; the returned function will always use v as the receiver.���// Method panics if i is out of range or if v is a nil interface value. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2150"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function methodByName</h3>
<pre><code class="language-haxe">function methodByName( _name:stdgo.GoString):stdgo.reflect.Value</code></pre>
<p>MethodByName returns a function value corresponding to the method���// of v with the given name.���// The arguments to a Call on the returned function should not include���// a receiver; the returned function will always use v as the receiver.���// It returns the zero Value if no method was found. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2129"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function numField</h3>
<pre><code class="language-haxe">function numField():stdgo.GoInt</code></pre>
<p>NumField returns the number of fields in the struct v.���// It panics if v's Kind is not Struct. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2118"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function numMethod</h3>
<pre><code class="language-haxe">function numMethod():stdgo.GoInt</code></pre>
<p>NumMethod returns the number of methods in the value's method set.���//���// For a non-interface type, it returns the number of exported methods.���//���// For an interface type, it returns the number of exported and unexported methods. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2140"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function overflowComplex</h3>
<pre><code class="language-haxe">function overflowComplex( _x:stdgo.GoComplex128):Bool</code></pre>
<p>OverflowComplex reports whether the complex128 x cannot be represented by v's type.���// It panics if v's Kind is not Complex64 or Complex128. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2110"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function overflowFloat</h3>
<pre><code class="language-haxe">function overflowFloat( _x:stdgo.GoFloat64):Bool</code></pre>
<p>OverflowFloat reports whether the float64 x cannot be represented by v's type.���// It panics if v's Kind is not Float32 or Float64. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2102"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function overflowInt</h3>
<pre><code class="language-haxe">function overflowInt( _x:stdgo.GoInt64):Bool</code></pre>
<p>OverflowInt reports whether the int64 x cannot be represented by v's type.���// It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2094"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function overflowUint</h3>
<pre><code class="language-haxe">function overflowUint( _x:stdgo.GoUInt64):Bool</code></pre>
<p>OverflowUint reports whether the uint64 x cannot be represented by v's type.���// It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2086"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function pointer</h3>
<pre><code class="language-haxe">function pointer():stdgo.GoUIntptr</code></pre>
<p>Pointer returns v's value as a uintptr.���// It returns uintptr instead of unsafe.Pointer so that���// code using reflect cannot obtain unsafe.Pointers���// without importing the unsafe package explicitly.���// It panics if v's Kind is not Chan, Func, Map, Pointer, Slice, or UnsafePointer.���//���// If v's Kind is Func, the returned pointer is an underlying���// code pointer, but not necessarily enough to identify a���// single function uniquely. The only guarantee is that the���// result is zero if and only if v is a nil func Value.���//���// If v's Kind is Slice, the returned pointer is to the first���// element of the slice. If the slice is nil the returned value���// is 0.  If the slice is empty but non-nil the return value is non-zero.���//���// It's preferred to use uintptr(Value.UnsafePointer()) to get the equivalent result. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2073"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function recv</h3>
<pre><code class="language-haxe">function recv():{_1:Bool, _0:stdgo.reflect.Value}</code></pre>
<p>Recv receives and returns a value from the channel v.���// It panics if v's Kind is not Chan.���// The receive blocks until a value is ready.���// The boolean value ok is true if the value x corresponds to a send���// on the channel, false if it is a zero value received because the channel is closed. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2052"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function send</h3>
<pre><code class="language-haxe">function send( _x:stdgo.reflect.Value):Void</code></pre>
<p>Send sends x on the channel v.���// It panics if v's kind is not Chan or if x's type is not the same type as v's element type.���// As in Go, x's value must be assignable to the channel's element type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2041"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function set</h3>
<pre><code class="language-haxe">function set( _x:stdgo.reflect.Value):Void</code></pre>
<p>Set assigns x to the value v.���// It panics if CanSet returns false.���// As in Go, x's value must be assignable to v's type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1985"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function setBool</h3>
<pre><code class="language-haxe">function setBool( _x:Bool):Void</code></pre>
<p>SetBool sets v's underlying value.���// It panics if v's Kind is not Bool or if CanSet() is false. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1977"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function setBytes</h3>
<pre><code class="language-haxe">function setBytes( _x:stdgo.Slice&lt;stdgo.GoByte&gt;):Void</code></pre>
<p>SetBytes sets v's underlying value.���// It panics if v's underlying value is not a slice of bytes. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1969"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function setCap</h3>
<pre><code class="language-haxe">function setCap( _n:stdgo.GoInt):Void</code></pre>
<p>SetCap sets v's capacity to n.���// It panics if v's Kind is not Slice or if n is smaller than the length or���// greater than the capacity of the slice. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1928"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function setComplex</h3>
<pre><code class="language-haxe">function setComplex( _x:stdgo.GoComplex128):Void</code></pre>
<p>SetComplex sets v's underlying value to x.���// It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1961"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function setFloat</h3>
<pre><code class="language-haxe">function setFloat( _x:stdgo.GoFloat64):Void</code></pre>
<p>SetFloat sets v's underlying value to x.���// It panics if v's Kind is not Float32 or Float64, or if CanSet() is false. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1953"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function setInt</h3>
<pre><code class="language-haxe">function setInt( _x:stdgo.GoInt64):Void</code></pre>
<p>SetInt sets v's underlying value to x.���// It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1945"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function setIterKey</h3>
<pre><code class="language-haxe">function setIterKey( _iter:stdgo.Ref&lt;stdgo.reflect.MapIter&gt;):Void</code></pre>
<p>SetIterKey assigns to v the key of iter's current map entry.���// It is equivalent to v.Set(iter.Key()), but it avoids allocating a new Value.���// As in Go, the key must be assignable to v's type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2189"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function setIterValue</h3>
<pre><code class="language-haxe">function setIterValue( _iter:stdgo.Ref&lt;stdgo.reflect.MapIter&gt;):Void</code></pre>
<p>SetIterValue assigns to v the value of iter's current map entry.���// It is equivalent to v.Set(iter.Value()), but it avoids allocating a new Value.���// As in Go, the value must be assignable to v's type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2180"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function setLen</h3>
<pre><code class="language-haxe">function setLen( _n:stdgo.GoInt):Void</code></pre>
<p>SetLen sets v's length to n.���// It panics if v's Kind is not Slice or if n is negative or���// greater than the capacity of the slice. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1937"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function setMapIndex</h3>
<pre><code class="language-haxe">function setMapIndex( _key:stdgo.reflect.Value, _elem:stdgo.reflect.Value):Void</code></pre>
<p>SetMapIndex sets the element associated with key in the map v to elem.���// It panics if v's Kind is not Map.���// If elem is the zero Value, SetMapIndex deletes the key from the map.���// Otherwise if v holds a nil map, SetMapIndex will panic.���// As in Go, key's elem must be assignable to the map's key type,���// and elem's value must be assignable to the map's elem type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1919"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function setPointer</h3>
<pre><code class="language-haxe">function setPointer( _x:stdgo.unsafe.UnsafePointer):Void</code></pre>
<p>SetPointer sets the unsafe.Pointer value v to x.���// It panics if v's Kind is not UnsafePointer. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1899"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function setString</h3>
<pre><code class="language-haxe">function setString( _x:stdgo.GoString):Void</code></pre>
<p>SetString sets v's underlying value to x.���// It panics if v's Kind is not String or if CanSet() is false. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1891"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function setUint</h3>
<pre><code class="language-haxe">function setUint( _x:stdgo.GoUInt64):Void</code></pre>
<p>SetUint sets v's underlying value to x.���// It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1907"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function slice</h3>
<pre><code class="language-haxe">function slice( _i:stdgo.GoInt, _j:stdgo.GoInt):stdgo.reflect.Value</code></pre>
<p>Slice returns v[i:j].���// It panics if v's Kind is not Array, Slice or String, or if v is an unaddressable array,���// or if the indexes are out of bounds. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1883"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function slice3</h3>
<pre><code class="language-haxe">function slice3( _i:stdgo.GoInt, _j:stdgo.GoInt, _k:stdgo.GoInt):stdgo.reflect.Value</code></pre>
<p>Slice3 is the 3-index form of the slice operation: it returns v[i:j:k].���// It panics if v's Kind is not Array or Slice, or if v is an unaddressable array,���// or if the indexes are out of bounds. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1874"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function string</h3>
<pre><code class="language-haxe">function string():stdgo.GoString</code></pre>
<p>String returns the string v's underlying value, as a string.���// String is a special case because of Go's String method convention.���// Unlike the other getters, it does not panic if v's Kind is not String.���// Instead, it returns a string of the form "\<T value\>" where T is v's type.���// The fmt package treats Values specially. It does not call their String���// method implicitly but instead prints the concrete values they hold. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1849"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function tryRecv</h3>
<pre><code class="language-haxe">function tryRecv():{_1:Bool, _0:stdgo.reflect.Value}</code></pre>
<p>TryRecv attempts to receive a value from the channel v but will not block.���// It panics if v's Kind is not Chan.���// If the receive delivers a value, x is the transferred value and ok is true.���// If the receive cannot finish without blocking, x is the zero Value and ok is false.���// If the channel is closed, x is the zero value for the channel's element type and ok is false. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1838"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function trySend</h3>
<pre><code class="language-haxe">function trySend( _x:stdgo.reflect.Value):Bool</code></pre>
<p>TrySend attempts to send x on the channel v but will not block.���// It panics if v's Kind is not Chan.���// It reports whether the value was sent.���// As in Go, x's value must be assignable to the channel's element type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1827"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function type</h3>
<pre><code class="language-haxe">function type():stdgo.reflect.Type</code></pre>
<p>Type returns v's type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1817"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function uint</h3>
<pre><code class="language-haxe">function uint():stdgo.GoUInt64</code></pre>
<p>Uint returns v's underlying value, as a uint64.���// It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1803"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function unsafeAddr</h3>
<pre><code class="language-haxe">function unsafeAddr():stdgo.GoUIntptr</code></pre>
<p>UnsafeAddr returns a pointer to v's data, as a uintptr.���// It is for advanced clients that also import the "unsafe" package.���// It panics if v is not addressable.���//���// It's preferred to use uintptr(Value.Addr().UnsafePointer()) to get the equivalent result. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1795"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Value_static_extension function unsafePointer</h3>
<pre><code class="language-haxe">function unsafePointer():stdgo.unsafe.UnsafePointer</code></pre>
<p>UnsafePointer returns v's value as a unsafe.Pointer.���// It panics if v's Kind is not Chan, Func, Map, Pointer, Slice, or UnsafePointer.���//���// If v's Kind is Func, the returned pointer is an underlying���// code pointer, but not necessarily enough to identify a���// single function uniquely. The only guarantee is that the���// result is zero if and only if v is a nil func Value.���//���// If v's Kind is Slice, the returned pointer is to the first���// element of the slice. If the slice is nil the returned value���// is nil.  If the slice is empty but non-nil the return value is non-nil. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L1784"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h1><a name="typedefs">Typedefs</a></h1>
<pre><code class="language-haxe">import stdgo.reflect.*</code></pre>
<h2><a name="typedef-chandir">typedef ChanDir</a></h2>
<pre><code class="language-haxe">typedef ChanDir = var t:{&lt;&gt;}</code></pre>
<p>ChanDir represents a channel type's direction. </p>
<h3><a name="chandir-function-string">ChanDir function string</a></h3>
<pre><code class="language-haxe">function string():stdgo.GoString</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2839"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="typedef-kind">typedef Kind</a></h2>
<pre><code class="language-haxe">typedef Kind = var t:{&lt;&gt;}</code></pre>
<p>A Kind represents the specific kind of type that a Type represents.��// The zero Kind is not a valid kind. </p>
<h3><a name="kind-function-string">Kind function string</a></h3>
<pre><code class="language-haxe">function string():stdgo.GoString</code></pre>
<p>String returns the name of k. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2754"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="typedef-selectdir">typedef SelectDir</a></h2>
<pre><code class="language-haxe">typedef SelectDir = var t:{&lt;&gt;}</code></pre>
<p>A SelectDir describes the communication direction of a select case. </p>
<h2><a name="typedef-structtag">typedef StructTag</a></h2>
<pre><code class="language-haxe">typedef StructTag = var x:{&lt;&gt;}</code></pre>
<p>A StructTag is the tag string in a struct field.��//��// By convention, tag strings are a concatenation of��// optionally space-separated key:"value" pairs.��// Each key is a non-empty string consisting of non-control��// characters other than space (U+0020 ' '), quote (U+0022 '"'),��// and colon (U+003A ':').  Each value is quoted using U+0022 '"'��// characters and Go string literal syntax. </p>
<h3><a name="structtag-function-get">StructTag function get</a></h3>
<pre><code class="language-haxe">function get( _key:stdgo.GoString):stdgo.GoString</code></pre>
<p>Get returns the value associated with key in the tag string.���// If there is no such key in the tag, Get returns the empty string.���// If the tag does not have the conventional format, the value���// returned by Get is unspecified. To determine whether a tag is���// explicitly set to the empty string, use Lookup. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2902"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="structtag-function-lookup">StructTag function lookup</a></h3>
<pre><code class="language-haxe">function lookup( _key:stdgo.GoString):{_1:Bool, _0:stdgo.GoString}</code></pre>
<p>Lookup returns the value associated with key in the tag string.���// If the key is present in the tag the value (which may be empty)���// is returned. Otherwise the returned value will be the empty string.���// The ok return value reports whether the value was explicitly set in���// the tag string. If the tag does not have the conventional format,���// the value returned by Lookup is unspecified. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/reflect//Reflect.hx#L2891"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="typedef-type">typedef Type</a></h2>
<pre><code class="language-haxe">typedef Type = var a:{&lt;__underlying__&gt; | ():stdgo.GoString | {&lt;haxe_doc&gt;} | ():stdgo.GoUIntptr | {&lt;haxe_doc&gt;} | ():stdgo.GoString | {&lt;haxe_doc&gt;} | (_i:stdgo.GoInt):stdgo.reflect.Type | {&lt;haxe_doc&gt;} | ():stdgo.GoInt | {&lt;haxe_doc&gt;} | ():stdgo.GoInt | {&lt;haxe_doc&gt;} | ():stdgo.GoInt | {&lt;haxe_doc&gt;} | ():stdgo.GoInt | {&lt;haxe_doc&gt;} | ():stdgo.GoString | {&lt;haxe_doc&gt;} | (_0:stdgo.GoString):{_1:Bool, _0:stdgo.reflect.Method} | {&lt;haxe_doc&gt;} | (_0:stdgo.GoInt):stdgo.reflect.Method | {&lt;haxe_doc&gt;} | ():stdgo.GoInt | {&lt;haxe_doc&gt;} | ():stdgo.reflect.Kind | {&lt;haxe_doc&gt;} | ():stdgo.reflect.Type | {&lt;haxe_doc&gt;} | ():Bool | {&lt;haxe_doc&gt;} | (_i:stdgo.GoInt):stdgo.reflect.Type | {&lt;haxe_doc&gt;} | (_u:stdgo.reflect.Type):Bool | {&lt;haxe_doc&gt;} | (_match:()):{_1:Bool, _0:stdgo.reflect.StructField} | {&lt;haxe_doc&gt;} | (_name:stdgo.GoString):{_1:Bool, _0:stdgo.reflect.StructField} | {&lt;haxe_doc&gt;} | (_index:stdgo.Slice&lt;stdgo.GoInt&gt;):stdgo.reflect.StructField | {&lt;haxe_doc&gt;} | ():stdgo.GoInt | {&lt;haxe_doc&gt;} | (_i:stdgo.GoInt):stdgo.reflect.StructField | {&lt;haxe_doc&gt;} | ():stdgo.reflect.Type | {&lt;haxe_doc&gt;} | (_u:stdgo.reflect.Type):Bool | {&lt;haxe_doc&gt;} | ():Bool | {&lt;haxe_doc&gt;} | ():stdgo.reflect.ChanDir | {&lt;haxe_doc&gt;} | ():stdgo.GoInt | {&lt;haxe_doc&gt;} | (_u:stdgo.reflect.Type):Bool | {&lt;haxe_doc&gt;} | ():stdgo.GoInt | {&lt;haxe_doc&gt;} | ():stdgo.AnyInterface}</code></pre>
<p>Type is the representation of a Go type.��//��// Not all methods apply to all kinds of types. Restrictions,��// if any, are noted in the documentation for each method.��// Use the Kind method to find out the kind of type before��// calling kind-specific methods. Calling a method��// inappropriate to the kind of type causes a run-time panic.��//��// Type values are comparable, such as with the == operator,��// so they can be used as map keys.��// Two Type values are equal if they represent identical types. </p>
    </article>
</body>
</html>