<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>go2hx stdgo</title>
    <link rel="shortcut icon" href="logo.svg">
    <meta property="og:title" content="go2hx stdgo"/>
    <meta property="og:type" content="Website"/>
    <meta property="og:url" content="https://go2hx.github.io"/>
    <meta property="og:description" content="go2hx is a Go to Haxe compiler"/>
    <meta property="og:image" content="logo.png"/>
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:width" content="512">
    <meta property="og:image:height" content="512">
    <meta property="og:image:alt" content="go2hx logo">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="go2hx">
    <meta name="twitter:description" content="go2hx, The Go to Haxe compiler">
    <meta name="twitter:image" content="logo.png">
    <meta name="twitter:image:alt" content="go2hx logo">
    <link href="../../prism.css" rel="stylesheet" />
    <link rel="stylesheet" href="../../style.css" />
		<style>
			body {
				box-sizing: border-box;
				min-width: 200px;
				max-width: 980px;
				margin: 0 auto;
				padding: 45px;
			}
			@media (prefers-color-scheme: dark) {
				body {
					background-color: #0d1117;
				}
			}
		</style>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css">
		<style>
			.github-fork-ribbon:before {
				background-color: #121612;
			}
		</style>
</head>
<body>
    <a class="markdown-body"><div class="header">
    <table>
            <thead>
            <th><h2><a href="https://go2hx.github.io/"><font color="#357b99">go</font><font color="#cad0d8">2</font><font color="#e2ac3f">hx</font></a></h2></th>
            <th><h2><a href="https://go2hx.github.io/manual">manual</a></h2></th>
            <th><h2><a href="https://github.com/go2hx/go2hx">github</a></h2></th>
        </thead>
    </table>
</div></a>
    <script src="../../prism.js"></script>
    <article class="markdown-body">
        <h1>Module: <code>stdgo.runtime</code></h1>
<p><a href="../index.html">(view library index)</a></p>
<h1><a name="overview">Overview</a></h1><table><thead><th align="null">\<em>��Package runtime contains operations that interact with Go's runtime system,��such as functions to control goroutines. It also includes the low-level type information��used by the reflect package; see reflect's documentation for the programmable��interface to the run-time type system.���# Environment Variables���The following environment variables ($name or %name%, depending on the host��operating system) control the run-time behavior of Go programs. The meanings��and use may change from release to release.���The GOGC variable sets the initial garbage collection target percentage.��A collection is triggered when the ratio of freshly allocated data to live data��remaining after the previous collection reaches this percentage. The default��is GOGC=100. Setting GOGC=off disables the garbage collector entirely.��[runtime/debug.SetGCPercent] allows changing this percentage at run time.���The GOMEMLIMIT variable sets a soft memory limit for the runtime. This memory limit��includes the Go heap and all other memory managed by the runtime, and excludes��external memory sources such as mappings of the binary itself, memory managed in��other languages, and memory held by the operating system on behalf of the Go��program. GOMEMLIMIT is a numeric value in bytes with an optional unit suffix.��The supported suffixes include B, KiB, MiB, GiB, and TiB. These suffixes��represent quantities of bytes as defined by the IEC 80000-13 standard. That is,��they are based on powers of two: KiB means 2^10 bytes, MiB means 2^20 bytes,��and so on. The default setting is math.MaxInt64, which effectively disables the��memory limit. [runtime/debug.SetMemoryLimit] allows changing this limit at run��time.���The GODEBUG variable controls debugging variables within the runtime.��It is a comma-separated list of name=val pairs setting these named variables:����allocfreetrace: setting allocfreetrace=1 causes every allocation to be���profiled and a stack trace printed on each object's allocation and free.����clobberfree: setting clobberfree=1 causes the garbage collector to���clobber the memory content of an object with bad content when it frees���the object.����cgocheck: setting cgocheck=0 disables all checks for packages���using cgo to incorrectly pass Go pointers to non-Go code.���Setting cgocheck=1 (the default) enables relatively cheap���checks that may miss some errors.  Setting cgocheck=2 enables���expensive checks that should not miss any errors, but will���cause your program to run slower.����efence: setting efence=1 causes the allocator to run in a mode���where each object is allocated on a unique page and addresses are���never recycled.����gccheckmark: setting gccheckmark=1 enables verification of the���garbage collector's concurrent mark phase by performing a���second mark pass while the world is stopped.  If the second���pass finds a reachable object that was not found by concurrent���mark, the garbage collector will panic.����gcpacertrace: setting gcpacertrace=1 causes the garbage collector to���print information about the internal state of the concurrent pacer.����gcshrinkstackoff: setting gcshrinkstackoff=1 disables moving goroutines���onto smaller stacks. In this mode, a goroutine's stack can only grow.����gcstoptheworld: setting gcstoptheworld=1 disables concurrent garbage collection,���making every garbage collection a stop-the-world event. Setting gcstoptheworld=2���also disables concurrent sweeping after the garbage collection finishes.����gctrace: setting gctrace=1 causes the garbage collector to emit a single line to standard���error at each collection, summarizing the amount of memory collected and the���length of the pause. The format of this line is subject to change.���Currently, it is:����gc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-\>#-\># MB, # MB goal, # P���where the fields are as follows:����gc #         the GC number, incremented at each GC����@#s          time in seconds since program start����#%           percentage of time spent in GC since program start����#+...+#      wall-clock/CPU times for the phases of the GC����#-\>#-\># MB   heap size at GC start, at GC end, and live heap����# MB goal    goal heap size����# MB stacks  estimated scannable stack size����# MB globals scannable global size����# P          number of processors used���The phases are stop-the-world (STW) sweep termination, concurrent���mark and scan, and STW mark termination. The CPU times���for mark/scan are broken down in to assist time (GC performed in���line with allocation), background GC time, and idle GC time.���If the line ends with "(forced)", this GC was forced by a���runtime.GC() call.����harddecommit: setting harddecommit=1 causes memory that is returned to the OS to���also have protections removed on it. This is the only mode of operation on Windows,���but is helpful in debugging scavenger-related issues on other platforms. Currently,���only supported on Linux.����inittrace: setting inittrace=1 causes the runtime to emit a single line to standard���error for each package with init work, summarizing the execution time and memory���allocation. No information is printed for inits executed as part of plugin loading���and for packages without both user defined and compiler generated init work.���The format of this line is subject to change. Currently, it is:����init # @#ms, # ms clock, # bytes, # allocs���where the fields are as follows:����init #      the package name����@# ms       time in milliseconds when the init started since program start����# clock     wall-clock time for package initialization work����# bytes     memory allocated on the heap����# allocs    number of heap allocations����madvdontneed: setting madvdontneed=0 will use MADV_FREE���instead of MADV_DONTNEED on Linux when returning memory to the���kernel. This is more efficient, but means RSS numbers will���drop only when the OS is under memory pressure.����memprofilerate: setting memprofilerate=X will update the value of runtime.MemProfileRate.���When set to 0 memory profiling is disabled.  Refer to the description of���MemProfileRate for the default value.����invalidptr: invalidptr=1 (the default) causes the garbage collector and stack���copier to crash the program if an invalid pointer value (for example, 1)���is found in a pointer-typed location. Setting invalidptr=0 disables this check.���This should only be used as a temporary workaround to diagnose buggy code.���The real fix is to not store integers in pointer-typed locations.����sbrk: setting sbrk=1 replaces the memory allocator and garbage collector���with a trivial allocator that obtains memory from the operating system and���never reclaims any memory.����scavtrace: setting scavtrace=1 causes the runtime to emit a single line to standard���error, roughly once per GC cycle, summarizing the amount of work done by the���scavenger as well as the total amount of memory returned to the operating system���and an estimate of physical memory utilization. The format of this line is subject���to change, but currently it is:����scav # KiB work, # KiB total, #% util���where the fields are as follows:����# KiB work   the amount of memory returned to the OS since the last line����# KiB total  the total amount of memory returned to the OS����#% util      the fraction of all unscavenged memory which is in-use���If the line ends with "(forced)", then scavenging was forced by a���debug.FreeOSMemory() call.����scheddetail: setting schedtrace=X and scheddetail=1 causes the scheduler to emit���detailed multiline info every X milliseconds, describing state of the scheduler,���processors, threads and goroutines.����schedtrace: setting schedtrace=X causes the scheduler to emit a single line to standard���error every X milliseconds, summarizing the scheduler state.����tracebackancestors: setting tracebackancestors=N extends tracebacks with the stacks at���which goroutines were created, where N limits the number of ancestor goroutines to���report. This also extends the information returned by runtime.Stack. Ancestor's goroutine���IDs will refer to the ID of the goroutine at the time of creation; it's possible for this���ID to be reused for another goroutine. Setting N to 0 will report no ancestry information.����asyncpreemptoff: asyncpreemptoff=1 disables signal-based���asynchronous goroutine preemption. This makes some loops���non-preemptible for long periods, which may delay GC and���goroutine scheduling. This is useful for debugging GC issues���because it also disables the conservative stack scanning used���for asynchronously preempted goroutines.���The net and net/http packages also refer to debugging variables in GODEBUG.��See the documentation for those packages for details.���The GOMAXPROCS variable limits the number of operating system threads that��can execute user-level Go code simultaneously. There is no limit to the number of threads��that can be blocked in system calls on behalf of Go code; those do not count against��the GOMAXPROCS limit. This package's GOMAXPROCS function queries and changes��the limit.���The GORACE variable configures the race detector, for programs built using -race.��See https://golang.org/doc/articles/race_detector.html for details.���The GOTRACEBACK variable controls the amount of output generated when a Go��program fails due to an unrecovered panic or an unexpected runtime condition.��By default, a failure prints a stack trace for the current goroutine,��eliding functions internal to the run-time system, and then exits with exit code 2.��The failure prints stack traces for all goroutines if there is no current goroutine��or the failure is internal to the run-time.��GOTRACEBACK=none omits the goroutine stack traces entirely.��GOTRACEBACK=single (the default) behaves as described above.��GOTRACEBACK=all adds stack traces for all user-created goroutines.��GOTRACEBACK=system is like “all” but adds stack frames for run-time functions��and shows goroutines created internally by the run-time.��GOTRACEBACK=crash is like “system” but crashes in an operating system-specific��manner instead of exiting. For example, on Unix systems, the crash raises��SIGABRT to trigger a core dump.��For historical reasons, the GOTRACEBACK settings 0, 1, and 2 are synonyms for��none, all, and system, respectively.��The runtime/debug package's SetTraceback function allows increasing the��amount of output at run time, but it cannot reduce the amount below that��specified by the environment variable.��See https://golang.org/pkg/runtime/debug/#SetTraceback.���The GOARCH, GOOS, GOPATH, and GOROOT environment variables complete��the set of Go environment variables. They influence the building of Go programs��(see https://golang.org/cmd/go and https://golang.org/pkg/go/build).��GOARCH, GOOS, and GOROOT are recorded at compile time and made available by��constants or functions in this package, but they do not influence the execution��of the run-time system.��\</em></th><th align="null">/</th></thead><tbody></tbody></table>
<h1><a name="index">Index</a></h1><ul><li>
<p><a href="#constants">Constants</a></p></li><li>
<p><a href="#variables">Variables</a></p></li><li>
<p><a href="#function-blockprofile"><code>function blockProfile(_p:stdgo.Slice&lt;stdgo.runtime.BlockProfileRecord&gt;):{_1:Bool, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-breakpoint"><code>function breakpoint():Void</code></a></p></li><li>
<p><a href="#function-caller"><code>function caller(_skip:stdgo.GoInt):{_3:Bool, _2:stdgo.GoInt, _1:stdgo.GoString, _0:stdgo.GoUIntptr}</code></a></p></li><li>
<p><a href="#function-callers"><code>function callers(_skip:stdgo.GoInt, _pc:stdgo.Slice&lt;stdgo.GoUIntptr&gt;):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-callersframes"><code>function callersFrames(_callers:stdgo.Slice&lt;stdgo.GoUIntptr&gt;):stdgo.Ref&lt;stdgo.runtime.Frames&gt;</code></a></p></li><li>
<p><a href="#function-cpuprofile"><code>function cpuprofile():stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-funcforpc"><code>function funcForPC(_pc:stdgo.GoUIntptr):stdgo.Ref&lt;stdgo.runtime.Func&gt;</code></a></p></li><li>
<p><a href="#function-gc"><code>function gc():Void</code></a></p></li><li>
<p><a href="#function-goexit"><code>function goexit():Void</code></a></p></li><li>
<p><a href="#function-gomaxprocs"><code>function gomaxprocs(_n:stdgo.GoInt):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-goroot"><code>function goroot():stdgo.GoString</code></a></p></li><li>
<p><a href="#function-goroutineprofile"><code>function goroutineProfile(_p:stdgo.Slice&lt;stdgo.runtime.StackRecord&gt;):{_1:Bool, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-gosched"><code>function gosched():Void</code></a></p></li><li>
<p><a href="#function-keepalive"><code>function keepAlive(_x:stdgo.AnyInterface):Void</code></a></p></li><li>
<p><a href="#function-lockosthread"><code>function lockOSThread():Void</code></a></p></li><li>
<p><a href="#function-memprofile"><code>function memProfile(_p:stdgo.Slice&lt;stdgo.runtime.MemProfileRecord&gt;, _inuseZero:Bool):{_1:Bool, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-mutexprofile"><code>function mutexProfile(_p:stdgo.Slice&lt;stdgo.runtime.BlockProfileRecord&gt;):{_1:Bool, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-numcpu"><code>function numCPU():stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-numcgocall"><code>function numCgoCall():stdgo.GoInt64</code></a></p></li><li>
<p><a href="#function-numgoroutine"><code>function numGoroutine():stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-readmemstats"><code>function readMemStats(_m:stdgo.Ref&lt;stdgo.runtime.MemStats&gt;):Void</code></a></p></li><li>
<p><a href="#function-readtrace"><code>function readTrace():stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-setblockprofilerate"><code>function setBlockProfileRate(_rate:stdgo.GoInt):Void</code></a></p></li><li>
<p><a href="#function-setcpuprofilerate"><code>function setCPUProfileRate(_hz:stdgo.GoInt):Void</code></a></p></li><li>
<p><a href="#function-setcgotraceback"><code>function setCgoTraceback(_version:stdgo.GoInt, _traceback:stdgo.unsafe.UnsafePointer, _context:stdgo.unsafe.UnsafePointer, _symbolizer:stdgo.unsafe.UnsafePointer):Void</code></a></p></li><li>
<p><a href="#function-setfinalizer"><code>function setFinalizer(_obj:stdgo.AnyInterface, _finalizer:stdgo.AnyInterface):Void</code></a></p></li><li>
<p><a href="#function-setmutexprofilefraction"><code>function setMutexProfileFraction(_rate:stdgo.GoInt):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-stack"><code>function stack(_buf:stdgo.Slice&lt;stdgo.GoByte&gt;, _all:Bool):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-starttrace"><code>function startTrace():stdgo.Error</code></a></p></li><li>
<p><a href="#function-stoptrace"><code>function stopTrace():Void</code></a></p></li><li>
<p><a href="#function-threadcreateprofile"><code>function threadCreateProfile(_p:stdgo.Slice&lt;stdgo.runtime.StackRecord&gt;):{_1:Bool, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-unlockosthread"><code>function unlockOSThread():Void</code></a></p></li><li>
<p><a href="#function-version"><code>function version():stdgo.GoString</code></a></p></li><li>
<p><a href="#class-blockprofilerecord">class BlockProfileRecord</a></p></li><li>
<p><a href="#blockprofilerecord-function-new"><code>function new(?count:stdgo.GoInt64, ?cycles:stdgo.GoInt64, ?stackRecord:stdgo.runtime.StackRecord):Void</code></a></p></li><li>
<p><a href="#blockprofilerecord-function-stack"><code>function stack():stdgo.Slice&lt;stdgo.GoUIntptr&gt;</code></a></p></li><li>
<p><a href="#blockprofilerecord-function-stack"><code>function stack():stdgo.Slice&lt;stdgo.GoUIntptr&gt;</code></a></p></li><li>
<p><a href="#class-blockprofilerecord_static_extension">class BlockProfileRecord_static_extension</a></p></li><li>
<p><a href="#blockprofilerecord_static_extension-function-stack"><code>function stack():stdgo.Slice&lt;stdgo.GoUIntptr&gt;</code></a></p></li><li>
<p><a href="#class-frame">class Frame</a></p></li><li>
<p><a href="#frame-function-new"><code>function new(?pc:stdgo.GoUIntptr, ?func:stdgo.Ref&lt;stdgo.runtime.Func&gt;, ?function_:stdgo.GoString, ?file:stdgo.GoString, ?line:Null&lt;stdgo.GoInt&gt;, ?entry:stdgo.GoUIntptr):Void</code></a></p></li><li>
<p><a href="#class-frames">class Frames</a></p></li><li>
<p><a href="#frames-function-new"><code>function new():Void</code></a></p></li><li>
<p><a href="#frames-function-next"><code>function next():{_1:Bool, _0:stdgo.runtime.Frame}</code></a></p></li><li>
<p><a href="#class-frames_static_extension">class Frames_static_extension</a></p></li><li>
<p><a href="#frames_static_extension-function-next"><code>function next():{_1:Bool, _0:stdgo.runtime.Frame}</code></a></p></li><li>
<p><a href="#class-func">class Func</a></p></li><li>
<p><a href="#func-function-new"><code>function new():Void</code></a></p></li><li>
<p><a href="#func-function-entry"><code>function entry():stdgo.GoUIntptr</code></a></p></li><li>
<p><a href="#func-function-fileline"><code>function fileLine( _pc:stdgo.GoUIntptr):{_1:stdgo.GoInt, _0:stdgo.GoString}</code></a></p></li><li>
<p><a href="#func-function-name"><code>function name():stdgo.GoString</code></a></p></li><li>
<p><a href="#class-func_static_extension">class Func_static_extension</a></p></li><li>
<p><a href="#func_static_extension-function-entry"><code>function entry():stdgo.GoUIntptr</code></a></p></li><li>
<p><a href="#func_static_extension-function-fileline"><code>function fileLine( _pc:stdgo.GoUIntptr):{_1:stdgo.GoInt, _0:stdgo.GoString}</code></a></p></li><li>
<p><a href="#func_static_extension-function-name"><code>function name():stdgo.GoString</code></a></p></li><li>
<p><a href="#class-memprofilerecord">class MemProfileRecord</a></p></li><li>
<p><a href="#memprofilerecord-function-new"><code>function new(?allocBytes:stdgo.GoInt64, ?freeBytes:stdgo.GoInt64, ?allocObjects:stdgo.GoInt64, ?freeObjects:stdgo.GoInt64, ?stack0:stdgo.GoArray&lt;stdgo.GoUIntptr&gt;):Void</code></a></p></li><li>
<p><a href="#memprofilerecord-function-inusebytes"><code>function inUseBytes():stdgo.GoInt64</code></a></p></li><li>
<p><a href="#memprofilerecord-function-inuseobjects"><code>function inUseObjects():stdgo.GoInt64</code></a></p></li><li>
<p><a href="#memprofilerecord-function-stack"><code>function stack():stdgo.Slice&lt;stdgo.GoUIntptr&gt;</code></a></p></li><li>
<p><a href="#class-memprofilerecord_static_extension">class MemProfileRecord_static_extension</a></p></li><li>
<p><a href="#memprofilerecord_static_extension-function-inusebytes"><code>function inUseBytes():stdgo.GoInt64</code></a></p></li><li>
<p><a href="#memprofilerecord_static_extension-function-inuseobjects"><code>function inUseObjects():stdgo.GoInt64</code></a></p></li><li>
<p><a href="#memprofilerecord_static_extension-function-stack"><code>function stack():stdgo.Slice&lt;stdgo.GoUIntptr&gt;</code></a></p></li><li>
<p><a href="#class-memstats">class MemStats</a></p></li><li>
<p><a href="#memstats-function-new"><code>function new(?alloc:stdgo.GoUInt64, ?totalAlloc:stdgo.GoUInt64, ?sys:stdgo.GoUInt64, ?lookups:stdgo.GoUInt64, ?mallocs:stdgo.GoUInt64, ?frees:stdgo.GoUInt64, ?heapAlloc:stdgo.GoUInt64, ?heapSys:stdgo.GoUInt64, ?heapIdle:stdgo.GoUInt64, ?heapInuse:stdgo.GoUInt64, ?heapReleased:stdgo.GoUInt64, ?heapObjects:stdgo.GoUInt64, ?stackInuse:stdgo.GoUInt64, ?stackSys:stdgo.GoUInt64, ?mspanInuse:stdgo.GoUInt64, ?mspanSys:stdgo.GoUInt64, ?mcacheInuse:stdgo.GoUInt64, ?mcacheSys:stdgo.GoUInt64, ?buckHashSys:stdgo.GoUInt64, ?gcsys:stdgo.GoUInt64, ?otherSys:stdgo.GoUInt64, ?nextGC:stdgo.GoUInt64, ?lastGC:stdgo.GoUInt64, ?pauseTotalNs:stdgo.GoUInt64, ?pauseNs:stdgo.GoArray&lt;stdgo.GoUInt64&gt;, ?pauseEnd:stdgo.GoArray&lt;stdgo.GoUInt64&gt;, ?numGC:stdgo.GoUInt32, ?numForcedGC:stdgo.GoUInt32, ?gccpufraction:stdgo.GoFloat64, ?enableGC:Bool, ?debugGC:Bool, ?bySize:stdgo.GoArray&lt;{size:stdgo.GoUInt32, mallocs:stdgo.GoUInt64, frees:stdgo.GoUInt64}&gt;):Void</code></a></p></li><li>
<p><a href="#class-stackrecord">class StackRecord</a></p></li><li>
<p><a href="#stackrecord-function-new"><code>function new(?stack0:stdgo.GoArray&lt;stdgo.GoUIntptr&gt;):Void</code></a></p></li><li>
<p><a href="#stackrecord-function-stack"><code>function stack():stdgo.Slice&lt;stdgo.GoUIntptr&gt;</code></a></p></li><li>
<p><a href="#class-stackrecord_static_extension">class StackRecord_static_extension</a></p></li><li>
<p><a href="#stackrecord_static_extension-function-stack"><code>function stack():stdgo.Slice&lt;stdgo.GoUIntptr&gt;</code></a></p></li><li>
<p><a href="#class-t__struct_0_static_extension">class T__struct_0_static_extension</a></p></li><li>
<p><a href="#class-typeassertionerror">class TypeAssertionError</a></p></li><li>
<p><a href="#typeassertionerror-function-new"><code>function new():Void</code></a></p></li><li>
<p><a href="#typeassertionerror-function-error"><code>function error():stdgo.GoString</code></a></p></li><li>
<p><a href="#typeassertionerror-function-runtimeerror"><code>function runtimeError():Void</code></a></p></li><li>
<p><a href="#class-typeassertionerror_static_extension">class TypeAssertionError_static_extension</a></p></li><li>
<p><a href="#typeassertionerror_static_extension-function-error"><code>function error():stdgo.GoString</code></a></p></li><li>
<p><a href="#typeassertionerror_static_extension-function-runtimeerror"><code>function runtimeError():Void</code></a></p></li><li>
<p><a href="#typedef-t_error">typedef T_error</a></p></li></ul>
<h1><a name="constants">Constants</a></h1>
<pre><code class="language-haxe">import stdgo.runtime.Runtime</code></pre>
<pre><code class="language-haxe">final compiler:stdgo.GoString = (("" : GoString))</code></pre>
<p>Compiler is the name of the compiler toolchain that built the��// running binary. Known toolchains are:��//��//�gc      Also known as cmd/compile.��//�gccgo   The gccgo front end, part of the GCC compiler suite. </p>
<pre><code class="language-haxe">final goarch:stdgo.GoString = (("" : GoString))</code></pre>
<p>GOARCH is the running program's architecture target:��// one of 386, amd64, arm, s390x, and so on. </p>
<pre><code class="language-haxe">final goos:stdgo.GoString = (("" : GoString))</code></pre>
<p>GOOS is the running program's operating system target:��// one of darwin, freebsd, linux, and so on.��// To view possible combinations of GOOS and GOARCH, run "go tool dist list". </p>
<h1><a name="variables">Variables</a></h1>
<pre><code class="language-haxe">import stdgo.runtime.Runtime</code></pre>
<pre><code class="language-haxe">var memProfileRate:stdgo.GoInt</code></pre>
<p>MemProfileRate controls the fraction of memory allocations��// that are recorded and reported in the memory profile.��// The profiler aims to sample an average of��// one allocation per MemProfileRate bytes allocated.��//��// To include every allocated block in the profile, set MemProfileRate to 1.��// To turn off profiling entirely, set MemProfileRate to 0.��//��// The tools that process the memory profiles assume that the��// profile rate is constant across the lifetime of the program��// and equal to the current value. Programs that change the��// memory profiling rate should do so just once, as early as��// possible in the execution of the program (for example,��// at the beginning of main). </p>
<h1><a name="functions">Functions</a></h1>
<pre><code class="language-haxe">import stdgo.runtime.Runtime</code></pre>
<h2><a name="function-blockprofile">function blockProfile</a></h2>
<pre><code class="language-haxe">function blockProfile(_p:stdgo.Slice&lt;stdgo.runtime.BlockProfileRecord&gt;):{_1:Bool, _0:stdgo.GoInt}</code></pre>
<p>BlockProfile returns n, the number of records in the current blocking profile.��// If len(p) \>= n, BlockProfile copies the profile into p and returns n, true.��// If len(p) \&lt; n, BlockProfile does not change p and returns n, false.��//��// Most clients should use the runtime/pprof package or��// the testing package's -test.blockprofile flag instead��// of calling BlockProfile directly. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1170"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-breakpoint">function breakpoint</a></h2>
<pre><code class="language-haxe">function breakpoint():Void</code></pre>
<p>Breakpoint executes a breakpoint trap. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1249"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-caller">function caller</a></h2>
<pre><code class="language-haxe">function caller(_skip:stdgo.GoInt):{_3:Bool, _2:stdgo.GoInt, _1:stdgo.GoString, _0:stdgo.GoUIntptr}</code></pre>
<p>Caller reports file and line number information about function invocations on��// the calling goroutine's stack. The argument skip is the number of stack frames��// to ascend, with 0 identifying the caller of Caller.  (For historical reasons the��// meaning of skip differs between Caller and Callers.) The return values report the��// program counter, file name, and line number within the file of the corresponding��// call. The boolean ok is false if it was not possible to recover the information. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L956"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-callers">function callers</a></h2>
<pre><code class="language-haxe">function callers(_skip:stdgo.GoInt, _pc:stdgo.Slice&lt;stdgo.GoUIntptr&gt;):stdgo.GoInt</code></pre>
<p>Callers fills the slice pc with the return program counters of function invocations��// on the calling goroutine's stack. The argument skip is the number of stack frames��// to skip before recording in pc, with 0 identifying the frame for Callers itself and��// 1 identifying the caller of Callers.��// It returns the number of entries written to pc.��//��// To translate these PCs into symbolic information such as function��// names and line numbers, use CallersFrames. CallersFrames accounts��// for inlined functions and adjusts the return program counters into��// call program counters. Iterating over the returned slice of PCs��// directly is discouraged, as is using FuncForPC on any of the��// returned PCs, since these cannot account for inlining or return��// program counter adjustment. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L974"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-callersframes">function callersFrames</a></h2>
<pre><code class="language-haxe">function callersFrames(_callers:stdgo.Slice&lt;stdgo.GoUIntptr&gt;):stdgo.Ref&lt;stdgo.runtime.Frames&gt;</code></pre>
<p>CallersFrames takes a slice of PC values returned by Callers and��// prepares to return function/file/line information.��// Do not change the slice until you are done with the Frames. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1293"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-cpuprofile">function cpuprofile</a></h2>
<pre><code class="language-haxe">function cpuprofile():stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>CPUProfile panics.��// It formerly provided raw access to chunks of��// a pprof-format profile generated by the runtime.��// The details of generating that format have changed,��// so this functionality has been removed.��//��// Deprecated: Use the runtime/pprof package,��// or the handlers in the net/http/pprof package,��// or the testing package's -test.cpuprofile flag instead. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L909"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-funcforpc">function funcForPC</a></h2>
<pre><code class="language-haxe">function funcForPC(_pc:stdgo.GoUIntptr):stdgo.Ref&lt;stdgo.runtime.Func&gt;</code></pre>
<p>FuncForPC returns a \<em>Func describing the function that contains the��// given program counter address, or else nil.��//��// If pc represents multiple functions because of inlining, it returns��// the \</em>Func describing the innermost function, but with an entry of��// the outermost function. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1304"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-gc">function gc</a></h2>
<pre><code class="language-haxe">function gc():Void</code></pre>
<p>GC runs a garbage collection and blocks the caller until the��// garbage collection is complete. It may also block the entire��// program. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1109"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-goexit">function goexit</a></h2>
<pre><code class="language-haxe">function goexit():Void</code></pre>
<p>Goexit terminates the goroutine that calls it. No other goroutine is affected.��// Goexit runs all deferred calls before terminating the goroutine. Because Goexit��// is not a panic, any recover calls in those deferred functions will return nil.��//��// Calling Goexit from the main goroutine terminates that goroutine��// without func main returning. Since func main has not returned,��// the program continues execution of other goroutines.��// If all other goroutines exit, the program crashes. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1236"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-gomaxprocs">function gomaxprocs</a></h2>
<pre><code class="language-haxe">function gomaxprocs(_n:stdgo.GoInt):stdgo.GoInt</code></pre>
<p>GOMAXPROCS sets the maximum number of CPUs that can be executing��// simultaneously and returns the previous setting. It defaults to��// the value of runtime.NumCPU. If n \&lt; 1, it does not change the current setting.��// This call will go away when the scheduler improves. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L918"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-goroot">function goroot</a></h2>
<pre><code class="language-haxe">function goroot():stdgo.GoString</code></pre>
<p>GOROOT returns the root of the Go tree. It uses the��// GOROOT environment variable, if set at process start,��// or else the root used during the Go build. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L982"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-goroutineprofile">function goroutineProfile</a></h2>
<pre><code class="language-haxe">function goroutineProfile(_p:stdgo.Slice&lt;stdgo.runtime.StackRecord&gt;):{_1:Bool, _0:stdgo.GoInt}</code></pre>
<p>GoroutineProfile returns n, the number of records in the active goroutine stack profile.��// If len(p) \>= n, GoroutineProfile copies the profile into p and returns n, true.��// If len(p) \&lt; n, GoroutineProfile does not change p and returns n, false.��//��// Most clients should use the runtime/pprof package instead��// of calling GoroutineProfile directly. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1203"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-gosched">function gosched</a></h2>
<pre><code class="language-haxe">function gosched():Void</code></pre>
<p>Gosched yields the processor, allowing other goroutines to run. It does not��// suspend the current goroutine, so execution resumes automatically. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1243"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-keepalive">function keepAlive</a></h2>
<pre><code class="language-haxe">function keepAlive(_x:stdgo.AnyInterface):Void</code></pre>
<p>KeepAlive marks its argument as currently reachable.��// This ensures that the object is not freed, and its finalizer is not run,��// before the point in the program where KeepAlive is called.��//��// A very simplified example showing where KeepAlive is required:��//��//�type File struct { d int }��//�d, err := syscall.Open("/file/path", syscall.O_RDONLY, 0)��//�// ... do something if err != nil ...��//�p := &amp;File{d}��//�runtime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })��//�var buf [10]byte��//�n, err := syscall.Read(p.d, buf[:])��//�// Ensure p is not finalized until Read returns.��//�runtime.KeepAlive(p)��//�// No more uses of p after this point.��//��// Without the KeepAlive call, the finalizer could run at the start of��// syscall.Read, closing the file descriptor before syscall.Read makes��// the actual system call.��//��// Note: KeepAlive should only be used to prevent finalizers from��// running prematurely. In particular, when used with unsafe.Pointer,��// the rules for valid uses of unsafe.Pointer still apply. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1101"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-lockosthread">function lockOSThread</a></h2>
<pre><code class="language-haxe">function lockOSThread():Void</code></pre>
<p>LockOSThread wires the calling goroutine to its current operating system thread.��// The calling goroutine will always execute in that thread,��// and no other goroutine will execute in it,��// until the calling goroutine has made as many calls to��// UnlockOSThread as to LockOSThread.��// If the calling goroutine exits without unlocking the thread,��// the thread will be terminated.��//��// All init functions are run on the startup thread. Calling LockOSThread��// from an init function will cause the main function to be invoked on��// that thread.��//��// A goroutine should call LockOSThread before calling OS services or��// non-Go library functions that depend on per-thread state. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1268"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-memprofile">function memProfile</a></h2>
<pre><code class="language-haxe">function memProfile(_p:stdgo.Slice&lt;stdgo.runtime.MemProfileRecord&gt;, _inuseZero:Bool):{_1:Bool, _0:stdgo.GoInt}</code></pre>
<p>MemProfile returns a profile of memory allocated and freed per allocation��// site.��//��// MemProfile returns n, the number of records in the current memory profile.��// If len(p) \>= n, MemProfile copies the profile into p and returns n, true.��// If len(p) \&lt; n, MemProfile does not change p and returns n, false.��//��// If inuseZero is true, the profile includes allocation records��// where r.AllocBytes \> 0 but r.AllocBytes == r.FreeBytes.��// These are sites where memory was allocated, but it has all��// been released back to the runtime.��//��// The returned profile may be up to two garbage collection cycles old.��// This is to avoid skewing the profile toward allocations; because��// allocations happen in real time but frees are delayed until the garbage��// collector performs sweeping, the profile only accounts for allocations��// that have had a chance to be freed by the garbage collector.��//��// Most clients should use the runtime/pprof package or��// the testing package's -test.memprofile flag instead��// of calling MemProfile directly. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1158"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-mutexprofile">function mutexProfile</a></h2>
<pre><code class="language-haxe">function mutexProfile(_p:stdgo.Slice&lt;stdgo.runtime.BlockProfileRecord&gt;):{_1:Bool, _0:stdgo.GoInt}</code></pre>
<p>MutexProfile returns n, the number of records in the current mutex profile.��// If len(p) \>= n, MutexProfile copies the profile into p and returns n, true.��// Otherwise, MutexProfile does not change p, and returns n, false.��//��// Most clients should use the runtime/pprof package��// instead of calling MutexProfile directly. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1181"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-numcpu">function numCPU</a></h2>
<pre><code class="language-haxe">function numCPU():stdgo.GoInt</code></pre>
<p>NumCPU returns the number of logical CPUs usable by the current process.��//��// The set of available CPUs is checked by querying the operating system��// at process startup. Changes to operating system CPU allocation after��// process startup are not reflected. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L928"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-numcgocall">function numCgoCall</a></h2>
<pre><code class="language-haxe">function numCgoCall():stdgo.GoInt64</code></pre>
<p>NumCgoCall returns the number of cgo calls made by the current process. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L934"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-numgoroutine">function numGoroutine</a></h2>
<pre><code class="language-haxe">function numGoroutine():stdgo.GoInt</code></pre>
<p>NumGoroutine returns the number of goroutines that currently exist. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L940"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-readmemstats">function readMemStats</a></h2>
<pre><code class="language-haxe">function readMemStats(_m:stdgo.Ref&lt;stdgo.runtime.MemStats&gt;):Void</code></pre>
<p>ReadMemStats populates m with memory allocator statistics.��//��// The returned memory allocator statistics are up to date as of the��// call to ReadMemStats. This is in contrast with a heap profile,��// which is a snapshot as of the most recently completed garbage��// collection cycle. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1223"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-readtrace">function readTrace</a></h2>
<pre><code class="language-haxe">function readTrace():stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>ReadTrace returns the next chunk of binary tracing data, blocking until data��// is available. If tracing is turned off and all the data accumulated while it��// was on has been returned, ReadTrace returns nil. The caller must copy the��// returned data before calling ReadTrace again.��// ReadTrace must be called from one goroutine at a time. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1331"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-setblockprofilerate">function setBlockProfileRate</a></h2>
<pre><code class="language-haxe">function setBlockProfileRate(_rate:stdgo.GoInt):Void</code></pre>
<p>SetBlockProfileRate controls the fraction of goroutine blocking events��// that are reported in the blocking profile. The profiler aims to sample��// an average of one blocking event per rate nanoseconds spent blocked.��//��// To include every blocking event in the profile, pass rate = 1.��// To turn off profiling entirely, pass rate \&lt;= 0. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1120"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-setcpuprofilerate">function setCPUProfileRate</a></h2>
<pre><code class="language-haxe">function setCPUProfileRate(_hz:stdgo.GoInt):Void</code></pre>
<p>SetCPUProfileRate sets the CPU profiling rate to hz samples per second.��// If hz \&lt;= 0, SetCPUProfileRate turns off profiling.��// If the profiler is on, the rate cannot be changed without first turning it off.��//��// Most clients should use the runtime/pprof package or��// the testing package's -test.cpuprofile flag instead of calling��// SetCPUProfileRate directly. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L895"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-setcgotraceback">function setCgoTraceback</a></h2>
<pre><code class="language-haxe">function setCgoTraceback(_version:stdgo.GoInt, _traceback:stdgo.unsafe.UnsafePointer, _context:stdgo.unsafe.UnsafePointer, _symbolizer:stdgo.unsafe.UnsafePointer):Void</code></pre>
<p>SetCgoTraceback records three C functions to use to gather��// traceback information from C code and to convert that traceback��// information into symbolic information. These are used when printing��// stack traces for a program that uses cgo.��//��// The traceback and context functions may be called from a signal��// handler, and must therefore use only async-signal safe functions.��// The symbolizer function may be called while the program is��// crashing, and so must be cautious about using memory.  None of the��// functions may call back into Go.��//��// The context function will be called with a single argument, a��// pointer to a struct:��//��//�struct {��//��Context uintptr��//�}��//��// In C syntax, this struct will be��//��//�struct {��//��uintptr_t Context;��//�};��//��// If the Context field is 0, the context function is being called to��// record the current traceback context. It should record in the��// Context field whatever information is needed about the current��// point of execution to later produce a stack trace, probably the��// stack pointer and PC. In this case the context function will be��// called from C code.��//��// If the Context field is not 0, then it is a value returned by a��// previous call to the context function. This case is called when the��// context is no longer needed; that is, when the Go code is returning��// to its C code caller. This permits the context function to release��// any associated resources.��//��// While it would be correct for the context function to record a��// complete a stack trace whenever it is called, and simply copy that��// out in the traceback function, in a typical program the context��// function will be called many times without ever recording a��// traceback for that context. Recording a complete stack trace in a��// call to the context function is likely to be inefficient.��//��// The traceback function will be called with a single argument, a��// pointer to a struct:��//��//�struct {��//��Context    uintptr��//��SigContext uintptr��//��Buf        \<em>uintptr��//��Max        uintptr��//�}��//��// In C syntax, this struct will be��//��//�struct {��//��uintptr_t  Context;��//��uintptr_t  SigContext;��//��uintptr_t\</em> Buf;��//��uintptr_t  Max;��//�};��//��// The Context field will be zero to gather a traceback from the��// current program execution point. In this case, the traceback��// function will be called from C code.��//��// Otherwise Context will be a value previously returned by a call to��// the context function. The traceback function should gather a stack��// trace from that saved point in the program execution. The traceback��// function may be called from an execution thread other than the one��// that recorded the context, but only when the context is known to be��// valid and unchanging. The traceback function may also be called��// deeper in the call stack on the same thread that recorded the��// context. The traceback function may be called multiple times with��// the same Context value; it will usually be appropriate to cache the��// result, if possible, the first time this is called for a specific��// context value.��//��// If the traceback function is called from a signal handler on a Unix��// system, SigContext will be the signal context argument passed to��// the signal handler (a C ucontext_t\<em> cast to uintptr_t). This may be��// used to start tracing at the point where the signal occurred. If��// the traceback function is not called from a signal handler,��// SigContext will be zero.��//��// Buf is where the traceback information should be stored. It should��// be PC values, such that Buf[0] is the PC of the caller, Buf[1] is��// the PC of that function's caller, and so on.  Max is the maximum��// number of entries to store.  The function should store a zero to��// indicate the top of the stack, or that the caller is on a different��// stack, presumably a Go stack.��//��// Unlike runtime.Callers, the PC values returned should, when passed��// to the symbolizer function, return the file/line of the call��// instruction.  No additional subtraction is required or appropriate.��//��// On all platforms, the traceback function is invoked when a call from��// Go to C to Go requests a stack trace. On linux/amd64, linux/ppc64le,��// linux/arm64, and freebsd/amd64, the traceback function is also invoked��// when a signal is received by a thread that is executing a cgo call.��// The traceback function should not make assumptions about when it is��// called, as future versions of Go may make additional calls.��//��// The symbolizer function will be called with a single argument, a��// pointer to a struct:��//��//�struct {��//��PC      uintptr // program counter to fetch information for��//��File    \</em>byte   // file name (NUL terminated)��//��Lineno  uintptr // line number��//��Func    \<em>byte   // function name (NUL terminated)��//��Entry   uintptr // function entry point��//��More    uintptr // set non-zero if more info for this PC��//��Data    uintptr // unused by runtime, available for function��//�}��//��// In C syntax, this struct will be��//��//�struct {��//��uintptr_t PC;��//��char\</em>     File;��//��uintptr_t Lineno;��//��char*     Func;��//��uintptr_t Entry;��//��uintptr_t More;��//��uintptr_t Data;��//�};��//��// The PC field will be a value returned by a call to the traceback��// function.��//��// The first time the function is called for a particular traceback,��// all the fields except PC will be 0. The function should fill in the��// other fields if possible, setting them to 0/nil if the information��// is not available. The Data field may be used to store any useful��// information across calls. The More field should be set to non-zero��// if there is more information for this PC, zero otherwise. If More��// is set non-zero, the function will be called again with the same��// PC, and may return different information (this is intended for use��// with inlined functions). If More is zero, the function will be��// called with the next PC value in the traceback. When the traceback��// is complete, the function will be called once more with PC set to��// zero; this may be used to free any information. Each call will��// leave the fields of the struct set to the same values they had upon��// return, except for the PC field when the More field is zero. The��// function must not keep a copy of the struct pointer between calls.��//��// When calling SetCgoTraceback, the version argument is the version��// number of the structs that the functions expect to receive.��// Currently this must be zero.��//��// The symbolizer function may be nil, in which case the results of��// the traceback function will be displayed as numbers. If the��// traceback function is nil, the symbolizer function will never be��// called. The context function may be nil, in which case the��// traceback function will only be called with the context field set��// to zero.  If the context function is nil, then calls from Go to C��// to Go will not show a traceback for the C portion of the call stack.��//��// SetCgoTraceback should be called only once, ideally from an init function. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1498"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-setfinalizer">function setFinalizer</a></h2>
<pre><code class="language-haxe">function setFinalizer(_obj:stdgo.AnyInterface, _finalizer:stdgo.AnyInterface):Void</code></pre>
<p>SetFinalizer sets the finalizer associated with obj to the provided��// finalizer function. When the garbage collector finds an unreachable block��// with an associated finalizer, it clears the association and runs��// finalizer(obj) in a separate goroutine. This makes obj reachable again,��// but now without an associated finalizer. Assuming that SetFinalizer��// is not called again, the next time the garbage collector sees��// that obj is unreachable, it will free obj.��//��// SetFinalizer(obj, nil) clears any finalizer associated with obj.��//��// The argument obj must be a pointer to an object allocated by calling��// new, by taking the address of a composite literal, or by taking the��// address of a local variable.��// The argument finalizer must be a function that takes a single argument��// to which obj's type can be assigned, and can have arbitrary ignored return��// values. If either of these is not true, SetFinalizer may abort the��// program.��//��// Finalizers are run in dependency order: if A points at B, both have��// finalizers, and they are otherwise unreachable, only the finalizer��// for A runs; once A is freed, the finalizer for B can run.��// If a cyclic structure includes a block with a finalizer, that��// cycle is not guaranteed to be garbage collected and the finalizer��// is not guaranteed to run, because there is no ordering that��// respects the dependencies.��//��// The finalizer is scheduled to run at some arbitrary time after the��// program can no longer reach the object to which obj points.��// There is no guarantee that finalizers will run before a program exits,��// so typically they are useful only for releasing non-memory resources��// associated with an object during a long-running program.��// For example, an os.File object could use a finalizer to close the��// associated operating system file descriptor when a program discards��// an os.File without calling Close, but it would be a mistake��// to depend on a finalizer to flush an in-memory I/O buffer such as a��// bufio.Writer, because the buffer would not be flushed at program exit.��//��// It is not guaranteed that a finalizer will run if the size of *obj is��// zero bytes.��//��// It is not guaranteed that a finalizer will run for objects allocated��// in initializers for package-level variables. Such objects may be��// linker-allocated, not heap-allocated.��//��// A finalizer may run as soon as an object becomes unreachable.��// In order to use finalizers correctly, the program must ensure that��// the object is reachable until it is no longer required.��// Objects stored in global variables, or that can be found by tracing��// pointers from a global variable, are reachable. For other objects,��// pass the object to a call of the KeepAlive function to mark the��// last point in the function where the object must be reachable.��//��// For example, if p points to a struct, such as os.File, that contains��// a file descriptor d, and p has a finalizer that closes that file��// descriptor, and if the last use of p in a function is a call to��// syscall.Write(p.d, buf, size), then p may be unreachable as soon as��// the program enters syscall.Write. The finalizer may run at that moment,��// closing p.d, causing syscall.Write to fail because it is writing to��// a closed file descriptor (or, worse, to an entirely different��// file descriptor opened by a different goroutine). To avoid this problem,��// call KeepAlive(p) after the call to syscall.Write.��//��// A single goroutine runs all finalizers for a program, sequentially.��// If a finalizer must run for a long time, it should do so by starting��// a new goroutine.��//��// In the terminology of the Go memory model, a call��// SetFinalizer(x, f) “synchronizes before” the finalization call f(x).��// However, there is no guarantee that KeepAlive(x) or any other use of x��// “synchronizes before” f(x), so in general a finalizer should use a mutex��// or other synchronization mechanism if it needs to access mutable state in x.��// For example, consider a finalizer that inspects a mutable field in x��// that is modified from time to time in the main program before x��// becomes unreachable and the finalizer is invoked.��// The modifications in the main program and the inspection in the finalizer��// need to use appropriate synchronization, such as mutexes or atomic updates,��// to avoid read-write races. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1072"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-setmutexprofilefraction">function setMutexProfileFraction</a></h2>
<pre><code class="language-haxe">function setMutexProfileFraction(_rate:stdgo.GoInt):stdgo.GoInt</code></pre>
<p>SetMutexProfileFraction controls the fraction of mutex contention events��// that are reported in the mutex profile. On average 1/rate events are��// reported. The previous rate is returned.��//��// To turn off profiling entirely, pass rate 0.��// To just read the current rate, pass rate \&lt; 0.��// (For n\>1 the details of sampling may change.) </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1132"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-stack">function stack</a></h2>
<pre><code class="language-haxe">function stack(_buf:stdgo.Slice&lt;stdgo.GoByte&gt;, _all:Bool):stdgo.GoInt</code></pre>
<p>Stack formats a stack trace of the calling goroutine into buf��// and returns the number of bytes written to buf.��// If all is true, Stack formats stack traces of all other goroutines��// into buf after the trace for the current goroutine. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1212"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-starttrace">function startTrace</a></h2>
<pre><code class="language-haxe">function startTrace():stdgo.Error</code></pre>
<p>StartTrace enables tracing for the current process.��// While tracing, the data will be buffered and available via ReadTrace.��// StartTrace returns an error if tracing is already enabled.��// Most clients should use the runtime/trace package or the testing package's��// -test.trace flag instead of calling StartTrace directly. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1314"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-stoptrace">function stopTrace</a></h2>
<pre><code class="language-haxe">function stopTrace():Void</code></pre>
<p>StopTrace stops tracing, if it was previously enabled.��// StopTrace only returns after all the reads for the trace have completed. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1321"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-threadcreateprofile">function threadCreateProfile</a></h2>
<pre><code class="language-haxe">function threadCreateProfile(_p:stdgo.Slice&lt;stdgo.runtime.StackRecord&gt;):{_1:Bool, _0:stdgo.GoInt}</code></pre>
<p>ThreadCreateProfile returns n, the number of records in the thread creation profile.��// If len(p) \>= n, ThreadCreateProfile copies the profile into p and returns n, true.��// If len(p) \&lt; n, ThreadCreateProfile does not change p and returns n, false.��//��// Most clients should use the runtime/pprof package instead��// of calling ThreadCreateProfile directly. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1192"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-unlockosthread">function unlockOSThread</a></h2>
<pre><code class="language-haxe">function unlockOSThread():Void</code></pre>
<p>UnlockOSThread undoes an earlier call to LockOSThread.��// If this drops the number of active LockOSThread calls on the��// calling goroutine to zero, it unwires the calling goroutine from��// its fixed operating system thread.��// If there are no active LockOSThread calls, this is a no-op.��//��// Before calling UnlockOSThread, the caller must ensure that the OS��// thread is suitable for running other goroutines. If the caller made��// any permanent changes to the state of the thread that would affect��// other goroutines, it should not call this function and thus leave��// the goroutine locked to the OS thread until the goroutine (and��// hence the thread) exits. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1285"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-version">function version</a></h2>
<pre><code class="language-haxe">function version():stdgo.GoString</code></pre>
<p>Version returns the Go tree's version string.��// It is either the commit hash and date at the time of the build or,��// when possible, a release tag like "go1.3". </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L990"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h1><a name="classes">Classes</a></h1>
<pre><code class="language-haxe">import stdgo.runtime.*</code></pre>
<h2><a name="class-blockprofilerecord">class BlockProfileRecord</a></h2>
<p>BlockProfileRecord describes blocking events originated��// at a particular call sequence (stack trace). </p>
<pre><code class="language-haxe">var count:stdgo.GoInt64</code></pre>
<pre><code class="language-haxe">var cycles:stdgo.GoInt64</code></pre>
<pre><code class="language-haxe">var stackRecord:stdgo.runtime.StackRecord</code></pre>
<h3><a name="blockprofilerecord-function-new">BlockProfileRecord function new</a></h3>
<pre><code class="language-haxe">function new(?count:stdgo.GoInt64, ?cycles:stdgo.GoInt64, ?stackRecord:stdgo.runtime.StackRecord):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L361"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="blockprofilerecord-function-stack">BlockProfileRecord function stack</a></h3>
<pre><code class="language-haxe">function stack():stdgo.Slice&lt;stdgo.GoUIntptr&gt;</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L375"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="blockprofilerecord-function-stack">BlockProfileRecord function stack</a></h3>
<pre><code class="language-haxe">function stack():stdgo.Slice&lt;stdgo.GoUIntptr&gt;</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1649"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class BlockProfileRecord_static_extension</h2>
<h3>BlockProfileRecord_static_extension function stack</h3>
<pre><code class="language-haxe">function stack():stdgo.Slice&lt;stdgo.GoUIntptr&gt;</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1649"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="class-frame">class Frame</a></h2>
<p>Frame is the information returned by Frames for each call frame. </p>
<pre><code class="language-haxe">var entry:stdgo.GoUIntptr</code></pre>
<p>Entry point program counter for the function; may be zero���// if not known. If Func is not nil then Entry ==���// Func.Entry(). </p>
<pre><code class="language-haxe">var file:stdgo.GoString</code></pre>
<p>File and Line are the file name and line number of the���// location in this frame. For non-leaf frames, this will be���// the location of a call. These may be the empty string and���// zero, respectively, if not known. </p>
<pre><code class="language-haxe">var func:stdgo.Ref&lt;stdgo.runtime.Func&gt;</code></pre>
<p>Func is the Func value of this call frame. This may be nil���// for non-Go code or fully inlined functions. </p>
<pre><code class="language-haxe">var function_:stdgo.GoString</code></pre>
<p>Function is the package path-qualified function name of���// this call frame. If non-empty, this string uniquely���// identifies a single function in the program.���// This may be the empty string if not known.���// If Func is not nil then Function == Func.Name(). </p>
<pre><code class="language-haxe">var line:stdgo.GoInt</code></pre>
<pre><code class="language-haxe">var pc:stdgo.GoUIntptr</code></pre>
<p>PC is the program counter for the location in this frame.���// For a frame that calls another frame, this will be the���// program counter of a call instruction. Because of inlining,���// multiple frames may have the same PC value, but different���// symbolic information. </p>
<h3><a name="frame-function-new">Frame function new</a></h3>
<pre><code class="language-haxe">function new(?pc:stdgo.GoUIntptr, ?func:stdgo.Ref&lt;stdgo.runtime.Func&gt;, ?function_:stdgo.GoString, ?file:stdgo.GoString, ?line:Null&lt;stdgo.GoInt&gt;, ?entry:stdgo.GoUIntptr):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L809"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="class-frames">class Frames</a></h2>
<p>Frames may be used to get function/file/line information for a��// slice of PC values returned by Callers. </p>
<h3><a name="frames-function-new">Frames function new</a></h3>
<pre><code class="language-haxe">function new():Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L754"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="frames-function-next">Frames function next</a></h3>
<pre><code class="language-haxe">function next():{_1:Bool, _0:stdgo.runtime.Frame}</code></pre>
<p>Next returns a Frame representing the next call frame in the slice���// of PC values. If it has already returned all call frames, Next���// returns a zero Frame.���//���// The more result indicates whether the next call to Next will return���// a valid Frame. It does not necessarily indicate whether this call���// returned one.���//���// See the Frames example for idiomatic usage. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1696"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class Frames_static_extension</h2>
<h3>Frames_static_extension function next</h3>
<pre><code class="language-haxe">function next():{_1:Bool, _0:stdgo.runtime.Frame}</code></pre>
<p>Next returns a Frame representing the next call frame in the slice���// of PC values. If it has already returned all call frames, Next���// returns a zero Frame.���//���// The more result indicates whether the next call to Next will return���// a valid Frame. It does not necessarily indicate whether this call���// returned one.���//���// See the Frames example for idiomatic usage. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1696"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="class-func">class Func</a></h2>
<p>A Func represents a Go function in the running binary. </p>
<h3><a name="func-function-new">Func function new</a></h3>
<pre><code class="language-haxe">function new():Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L836"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="func-function-entry">Func function entry</a></h3>
<pre><code class="language-haxe">function entry():stdgo.GoUIntptr</code></pre>
<p>Entry returns the entry address of the function. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1754"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="func-function-fileline">Func function fileLine</a></h3>
<pre><code class="language-haxe">function fileLine( _pc:stdgo.GoUIntptr):{_1:stdgo.GoInt, _0:stdgo.GoString}</code></pre>
<p>FileLine returns the file name and line number of the���// source code corresponding to the program counter pc.���// The result will not be accurate if pc is not a program���// counter within f. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1747"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="func-function-name">Func function name</a></h3>
<pre><code class="language-haxe">function name():stdgo.GoString</code></pre>
<p>Name returns the name of the function. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1761"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class Func_static_extension</h2>
<h3>Func_static_extension function entry</h3>
<pre><code class="language-haxe">function entry():stdgo.GoUIntptr</code></pre>
<p>Entry returns the entry address of the function. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1754"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Func_static_extension function fileLine</h3>
<pre><code class="language-haxe">function fileLine( _pc:stdgo.GoUIntptr):{_1:stdgo.GoInt, _0:stdgo.GoString}</code></pre>
<p>FileLine returns the file name and line number of the���// source code corresponding to the program counter pc.���// The result will not be accurate if pc is not a program���// counter within f. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1747"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Func_static_extension function name</h3>
<pre><code class="language-haxe">function name():stdgo.GoString</code></pre>
<p>Name returns the name of the function. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1761"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="class-memprofilerecord">class MemProfileRecord</a></h2>
<p>A MemProfileRecord describes the live objects allocated��// by a particular call sequence (stack trace). </p>
<pre><code class="language-haxe">var allocBytes:stdgo.GoInt64</code></pre>
<p>number of bytes allocated, freed </p>
<pre><code class="language-haxe">var allocObjects:stdgo.GoInt64</code></pre>
<p>stack trace for this record; ends at first 0 entry </p>
<pre><code class="language-haxe">var freeBytes:stdgo.GoInt64</code></pre>
<p>number of objects allocated, freed </p>
<pre><code class="language-haxe">var freeObjects:stdgo.GoInt64</code></pre>
<pre><code class="language-haxe">var stack0:stdgo.GoArray&lt;stdgo.GoUIntptr&gt;</code></pre>
<h3><a name="memprofilerecord-function-new">MemProfileRecord function new</a></h3>
<pre><code class="language-haxe">function new(?allocBytes:stdgo.GoInt64, ?freeBytes:stdgo.GoInt64, ?allocObjects:stdgo.GoInt64, ?freeObjects:stdgo.GoInt64, ?stack0:stdgo.GoArray&lt;stdgo.GoUIntptr&gt;):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L330"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="memprofilerecord-function-inusebytes">MemProfileRecord function inUseBytes</a></h3>
<pre><code class="language-haxe">function inUseBytes():stdgo.GoInt64</code></pre>
<p>InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes). </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1624"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="memprofilerecord-function-inuseobjects">MemProfileRecord function inUseObjects</a></h3>
<pre><code class="language-haxe">function inUseObjects():stdgo.GoInt64</code></pre>
<p>InUseObjects returns the number of objects in use (AllocObjects - FreeObjects). </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1617"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="memprofilerecord-function-stack">MemProfileRecord function stack</a></h3>
<pre><code class="language-haxe">function stack():stdgo.Slice&lt;stdgo.GoUIntptr&gt;</code></pre>
<p>Stack returns the stack trace associated with the record,���// a prefix of r.Stack0. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1610"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class MemProfileRecord_static_extension</h2>
<h3>MemProfileRecord_static_extension function inUseBytes</h3>
<pre><code class="language-haxe">function inUseBytes():stdgo.GoInt64</code></pre>
<p>InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes). </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1624"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>MemProfileRecord_static_extension function inUseObjects</h3>
<pre><code class="language-haxe">function inUseObjects():stdgo.GoInt64</code></pre>
<p>InUseObjects returns the number of objects in use (AllocObjects - FreeObjects). </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1617"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>MemProfileRecord_static_extension function stack</h3>
<pre><code class="language-haxe">function stack():stdgo.Slice&lt;stdgo.GoUIntptr&gt;</code></pre>
<p>Stack returns the stack trace associated with the record,���// a prefix of r.Stack0. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1610"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="class-memstats">class MemStats</a></h2>
<p>A MemStats records statistics about the memory allocator. </p>
<pre><code class="language-haxe">var alloc:stdgo.GoUInt64</code></pre>
<p>Alloc is bytes of allocated heap objects.���//���// This is the same as HeapAlloc (see below). </p>
<pre><code class="language-haxe">var buckHashSys:stdgo.GoUInt64</code></pre>
<p>BuckHashSys is bytes of memory in profiling bucket hash tables. </p>
<pre><code class="language-haxe">var bySize:stdgo.GoArray&lt;{size:stdgo.GoUInt32, mallocs:stdgo.GoUInt64, frees:stdgo.GoUInt64}&gt;</code></pre>
<p>BySize reports per-size class allocation statistics.���//���// BySize[N] gives statistics for allocations of size S where���// BySize[N-1].Size \&lt; S ≤ BySize[N].Size.���//���// This does not report allocations larger than BySize[60].Size. </p>
<pre><code class="language-haxe">var debugGC:Bool</code></pre>
<p>DebugGC is currently unused. </p>
<pre><code class="language-haxe">var enableGC:Bool</code></pre>
<p>EnableGC indicates that GC is enabled. It is always true,���// even if GOGC=off. </p>
<pre><code class="language-haxe">var frees:stdgo.GoUInt64</code></pre>
<p>Frees is the cumulative count of heap objects freed. </p>
<pre><code class="language-haxe">var gccpufraction:stdgo.GoFloat64</code></pre>
<p>GCCPUFraction is the fraction of this program's available���// CPU time used by the GC since the program started.���//���// GCCPUFraction is expressed as a number between 0 and 1,���// where 0 means GC has consumed none of this program's CPU. A���// program's available CPU time is defined as the integral of���// GOMAXPROCS since the program started. That is, if���// GOMAXPROCS is 2 and a program has been running for 10���// seconds, its "available CPU" is 20 seconds. GCCPUFraction���// does not include CPU time used for write barrier activity.���//���// This is the same as the fraction of CPU reported by���// GODEBUG=gctrace=1. </p>
<pre><code class="language-haxe">var gcsys:stdgo.GoUInt64</code></pre>
<p>GCSys is bytes of memory in garbage collection metadata. </p>
<pre><code class="language-haxe">var heapAlloc:stdgo.GoUInt64</code></pre>
<p>HeapAlloc is bytes of allocated heap objects.���//���// "Allocated" heap objects include all reachable objects, as���// well as unreachable objects that the garbage collector has���// not yet freed. Specifically, HeapAlloc increases as heap���// objects are allocated and decreases as the heap is swept���// and unreachable objects are freed. Sweeping occurs���// incrementally between GC cycles, so these two processes���// occur simultaneously, and as a result HeapAlloc tends to���// change smoothly (in contrast with the sawtooth that is���// typical of stop-the-world garbage collectors). </p>
<pre><code class="language-haxe">var heapIdle:stdgo.GoUInt64</code></pre>
<p>HeapIdle is bytes in idle (unused) spans.���//���// Idle spans have no objects in them. These spans could be���// (and may already have been) returned to the OS, or they can���// be reused for heap allocations, or they can be reused as���// stack memory.���//���// HeapIdle minus HeapReleased estimates the amount of memory���// that could be returned to the OS, but is being retained by���// the runtime so it can grow the heap without requesting more���// memory from the OS. If this difference is significantly���// larger than the heap size, it indicates there was a recent���// transient spike in live heap size. </p>
<pre><code class="language-haxe">var heapInuse:stdgo.GoUInt64</code></pre>
<p>HeapInuse is bytes in in-use spans.���//���// In-use spans have at least one object in them. These spans���// can only be used for other objects of roughly the same���// size.���//���// HeapInuse minus HeapAlloc estimates the amount of memory���// that has been dedicated to particular size classes, but is���// not currently being used. This is an upper bound on���// fragmentation, but in general this memory can be reused���// efficiently. </p>
<pre><code class="language-haxe">var heapObjects:stdgo.GoUInt64</code></pre>
<p>HeapObjects is the number of allocated heap objects.���//���// Like HeapAlloc, this increases as objects are allocated and���// decreases as the heap is swept and unreachable objects are���// freed. </p>
<pre><code class="language-haxe">var heapReleased:stdgo.GoUInt64</code></pre>
<p>HeapReleased is bytes of physical memory returned to the OS.���//���// This counts heap memory from idle spans that was returned���// to the OS and has not yet been reacquired for the heap. </p>
<pre><code class="language-haxe">var heapSys:stdgo.GoUInt64</code></pre>
<p>HeapSys is bytes of heap memory obtained from the OS.���//���// HeapSys measures the amount of virtual address space���// reserved for the heap. This includes virtual address space���// that has been reserved but not yet used, which consumes no���// physical memory, but tends to be small, as well as virtual���// address space for which the physical memory has been���// returned to the OS after it became unused (see HeapReleased���// for a measure of the latter).���//���// HeapSys estimates the largest size the heap has had. </p>
<pre><code class="language-haxe">var lastGC:stdgo.GoUInt64</code></pre>
<p>LastGC is the time the last garbage collection finished, as���// nanoseconds since 1970 (the UNIX epoch). </p>
<pre><code class="language-haxe">var lookups:stdgo.GoUInt64</code></pre>
<p>Lookups is the number of pointer lookups performed by the���// runtime.���//���// This is primarily useful for debugging runtime internals. </p>
<pre><code class="language-haxe">var mallocs:stdgo.GoUInt64</code></pre>
<p>Mallocs is the cumulative count of heap objects allocated.���// The number of live objects is Mallocs - Frees. </p>
<pre><code class="language-haxe">var mcacheInuse:stdgo.GoUInt64</code></pre>
<p>MCacheInuse is bytes of allocated mcache structures. </p>
<pre><code class="language-haxe">var mcacheSys:stdgo.GoUInt64</code></pre>
<p>MCacheSys is bytes of memory obtained from the OS for���// mcache structures. </p>
<pre><code class="language-haxe">var mspanInuse:stdgo.GoUInt64</code></pre>
<p>MSpanInuse is bytes of allocated mspan structures. </p>
<pre><code class="language-haxe">var mspanSys:stdgo.GoUInt64</code></pre>
<p>MSpanSys is bytes of memory obtained from the OS for mspan���// structures. </p>
<pre><code class="language-haxe">var nextGC:stdgo.GoUInt64</code></pre>
<p>NextGC is the target heap size of the next GC cycle.���//���// The garbage collector's goal is to keep HeapAlloc ≤ NextGC.���// At the end of each GC cycle, the target for the next cycle���// is computed based on the amount of reachable data and the���// value of GOGC. </p>
<pre><code class="language-haxe">var numForcedGC:stdgo.GoUInt32</code></pre>
<p>NumForcedGC is the number of GC cycles that were forced by���// the application calling the GC function. </p>
<pre><code class="language-haxe">var numGC:stdgo.GoUInt32</code></pre>
<p>NumGC is the number of completed GC cycles. </p>
<pre><code class="language-haxe">var otherSys:stdgo.GoUInt64</code></pre>
<p>OtherSys is bytes of memory in miscellaneous off-heap���// runtime allocations. </p>
<pre><code class="language-haxe">var pauseEnd:stdgo.GoArray&lt;stdgo.GoUInt64&gt;</code></pre>
<p>PauseEnd is a circular buffer of recent GC pause end times,���// as nanoseconds since 1970 (the UNIX epoch).���//���// This buffer is filled the same way as PauseNs. There may be���// multiple pauses per GC cycle; this records the end of the���// last pause in a cycle. </p>
<pre><code class="language-haxe">var pauseNs:stdgo.GoArray&lt;stdgo.GoUInt64&gt;</code></pre>
<p>PauseNs is a circular buffer of recent GC stop-the-world���// pause times in nanoseconds.���//���// The most recent pause is at PauseNs[(NumGC+255)%256]. In���// general, PauseNs[N%256] records the time paused in the most���// recent N%256th GC cycle. There may be multiple pauses per���// GC cycle; this is the sum of all pauses during a cycle. </p>
<pre><code class="language-haxe">var pauseTotalNs:stdgo.GoUInt64</code></pre>
<p>PauseTotalNs is the cumulative nanoseconds in GC���// stop-the-world pauses since the program started.���//���// During a stop-the-world pause, all goroutines are paused���// and only the garbage collector can run. </p>
<pre><code class="language-haxe">var stackInuse:stdgo.GoUInt64</code></pre>
<p>StackInuse is bytes in stack spans.���//���// In-use stack spans have at least one stack in them. These���// spans can only be used for other stacks of the same size.���//���// There is no StackIdle because unused stack spans are���// returned to the heap (and hence counted toward HeapIdle). </p>
<pre><code class="language-haxe">var stackSys:stdgo.GoUInt64</code></pre>
<p>StackSys is bytes of stack memory obtained from the OS.���//���// StackSys is StackInuse, plus any memory obtained directly���// from the OS for OS thread stacks (which should be minimal). </p>
<pre><code class="language-haxe">var sys:stdgo.GoUInt64</code></pre>
<p>Sys is the total bytes of memory obtained from the OS.���//���// Sys is the sum of the XSys fields below. Sys measures the���// virtual address space reserved by the Go runtime for the���// heap, stacks, and other internal data structures. It's���// likely that not all of the virtual address space is backed���// by physical memory at any given moment, though in general���// it all was at some point. </p>
<pre><code class="language-haxe">var totalAlloc:stdgo.GoUInt64</code></pre>
<p>TotalAlloc is cumulative bytes allocated for heap objects.���//���// TotalAlloc increases as heap objects are allocated, but���// unlike Alloc and HeapAlloc, it does not decrease when���// objects are freed. </p>
<h3><a name="memstats-function-new">MemStats function new</a></h3>
<pre><code class="language-haxe">function new(?alloc:stdgo.GoUInt64, ?totalAlloc:stdgo.GoUInt64, ?sys:stdgo.GoUInt64, ?lookups:stdgo.GoUInt64, ?mallocs:stdgo.GoUInt64, ?frees:stdgo.GoUInt64, ?heapAlloc:stdgo.GoUInt64, ?heapSys:stdgo.GoUInt64, ?heapIdle:stdgo.GoUInt64, ?heapInuse:stdgo.GoUInt64, ?heapReleased:stdgo.GoUInt64, ?heapObjects:stdgo.GoUInt64, ?stackInuse:stdgo.GoUInt64, ?stackSys:stdgo.GoUInt64, ?mspanInuse:stdgo.GoUInt64, ?mspanSys:stdgo.GoUInt64, ?mcacheInuse:stdgo.GoUInt64, ?mcacheSys:stdgo.GoUInt64, ?buckHashSys:stdgo.GoUInt64, ?gcsys:stdgo.GoUInt64, ?otherSys:stdgo.GoUInt64, ?nextGC:stdgo.GoUInt64, ?lastGC:stdgo.GoUInt64, ?pauseTotalNs:stdgo.GoUInt64, ?pauseNs:stdgo.GoArray&lt;stdgo.GoUInt64&gt;, ?pauseEnd:stdgo.GoArray&lt;stdgo.GoUInt64&gt;, ?numGC:stdgo.GoUInt32, ?numForcedGC:stdgo.GoUInt32, ?gccpufraction:stdgo.GoFloat64, ?enableGC:Bool, ?debugGC:Bool, ?bySize:stdgo.GoArray&lt;{size:stdgo.GoUInt32, mallocs:stdgo.GoUInt64, frees:stdgo.GoUInt64}&gt;):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L666"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="class-stackrecord">class StackRecord</a></h2>
<p>A StackRecord describes a single execution stack. </p>
<pre><code class="language-haxe">var stack0:stdgo.GoArray&lt;stdgo.GoUIntptr&gt;</code></pre>
<p>stack trace for this record; ends at first 0 entry </p>
<h3><a name="stackrecord-function-new">StackRecord function new</a></h3>
<pre><code class="language-haxe">function new(?stack0:stdgo.GoArray&lt;stdgo.GoUIntptr&gt;):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L294"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="stackrecord-function-stack">StackRecord function stack</a></h3>
<pre><code class="language-haxe">function stack():stdgo.Slice&lt;stdgo.GoUIntptr&gt;</code></pre>
<p>Stack returns the stack trace associated with the record,���// a prefix of r.Stack0. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1563"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class StackRecord_static_extension</h2>
<h3>StackRecord_static_extension function stack</h3>
<pre><code class="language-haxe">function stack():stdgo.Slice&lt;stdgo.GoUIntptr&gt;</code></pre>
<p>Stack returns the stack trace associated with the record,���// a prefix of r.Stack0. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1563"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class T__struct_0_static_extension</h2>
<h2><a name="class-typeassertionerror">class TypeAssertionError</a></h2>
<p>A TypeAssertionError explains a failed type assertion. </p>
<h3><a name="typeassertionerror-function-new">TypeAssertionError function new</a></h3>
<pre><code class="language-haxe">function new():Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L275"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="typeassertionerror-function-error">TypeAssertionError function error</a></h3>
<pre><code class="language-haxe">function error():stdgo.GoString</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1526"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="typeassertionerror-function-runtimeerror">TypeAssertionError function runtimeError</a></h3>
<pre><code class="language-haxe">function runtimeError():Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1530"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class TypeAssertionError_static_extension</h2>
<h3>TypeAssertionError_static_extension function error</h3>
<pre><code class="language-haxe">function error():stdgo.GoString</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1526"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>TypeAssertionError_static_extension function runtimeError</h3>
<pre><code class="language-haxe">function runtimeError():Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/runtime//Runtime.hx#L1530"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h1><a name="typedefs">Typedefs</a></h1>
<pre><code class="language-haxe">import stdgo.runtime.*</code></pre>
<h2><a name="typedef-t_error">typedef T_error</a></h2>
<pre><code class="language-haxe">typedef T_error = var a:{&lt;__underlying__&gt; | ():Void | {&lt;haxe_doc&gt;} | ():stdgo.GoString | ():stdgo.AnyInterface}</code></pre>
<p>The Error interface identifies a run time error. </p>
    </article>
</body>
</html>