<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>go2hx stdgo</title>
    <link rel="shortcut icon" href="logo.svg">
    <meta property="og:title" content="go2hx stdgo"/>
    <meta property="og:type" content="Website"/>
    <meta property="og:url" content="https://go2hx.github.io"/>
    <meta property="og:description" content="go2hx is a Go to Haxe compiler"/>
    <meta property="og:image" content="logo.png"/>
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:width" content="512">
    <meta property="og:image:height" content="512">
    <meta property="og:image:alt" content="go2hx logo">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="go2hx">
    <meta name="twitter:description" content="go2hx, The Go to Haxe compiler">
    <meta name="twitter:image" content="logo.png">
    <meta name="twitter:image:alt" content="go2hx logo">
    <link href="../../prism.css" rel="stylesheet" />
    <link rel="stylesheet" href="../../style.css" />
		<style>
			body {
				box-sizing: border-box;
				min-width: 200px;
				max-width: 980px;
				margin: 0 auto;
				padding: 45px;
			}
			@media (prefers-color-scheme: dark) {
				body {
					background-color: #0d1117;
				}
			}
		</style>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css">
		<style>
			.github-fork-ribbon:before {
				background-color: #121612;
			}
		</style>
</head>
<body>
    <a class="markdown-body"><div class="header">
    <table>
            <thead>
            <th><h2><a href="https://go2hx.github.io/"><font color="#357b99">go</font><font color="#cad0d8">2</font><font color="#e2ac3f">hx</font></a></h2></th>
            <th><h2><a href="https://go2hx.github.io/manual">manual</a></h2></th>
            <th><h2><a href="https://github.com/go2hx/go2hx">github</a></h2></th>
        </thead>
    </table>
</div></a>
    <script src="../../prism.js"></script>
    <article class="markdown-body">
        <h1>Module: <code>stdgo.fmt</code></h1>
<p><a href="../index.html">(view library index)</a></p>
<h1><a name="overview">Overview</a></h1><table><thead><th align="null">\<em>  Package fmt implements formatted I/O with functions analogous  to C's printf and scanf.  The format 'verbs' are derived from C's but  are simpler.   # Printing   The verbs:   General:    %v the value in a default format    when printing structs, the plus flag (%+v) adds field names   %#v a Go-syntax representation of the value   %T a Go-syntax representation of the type of the value   %% a literal percent sign; consumes no value   Boolean:    %t the word true or false   Integer:    %b base 2   %c the character represented by the corresponding Unicode code point   %d base 10   %o base 8   %O base 8 with 0o prefix   %q a single-quoted character literal safely escaped with Go syntax.   %x base 16, with lower-case letters for a-f   %X base 16, with upper-case letters for A-F   %U Unicode format: U+1234; same as "U+%04X"   Floating-point and complex constituents:    %b decimalless scientific notation with exponent a power of two,    in the manner of strconv.FormatFloat with the 'b' format,    e.g. -123456p-78   %e scientific notation, e.g. -1.234456e+78   %E scientific notation, e.g. -1.234456E+78   %f decimal point but no exponent, e.g. 123.456   %F synonym for %f   %g %e for large exponents, %f otherwise. Precision is discussed below.   %G %E for large exponents, %F otherwise   %x hexadecimal notation (with decimal power of two exponent), e.g. -0x1.23abcp+20   %X upper-case hexadecimal notation, e.g. -0X1.23ABCP+20   String and slice of bytes (treated equivalently with these verbs):    %s the uninterpreted bytes of the string or slice   %q a double-quoted string safely escaped with Go syntax   %x base 16, lower-case, two characters per byte   %X base 16, upper-case, two characters per byte   Slice:    %p address of 0th element in base 16 notation, with leading 0x   Pointer:    %p base 16 notation, with leading 0x   The %b, %d, %o, %x and %X verbs also work with pointers,   formatting the value exactly as if it were an integer.   The default format for %v is:    bool:                    %t   int, int8 etc.:          %d   uint, uint8 etc.:        %d, %#x if printed with %#v   float32, complex64, etc: %g   string:                  %s   chan:                    %p   pointer:                 %p   For compound objects, the elements are printed using these rules, recursively,  laid out like this:    struct:             {field0 field1 ...}   array, slice:       [elem0 elem1 ...]   maps:               map[key1:value1 key2:value2 ...]   pointer to above:   &amp;{}, &amp;[], &amp;map[]   Width is specified by an optional decimal number immediately preceding the verb.  If absent, the width is whatever is necessary to represent the value.  Precision is specified after the (optional) width by a period followed by a  decimal number. If no period is present, a default precision is used.  A period with no following number specifies a precision of zero.  Examples:    %f     default width, default precision   %9f    width 9, default precision   %.2f   default width, precision 2   %9.2f  width 9, precision 2   %9.f   width 9, precision 0   Width and precision are measured in units of Unicode code points,  that is, runes. (This differs from C's printf where the  units are always measured in bytes.) Either or both of the flags  may be replaced with the character '\</em>', causing their values to be  obtained from the next operand (preceding the one to format),  which must be of type int.   For most values, width is the minimum number of runes to output,  padding the formatted form with spaces if necessary.   For strings, byte slices and byte arrays, however, precision  limits the length of the input to be formatted (not the size of  the output), truncating if necessary. Normally it is measured in  runes, but for these types when formatted with the %x or %X format  it is measured in bytes.   For floating-point values, width sets the minimum width of the field and  precision sets the number of places after the decimal, if appropriate,  except that for %g/%G precision sets the maximum number of significant  digits (trailing zeros are removed). For example, given 12.345 the format  %6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e, %f  and %#g is 6; for %g it is the smallest number of digits necessary to identify  the value uniquely.   For complex numbers, the width and precision apply to the two  components independently and the result is parenthesized, so %f applied  to 1.2+3.4i produces (1.200000+3.400000i).   When formatting a single integer code point or a rune string (type []rune)  with %q, invalid Unicode code points are changed to the Unicode replacement  character, U+FFFD, as in strconv.QuoteRune.   Other flags:    '+' always print a sign for numeric values;    guarantee ASCII-only output for %q (%+q)   '-' pad with spaces on the right rather than the left (left-justify the field)   '#' alternate format: add leading 0b for binary (%#b), 0 for octal (%#o),    0x or 0X for hex (%#x or %#X); suppress 0x for %p (%#p);    for %q, print a raw (backquoted) string if strconv.CanBackquote    returns true;    always print a decimal point for %e, %E, %f, %F, %g and %G;    do not remove trailing zeros for %g and %G;    write e.g. U+0078 'x' if the character is printable for %U (%#U).   ' ' (space) leave a space for elided sign in numbers (% d);    put spaces between bytes printing strings or slices in hex (% x, % X)   '0' pad with leading zeros rather than spaces;    for numbers, this moves the padding after the sign;    ignored for strings, byte slices and byte arrays   Flags are ignored by verbs that do not expect them.  For example there is no alternate decimal format, so %#d and %d  behave identically.   For each Printf-like function, there is also a Print function  that takes no format and is equivalent to saying %v for every  operand.  Another variant Println inserts blanks between  operands and appends a newline.   Regardless of the verb, if an operand is an interface value,  the internal concrete value is used, not the interface itself.  Thus:    var i interface{} = 23   fmt.Printf("%v\n", i)   will print 23.   Except when printed using the verbs %T and %p, special  formatting considerations apply for operands that implement  certain interfaces. In order of application:   1. If the operand is a reflect.Value, the operand is replaced by the  concrete value that it holds, and printing continues with the next rule.   2. If an operand implements the Formatter interface, it will  be invoked. In this case the interpretation of verbs and flags is  controlled by that implementation.   3. If the %v verb is used with the # flag (%#v) and the operand  implements the GoStringer interface, that will be invoked.   If the format (which is implicitly %v for Println etc.) is valid  for a string (%s %q %v %x %X), the following two rules apply:   4. If an operand implements the error interface, the Error method  will be invoked to convert the object to a string, which will then  be formatted as required by the verb (if any).   5. If an operand implements method String() string, that method  will be invoked to convert the object to a string, which will then  be formatted as required by the verb (if any).   For compound operands such as slices and structs, the format  applies to the elements of each operand, recursively, not to the  operand as a whole. Thus %q will quote each element of a slice  of strings, and %6.2f will control formatting for each element  of a floating-point array.   However, when printing a byte slice with a string-like verb  (%s %q %x %X), it is treated identically to a string, as a single item.   To avoid recursion in cases such as    type X string   func (x X) String() string { return Sprintf("\&lt;%s\>", x) }   convert the value before recurring:    func (x X) String() string { return Sprintf("\&lt;%s\>", string(x)) }   Infinite recursion can also be triggered by self-referential data  structures, such as a slice that contains itself as an element, if  that type has a String method. Such pathologies are rare, however,  and the package does not protect against them.   When printing a struct, fmt cannot and therefore does not invoke  formatting methods such as Error or String on unexported fields.   # Explicit argument indexes   In Printf, Sprintf, and Fprintf, the default behavior is for each  formatting verb to format successive arguments passed in the call.  However, the notation [n] immediately before the verb indicates that the  nth one-indexed argument is to be formatted instead. The same notation  before a '\<em>' for a width or precision selects the argument index holding  the value. After processing a bracketed expression [n], subsequent verbs  will use arguments n+1, n+2, etc. unless otherwise directed.   For example,    fmt.Sprintf("%[2]d %[1]d\n", 11, 22)   will yield "22 11", while    fmt.Sprintf("%[3]\</em>.[2]\<em>[1]f", 12.0, 2, 6)   equivalent to    fmt.Sprintf("%6.2f", 12.0)   will yield " 12.00". Because an explicit index affects subsequent verbs,  this notation can be used to print the same values multiple times  by resetting the index for the first argument to be repeated:    fmt.Sprintf("%d %d %#[1]x %#x", 16, 17)   will yield "16 17 0x10 0x11".   # Format errors   If an invalid argument is given for a verb, such as providing  a string to %d, the generated string will contain a  description of the problem, as in these examples:    Wrong type or unknown verb: %!verb(type=value)    Printf("%d", "hi"):        %!d(string=hi)   Too many arguments: %!(EXTRA type=value)    Printf("hi", "guys"):      hi%!(EXTRA string=guys)   Too few arguments: %!verb(MISSING)    Printf("hi%d"):            hi%!d(MISSING)   Non-int for width or precision: %!(BADWIDTH) or %!(BADPREC)    Printf("%\</em>s", 4.5, "hi"):  %!(BADWIDTH)hi    Printf("%.\<em>s", 4.5, "hi"): %!(BADPREC)hi   Invalid or invalid use of argument index: %!(BADINDEX)    Printf("%\</em>[2]d", 7):       %!d(BADINDEX)    Printf("%.[2]d", 7):       %!d(BADINDEX)   All errors begin with the string "%!" followed sometimes  by a single character (the verb) and end with a parenthesized  description.   If an Error or String method triggers a panic when called by a  print routine, the fmt package reformats the error message  from the panic, decorating it with an indication that it came  through the fmt package.  For example, if a String method  calls panic("bad"), the resulting formatted message will look  like    %!s(PANIC=bad)   The %!s just shows the print verb in use when the failure  occurred. If the panic is caused by a nil receiver to an Error  or String method, however, the output is the undecorated  string, "\<nil\>".   # Scanning   An analogous set of functions scans formatted text to yield  values.  Scan, Scanf and Scanln read from os.Stdin; Fscan,  Fscanf and Fscanln read from a specified io.Reader; Sscan,  Sscanf and Sscanln read from an argument string.   Scan, Fscan, Sscan treat newlines in the input as spaces.   Scanln, Fscanln and Sscanln stop scanning at a newline and  require that the items be followed by a newline or EOF.   Scanf, Fscanf, and Sscanf parse the arguments according to a  format string, analogous to that of Printf. In the text that  follows, 'space' means any Unicode whitespace character  except newline.   In the format string, a verb introduced by the % character  consumes and parses input; these verbs are described in more  detail below. A character other than %, space, or newline in  the format consumes exactly that input character, which must  be present. A newline with zero or more spaces before it in  the format string consumes zero or more spaces in the input  followed by a single newline or the end of the input. A space  following a newline in the format string consumes zero or more  spaces in the input. Otherwise, any run of one or more spaces  in the format string consumes as many spaces as possible in  the input. Unless the run of spaces in the format string  appears adjacent to a newline, the run must consume at least  one space from the input or find the end of the input.   The handling of spaces and newlines differs from that of C's  scanf family: in C, newlines are treated as any other space,  and it is never an error when a run of spaces in the format  string finds no spaces to consume in the input.   The verbs behave analogously to those of Printf.  For example, %x will scan an integer as a hexadecimal number,  and %v will scan the default representation format for the value.  The Printf verbs %p and %T and the flags # and + are not implemented.  For floating-point and complex values, all valid formatting verbs  (%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept  both decimal and hexadecimal notation (for example: "2.3e+7", "0x4.5p-8")  and digit-separating underscores (for example: "3.14159_26535_89793").   Input processed by verbs is implicitly space-delimited: the  implementation of every verb except %c starts by discarding  leading spaces from the remaining input, and the %s verb  (and %v reading into a string) stops consuming input at the first  space or newline character.   The familiar base-setting prefixes 0b (binary), 0o and 0 (octal),  and 0x (hexadecimal) are accepted when scanning integers  without a format or with the %v verb, as are digit-separating  underscores.   Width is interpreted in the input text but there is no  syntax for scanning with a precision (no %5.2f, just %5f).  If width is provided, it applies after leading spaces are  trimmed and specifies the maximum number of runes to read  to satisfy the verb. For example,    Sscanf(" 1234567 ", "%5s%d", &amp;s, &amp;i)   will set s to "12345" and i to 67 while    Sscanf(" 12 34 567 ", "%5s%d", &amp;s, &amp;i)   will set s to "12" and i to 34.   In all the scanning functions, a carriage return followed  immediately by a newline is treated as a plain newline  (\r\n means the same as \n).   In all the scanning functions, if an operand implements method  Scan (that is, it implements the Scanner interface) that  method will be used to scan the text for that operand.  Also,  if the number of arguments scanned is less than the number of  arguments provided, an error is returned.   All arguments to be scanned must be either pointers to basic  types or implementations of the Scanner interface.   Like Scanf and Fscanf, Sscanf need not consume its entire input.  There is no way to recover how much of the input string Sscanf used.   Note: Fscan etc. can read one character (rune) past the input  they return, which means that a loop calling a scan routine  may skip some of the input.  This is usually a problem only  when there is no space between input values.  If the reader  provided to Fscan implements ReadRune, that method will be used  to read characters.  If the reader also implements UnreadRune,  that method will be used to save the character and successive  calls will not lose data.  To attach ReadRune and UnreadRune  methods to a reader without that capability, use  bufio.NewReader.  *</th><th align="null">/</th></thead><tbody></tbody></table><details><summary>hl tests failed</summary>
<p>
<pre><code>stdgo/reflect/Reflect.hx:2977: characters 28-35 : Warning : Potential typo detected (expected similar values are refType). Consider using `var keyType` instead
Error: Command failed with error 1
stdgo/internal/Macro.macro.hx:35: define
=== RUN  TestErrorf
err.Error() = "wrapped two errors: 1 %!w(fmt_test._Fmt_test.errString=2)", want "wrapped two errors: 1 %!w(fmt_test.errString=2)"</code></pre>
<p></p>
</details></p><details><summary>interp tests failed</summary>
<p>
<pre><code>stdgo/reflect/Reflect.hx:2977: characters 28-35 : Warning : Potential typo detected (expected similar values are refType). Consider using `var keyType` instead
stdgo/internal/Macro.macro.hx:35: define
=== RUN  TestErrorf
err.Error() = "wrapped two errors: 1 %!w(fmt_test._Fmt_test.errString=2)", want "wrapped two errors: 1 %!w(fmt_test.errString=2)"</code></pre>
<p></p>
</details></p><details><summary>jvm tests failed</summary>
<p>
<pre><code>stdgo/reflect/Reflect.hx:2977: characters 28-35 : Warning : Potential typo detected (expected similar values are refType). Consider using `var keyType` instead
IO.Overflow("write_ui16")
stdgo/internal/Macro.macro.hx:35: define</code></pre>
<p></p>
</details></p>
<h1><a name="index">Index</a></h1><ul><li>
<p><a href="#function-append"><code>function append(_b:stdgo.Slice&lt;stdgo.GoByte&gt;, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-appendf"><code>function appendf(_b:stdgo.Slice&lt;stdgo.GoByte&gt;, _format:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-appendln"><code>function appendln(_b:stdgo.Slice&lt;stdgo.GoByte&gt;, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-errorf"><code>function errorf(_format:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):stdgo.Error</code></a></p></li><li>
<p><a href="#function-fprint"><code>function fprint(_w:stdgo.io.Writer, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-fprintf"><code>function fprintf(_w:stdgo.io.Writer, _format:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-fprintln"><code>function fprintln(_w:stdgo.io.Writer, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-fscan"><code>function fscan(_r:stdgo.io.Reader, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-fscanf"><code>function fscanf(_r:stdgo.io.Reader, _format:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-fscanln"><code>function fscanln(_r:stdgo.io.Reader, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-isspace"><code>function isSpace()</code></a></p></li><li>
<p><a href="#function-parsenum"><code>function parsenum(:stdgo.GoString, :stdgo.GoInt, :stdgo.GoInt):{_2:stdgo.GoInt, _1:Bool, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-print"><code>function print(_a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-printf"><code>function printf(_format:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-println"><code>function println(_a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-scan"><code>function scan(_a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-scanf"><code>function scanf(_format:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-scanln"><code>function scanln(_a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-sprint"><code>function sprint(_a:haxe.Rest&lt;stdgo.AnyInterface&gt;):stdgo.GoString</code></a></p></li><li>
<p><a href="#function-sprintf"><code>function sprintf(_format:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):stdgo.GoString</code></a></p></li><li>
<p><a href="#function-sprintln"><code>function sprintln(_a:haxe.Rest&lt;stdgo.AnyInterface&gt;):stdgo.GoString</code></a></p></li><li>
<p><a href="#function-sscan"><code>function sscan(_str:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-sscanf"><code>function sscanf(_str:stdgo.GoString, _format:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#function-sscanln"><code>function sscanln(_str:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#class-t_buffer_static_extension">class T_buffer_static_extension</a></p></li><li>
<p><a href="#t_buffer_static_extension-function-_write"><code>function _write(_b:stdgo.Ref&lt;stdgo.fmt._Fmt.T_buffer&gt;, _p:stdgo.Slice&lt;stdgo.GoByte&gt;):Void</code></a></p></li><li>
<p><a href="#t_buffer_static_extension-function-_writebyte"><code>function _writeByte(_b:stdgo.Ref&lt;stdgo.fmt._Fmt.T_buffer&gt;, _c:stdgo.GoByte):Void</code></a></p></li><li>
<p><a href="#t_buffer_static_extension-function-_writerune"><code>function _writeRune(_bp:stdgo.Ref&lt;stdgo.fmt._Fmt.T_buffer&gt;, _r:stdgo.GoRune):Void</code></a></p></li><li>
<p><a href="#t_buffer_static_extension-function-_writestring"><code>function _writeString(_b:stdgo.Ref&lt;stdgo.fmt._Fmt.T_buffer&gt;, _s:stdgo.GoString):Void</code></a></p></li><li>
<p><a href="#class-t_fmt_static_extension">class T_fmt_static_extension</a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_clearflags"><code>function _clearflags(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;):Void</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_fmtboolean"><code>function _fmtBoolean(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _v:Bool):Void</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_fmtbs"><code>function _fmtBs(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _b:stdgo.Slice&lt;stdgo.GoByte&gt;):Void</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_fmtbx"><code>function _fmtBx(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _b:stdgo.Slice&lt;stdgo.GoByte&gt;, _digits:stdgo.GoString):Void</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_fmtc"><code>function _fmtC(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _c:stdgo.GoUInt64):Void</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_fmtfloat"><code>function _fmtFloat(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _v:stdgo.GoFloat64, _size:stdgo.GoInt, _verb:stdgo.GoRune, _prec:stdgo.GoInt):Void</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_fmtinteger"><code>function _fmtInteger(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _u:stdgo.GoUInt64, _base:stdgo.GoInt, _isSigned:Bool, _verb:stdgo.GoRune, _digits:stdgo.GoString):Void</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_fmtq"><code>function _fmtQ(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _s:stdgo.GoString):Void</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_fmtqc"><code>function _fmtQc(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _c:stdgo.GoUInt64):Void</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_fmts"><code>function _fmtS(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _s:stdgo.GoString):Void</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_fmtsbx"><code>function _fmtSbx(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _s:stdgo.GoString, _b:stdgo.Slice&lt;stdgo.GoByte&gt;, _digits:stdgo.GoString):Void</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_fmtsx"><code>function _fmtSx(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _s:stdgo.GoString, _digits:stdgo.GoString):Void</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_fmtunicode"><code>function _fmtUnicode(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _u:stdgo.GoUInt64):Void</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_init"><code>function _init(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _buf:stdgo.Ref&lt;stdgo.fmt._Fmt.T_buffer&gt;):Void</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_pad"><code>function _pad(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _b:stdgo.Slice&lt;stdgo.GoByte&gt;):Void</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_padstring"><code>function _padString(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _s:stdgo.GoString):Void</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_truncate"><code>function _truncate(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _b:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_truncatestring"><code>function _truncateString(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _s:stdgo.GoString):stdgo.GoString</code></a></p></li><li>
<p><a href="#t_fmt_static_extension-function-_writepadding"><code>function _writePadding(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _n:stdgo.GoInt):Void</code></a></p></li><li>
<p><a href="#class-t_pp_static_extension">class T_pp_static_extension</a></p></li><li>
<p><a href="#t_pp_static_extension-function-_argnumber"><code>function _argNumber(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _argNum:stdgo.GoInt, _format:stdgo.GoString, _i:stdgo.GoInt, _numArgs:stdgo.GoInt):{_2:Bool, _1:stdgo.GoInt, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_badargnum"><code>function _badArgNum(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _verb:stdgo.GoRune):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_badverb"><code>function _badVerb(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _verb:stdgo.GoRune):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_catchpanic"><code>function _catchPanic(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _arg:stdgo.AnyInterface, _verb:stdgo.GoRune, _method:stdgo.GoString):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_doprint"><code>function _doPrint(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _a:stdgo.Slice&lt;stdgo.AnyInterface&gt;):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_doprintf"><code>function _doPrintf(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _format:stdgo.GoString, _a:stdgo.Slice&lt;stdgo.AnyInterface&gt;):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_doprintln"><code>function _doPrintln(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _a:stdgo.Slice&lt;stdgo.AnyInterface&gt;):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_fmt0x64"><code>function _fmt0x64(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _v:stdgo.GoUInt64, _leading0x:Bool):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_fmtbool"><code>function _fmtBool(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _v:Bool, _verb:stdgo.GoRune):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_fmtbytes"><code>function _fmtBytes(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _v:stdgo.Slice&lt;stdgo.GoByte&gt;, _verb:stdgo.GoRune, _typeString:stdgo.GoString):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_fmtcomplex"><code>function _fmtComplex(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _v:stdgo.GoComplex128, _size:stdgo.GoInt, _verb:stdgo.GoRune):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_fmtfloat"><code>function _fmtFloat(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _v:stdgo.GoFloat64, _size:stdgo.GoInt, _verb:stdgo.GoRune):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_fmtinteger"><code>function _fmtInteger(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _v:stdgo.GoUInt64, _isSigned:Bool, _verb:stdgo.GoRune):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_fmtpointer"><code>function _fmtPointer(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _value:stdgo.reflect.Value, _verb:stdgo.GoRune):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_fmtstring"><code>function _fmtString(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _v:stdgo.GoString, _verb:stdgo.GoRune):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_free"><code>function _free(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_handlemethods"><code>function _handleMethods(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _verb:stdgo.GoRune):Bool</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_missingarg"><code>function _missingArg(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _verb:stdgo.GoRune):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_printarg"><code>function _printArg(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _arg:stdgo.AnyInterface, _verb:stdgo.GoRune):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_printvalue"><code>function _printValue(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _value:stdgo.reflect.Value, _verb:stdgo.GoRune, _depth:stdgo.GoInt):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-_unknowntype"><code>function _unknownType(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _v:stdgo.reflect.Value):Void</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-flag"><code>function flag(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _b:stdgo.GoInt):Bool</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-precision"><code>function precision(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;):{_1:Bool, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-width"><code>function width(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;):{_1:Bool, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-write"><code>function write(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _b:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#t_pp_static_extension-function-writestring"><code>function writeString(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _s:stdgo.GoString):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#class-t_readrune_static_extension">class T_readRune_static_extension</a></p></li><li>
<p><a href="#t_readrune_static_extension-function-_readbyte"><code>function _readByte(_r:stdgo.Ref&lt;stdgo.fmt._Fmt.T_readRune&gt;):{_1:stdgo.Error, _0:stdgo.GoByte}</code></a></p></li><li>
<p><a href="#t_readrune_static_extension-function-readrune"><code>function readRune(_r:stdgo.Ref&lt;stdgo.fmt._Fmt.T_readRune&gt;):{_2:stdgo.Error, _1:stdgo.GoInt, _0:stdgo.GoRune}</code></a></p></li><li>
<p><a href="#t_readrune_static_extension-function-unreadrune"><code>function unreadRune(_r:stdgo.Ref&lt;stdgo.fmt._Fmt.T_readRune&gt;):stdgo.Error</code></a></p></li><li>
<p><a href="#class-t_ss_static_extension">class T_ss_static_extension</a></p></li><li>
<p><a href="#t_ss_static_extension-function-_accept"><code>function _accept(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _ok:stdgo.GoString):Bool</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_advance"><code>function _advance(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _format:stdgo.GoString):stdgo.GoInt</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_complextokens"><code>function _complexTokens(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):{_1:stdgo.GoString, _0:stdgo.GoString}</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_consume"><code>function _consume(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _ok:stdgo.GoString, _accept:Bool):Bool</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_convertfloat"><code>function _convertFloat(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _str:stdgo.GoString, _n:stdgo.GoInt):stdgo.GoFloat64</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_convertstring"><code>function _convertString(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _verb:stdgo.GoRune):stdgo.GoString</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_doscan"><code>function _doScan(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _a:stdgo.Slice&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_doscanf"><code>function _doScanf(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _format:stdgo.GoString, _a:stdgo.Slice&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_error"><code>function _error(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _err:stdgo.Error):Void</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_errorstring"><code>function _errorString(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _err:stdgo.GoString):Void</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_floattoken"><code>function _floatToken(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):stdgo.GoString</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_free"><code>function _free(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _old:stdgo.fmt._Fmt.T_ssave):Void</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_getbase"><code>function _getBase(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _verb:stdgo.GoRune):{_1:stdgo.GoString, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_getrune"><code>function _getRune(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):stdgo.GoRune</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_hexbyte"><code>function _hexByte(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):{_1:Bool, _0:stdgo.GoByte}</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_hexstring"><code>function _hexString(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):stdgo.GoString</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_mustreadrune"><code>function _mustReadRune(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):stdgo.GoRune</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_noteof"><code>function _notEOF(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):Void</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_okverb"><code>function _okVerb(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _verb:stdgo.GoRune, _okVerbs:stdgo.GoString, _typ:stdgo.GoString):Bool</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_peek"><code>function _peek(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _ok:stdgo.GoString):Bool</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_quotedstring"><code>function _quotedString(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):stdgo.GoString</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_scanbaseprefix"><code>function _scanBasePrefix(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):{_2:Bool, _1:stdgo.GoString, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_scanbool"><code>function _scanBool(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _verb:stdgo.GoRune):Bool</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_scancomplex"><code>function _scanComplex(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _verb:stdgo.GoRune, _n:stdgo.GoInt):stdgo.GoComplex128</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_scanint"><code>function _scanInt(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _verb:stdgo.GoRune, _bitSize:stdgo.GoInt):stdgo.GoInt64</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_scannumber"><code>function _scanNumber(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _digits:stdgo.GoString, _haveDigits:Bool):stdgo.GoString</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_scanone"><code>function _scanOne(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _verb:stdgo.GoRune, _arg:stdgo.AnyInterface):Void</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_scanpercent"><code>function _scanPercent(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):Void</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_scanrune"><code>function _scanRune(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _bitSize:stdgo.GoInt):stdgo.GoInt64</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_scanuint"><code>function _scanUint(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _verb:stdgo.GoRune, _bitSize:stdgo.GoInt):stdgo.GoUInt64</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-_token"><code>function _token(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _skipSpace:Bool, _f:()):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-read"><code>function read(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _buf:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-readrune"><code>function readRune(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):{_2:stdgo.Error, _1:stdgo.GoInt, _0:stdgo.GoRune}</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-skipspace"><code>function skipSpace(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):Void</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-token"><code>function token(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _skipSpace:Bool, _f:()):{_1:stdgo.Error, _0:stdgo.Slice&lt;stdgo.GoByte&gt;}</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-unreadrune"><code>function unreadRune(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):stdgo.Error</code></a></p></li><li>
<p><a href="#t_ss_static_extension-function-width"><code>function width(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):{_1:Bool, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#class-t_stringreader_static_extension">class T_stringReader_static_extension</a></p></li><li>
<p><a href="#t_stringreader_static_extension-function-read"><code>function read(____:stdgo.fmt._Fmt.T_stringReader, _r:stdgo.Pointer&lt;stdgo.fmt._Fmt.T_stringReader&gt;, _b:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#class-t_wraperror_static_extension">class T_wrapError_static_extension</a></p></li><li>
<p><a href="#t_wraperror_static_extension-function-error"><code>function error(_e:stdgo.Ref&lt;stdgo.fmt._Fmt.T_wrapError&gt;):stdgo.GoString</code></a></p></li><li>
<p><a href="#t_wraperror_static_extension-function-unwrap"><code>function unwrap(_e:stdgo.Ref&lt;stdgo.fmt._Fmt.T_wrapError&gt;):stdgo.Error</code></a></p></li><li>
<p><a href="#typedef-formatter">typedef Formatter</a></p></li><li>
<p><a href="#typedef-gostringer">typedef GoStringer</a></p></li><li>
<p><a href="#typedef-scanstate">typedef ScanState</a></p></li><li>
<p><a href="#typedef-scanner">typedef Scanner</a></p></li><li>
<p><a href="#typedef-state">typedef State</a></p></li><li>
<p><a href="#typedef-stringer">typedef Stringer</a></p></li></ul>
<h1><a name="examples">Examples</a></h1><ul><li>
<p><a href="#exampleerrorf"><code>exampleErrorf</code></a></p></li><li>
<p><a href="#examplefprint"><code>exampleFprint</code></a></p></li><li>
<p><a href="#examplefprintf"><code>exampleFprintf</code></a></p></li><li>
<p><a href="#examplefprintln"><code>exampleFprintln</code></a></p></li><li>
<p><a href="#examplefscanf"><code>exampleFscanf</code></a></p></li><li>
<p><a href="#examplefscanln"><code>exampleFscanln</code></a></p></li><li>
<p><a href="#examplegostringer"><code>exampleGoStringer</code></a></p></li><li>
<p><a href="#exampleprint"><code>examplePrint</code></a></p></li><li>
<p><a href="#exampleprintf"><code>examplePrintf</code></a></p></li><li>
<p><a href="#exampleprintln"><code>examplePrintln</code></a></p></li><li>
<p><a href="#examplesprint"><code>exampleSprint</code></a></p></li><li>
<p><a href="#examplesprintf"><code>exampleSprintf</code></a></p></li><li>
<p><a href="#examplesprintln"><code>exampleSprintln</code></a></p></li><li>
<p><a href="#examplesscanf"><code>exampleSscanf</code></a></p></li><li>
<p><a href="#examplestringer"><code>exampleStringer</code></a></p></li></ul>
<h1><a name="functions">Functions</a></h1>
<pre><code class="language-haxe">import stdgo.fmt.Fmt</code></pre>
<h2><a name="function-append">function append</a></h2>
<pre><code class="language-haxe">function append(_b:stdgo.Slice&lt;stdgo.GoByte&gt;, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>Append formats using the default formats for its operands, appends the result to  the byte slice, and returns the updated slice. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1139"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-appendf">function appendf</a></h2>
<pre><code class="language-haxe">function appendf(_b:stdgo.Slice&lt;stdgo.GoByte&gt;, _format:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>Appendf formats according to a format specifier, appends the result to the byte  slice, and returns the updated slice. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1083"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-appendln">function appendln</a></h2>
<pre><code class="language-haxe">function appendln(_b:stdgo.Slice&lt;stdgo.GoByte&gt;, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>Appendln formats using the default formats for its operands, appends the result  to the byte slice, and returns the updated slice. Spaces are always added  between operands and a newline is appended. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1196"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-errorf">function errorf</a></h2>
<pre><code class="language-haxe">function errorf(_format:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):stdgo.Error</code></pre>
<p>Errorf formats according to a format specifier and returns the string as a  value that satisfies error.    If the format specifier includes a %w verb with an error operand,  the returned error will implement an Unwrap method returning the operand. It is  invalid to include more than one %w verb or to supply it with an operand  that does not implement the error interface. The %w verb is otherwise  a synonym for %v. </p>
<h3><a name="exampleerrorf">exampleErrorf</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleErrorf():Void {
	{};
	var _err:Error = stdgo.fmt.Fmt.errorf(("user %q (id %d) not found" : GoString), Go.toInterface(("bueller" : GoString)), Go.toInterface((17 : GoInt)));
	stdgo.fmt.Fmt.println(Go.toInterface(_err.error()));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1011"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-fprint">function fprint</a></h2>
<pre><code class="language-haxe">function fprint(_w:stdgo.io.Writer, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Fprint formats using the default formats for its operands and writes to w.  Spaces are added between operands when neither is a string.  It returns the number of bytes written and any write error encountered. </p>
<h3><a name="examplefprint">exampleFprint</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleFprint():Void {
	{};
	var __tmp__ = stdgo.fmt.Fmt.fprint(Go.asInterface(stdgo.os.Os.stdout), Go.toInterface(("Kim" : GoString)), Go.toInterface((" is " : GoString)),
		Go.toInterface((22 : GoInt)), Go.toInterface((" years old.\n" : GoString))),
		_n:GoInt = __tmp__._0,
		_err:Error = __tmp__._1;
	if (_err != null) {
		stdgo.fmt.Fmt.fprintf(Go.asInterface(stdgo.os.Os.stderr), ("Fprint: %v\n" : GoString), Go.toInterface(_err));
	};
	stdgo.fmt.Fmt.print(Go.toInterface(_n), Go.toInterface((" bytes written.\n" : GoString)));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1097"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-fprintf">function fprintf</a></h2>
<pre><code class="language-haxe">function fprintf(_w:stdgo.io.Writer, _format:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Fprintf formats according to a format specifier and writes to w.  It returns the number of bytes written and any write error encountered. </p>
<h3><a name="examplefprintf">exampleFprintf</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleFprintf():Void {
	{};
	var __tmp__ = stdgo.fmt.Fmt.fprintf(Go.asInterface(stdgo.os.Os.stdout), ("%s is %d years old.\n" : GoString), Go.toInterface(("Kim" : GoString)),
		Go.toInterface((22 : GoInt))),
		_n:GoInt = __tmp__._0,
		_err:Error = __tmp__._1;
	if (_err != null) {
		stdgo.fmt.Fmt.fprintf(Go.asInterface(stdgo.os.Os.stderr), ("Fprintf: %v\n" : GoString), Go.toInterface(_err));
	};
	stdgo.fmt.Fmt.printf(("%d bytes written.\n" : GoString), Go.toInterface(_n));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1043"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-fprintln">function fprintln</a></h2>
<pre><code class="language-haxe">function fprintln(_w:stdgo.io.Writer, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Fprintln formats using the default formats for its operands and writes to w.  Spaces are always added between operands and a newline is appended.  It returns the number of bytes written and any write error encountered. </p>
<h3><a name="examplefprintln">exampleFprintln</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleFprintln():Void {
	{};
	var __tmp__ = stdgo.fmt.Fmt.fprintln(Go.asInterface(stdgo.os.Os.stdout), Go.toInterface(("Kim" : GoString)), Go.toInterface(("is" : GoString)),
		Go.toInterface((22 : GoInt)), Go.toInterface(("years old." : GoString))),
		_n:GoInt = __tmp__._0,
		_err:Error = __tmp__._1;
	if (_err != null) {
		stdgo.fmt.Fmt.fprintf(Go.asInterface(stdgo.os.Os.stderr), ("Fprintln: %v\n" : GoString), Go.toInterface(_err));
	};
	stdgo.fmt.Fmt.println(Go.toInterface(_n), Go.toInterface(("bytes written." : GoString)));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1153"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-fscan">function fscan</a></h2>
<pre><code class="language-haxe">function fscan(_r:stdgo.io.Reader, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Fscan scans text read from r, storing successive space-separated  values into successive arguments. Newlines count as space. It  returns the number of items successfully scanned. If that is less  than the number of arguments, err will report why. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1419"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-fscanf">function fscanf</a></h2>
<pre><code class="language-haxe">function fscanf(_r:stdgo.io.Reader, _format:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Fscanf scans text read from r, storing successive space-separated  values into successive arguments as determined by the format. It  returns the number of items successfully parsed.  Newlines in the input must match newlines in the format. </p>
<h3><a name="examplefscanf">exampleFscanf</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleFscanf():Void {
	var _0:GoInt = (0 : GoInt),
		_1:Bool = false,
		_2:GoString = ("" : GoString),
		_s:GoString = _2,
		_b:Bool = _1,
		_i:GoInt = _0;
	var _r = stdgo.strings.Strings.newReader(("5 true gophers" : GoString));
	var __tmp__ = stdgo.fmt.Fmt.fscanf(Go.asInterface(_r), ("%d %t %s" : GoString), Go.toInterface(Go.pointer(_i)), Go.toInterface(Go.pointer(_b)),
		Go.toInterface(Go.pointer(_s))),
		_n:GoInt = __tmp__._0,
		_err:Error = __tmp__._1;
	if (_err != null) {
		stdgo.fmt.Fmt.fprintf(Go.asInterface(stdgo.os.Os.stderr), ("Fscanf: %v\n" : GoString), Go.toInterface(_err));
	};
	stdgo.fmt.Fmt.println(Go.toInterface(_i), Go.toInterface(_b), Go.toInterface(_s));
	stdgo.fmt.Fmt.println(Go.toInterface(_n));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1459"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-fscanln">function fscanln</a></h2>
<pre><code class="language-haxe">function fscanln(_r:stdgo.io.Reader, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Fscanln is similar to Fscan, but stops scanning at a newline and  after the final item there must be a newline or EOF. </p>
<h3><a name="examplefscanln">exampleFscanln</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleFscanln():Void {
	var _s:GoString = ("dmr 1771 1.61803398875\n\tken 271828 3.14159" : GoString);
	var _r = stdgo.strings.Strings.newReader(_s);
	var _a:GoString = ("" : GoString);
	var _b:GoInt = (0 : GoInt);
	var _c:GoFloat64 = (0 : GoFloat64);
	while (true) {
		var __tmp__ = stdgo.fmt.Fmt.fscanln(Go.asInterface(_r), Go.toInterface(Go.pointer(_a)), Go.toInterface(Go.pointer(_b)),
			Go.toInterface(Go.pointer(_c))),
			_n:GoInt = __tmp__._0,
			_err:Error = __tmp__._1;
		if (Go.toInterface(_err) == (Go.toInterface(stdgo.io.Io.eof))) {
			break;
		};
		if (_err != null) {
			throw Go.toInterface(_err);
		};
		stdgo.fmt.Fmt.printf(("%d: %s, %d, %f\n" : GoString), Go.toInterface(_n), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(_c));
	};
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1438"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-isspace">function isSpace</a></h2>
<pre><code class="language-haxe">function isSpace()</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L425"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-parsenum">function parsenum</a></h2>
<pre><code class="language-haxe">function parsenum(:stdgo.GoString, :stdgo.GoInt, :stdgo.GoInt):{_2:stdgo.GoInt, _1:Bool, _0:stdgo.GoInt}</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L431"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-print">function print</a></h2>
<pre><code class="language-haxe">function print(_a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Print formats using the default formats for its operands and writes to standard output.  Spaces are added between operands when neither is a string.  It returns the number of bytes written and any write error encountered. </p>
<h3><a name="exampleprint">examplePrint</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function examplePrint():Void {
	{};
	stdgo.fmt.Fmt.print(Go.toInterface(("Kim" : GoString)), Go.toInterface((" is " : GoString)), Go.toInterface((22 : GoInt)),
		Go.toInterface((" years old.\n" : GoString)));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1116"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-printf">function printf</a></h2>
<pre><code class="language-haxe">function printf(_format:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Printf formats according to a format specifier and writes to standard output.  It returns the number of bytes written and any write error encountered. </p>
<h3><a name="exampleprintf">examplePrintf</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function examplePrintf():Void {
	{};
	stdgo.fmt.Fmt.printf(("%s is %d years old.\n" : GoString), Go.toInterface(("Kim" : GoString)), Go.toInterface((22 : GoInt)));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1061"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-println">function println</a></h2>
<pre><code class="language-haxe">function println(_a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Println formats using the default formats for its operands and writes to standard output.  Spaces are always added between operands and a newline is appended.  It returns the number of bytes written and any write error encountered. </p>
<h3><a name="exampleprintln">examplePrintln</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function examplePrintln():Void {
	{};
	stdgo.fmt.Fmt.println(Go.toInterface(("Kim" : GoString)), Go.toInterface(("is" : GoString)), Go.toInterface((22 : GoInt)),
		Go.toInterface(("years old." : GoString)));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1172"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-scan">function scan</a></h2>
<pre><code class="language-haxe">function scan(_a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Scan scans text read from standard input, storing successive  space-separated values into successive arguments. Newlines count  as space. It returns the number of items successfully scanned.  If that is less than the number of arguments, err will report why. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1342"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-scanf">function scanf</a></h2>
<pre><code class="language-haxe">function scanf(_format:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Scanf scans text read from standard input, storing successive  space-separated values into successive arguments as determined by  the format. It returns the number of items successfully scanned.  If that is less than the number of arguments, err will report why.  Newlines in the input must match newlines in the format.  The one exception: the verb %c always scans the next rune in the  input, even if it is a space (or tab etc.) or newline. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1367"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-scanln">function scanln</a></h2>
<pre><code class="language-haxe">function scanln(_a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Scanln is similar to Scan, but stops scanning at a newline and  after the final item there must be a newline or EOF. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1352"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-sprint">function sprint</a></h2>
<pre><code class="language-haxe">function sprint(_a:haxe.Rest&lt;stdgo.AnyInterface&gt;):stdgo.GoString</code></pre>
<p>Sprint formats using the default formats for its operands and returns the resulting string.  Spaces are added between operands when neither is a string. </p>
<h3><a name="examplesprint">exampleSprint</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleSprint():Void {
	{};
	var _s:GoString = stdgo.fmt.Fmt.sprint(Go.toInterface(("Kim" : GoString)), Go.toInterface((" is " : GoString)), Go.toInterface((22 : GoInt)),
		Go.toInterface((" years old.\n" : GoString)));
	stdgo.io.Io.writeString(Go.asInterface(stdgo.os.Os.stdout), _s);
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1126"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-sprintf">function sprintf</a></h2>
<pre><code class="language-haxe">function sprintf(_format:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):stdgo.GoString</code></pre>
<p>Sprintf formats according to a format specifier and returns the resulting string. </p>
<h3><a name="examplesprintf">exampleSprintf</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleSprintf():Void {
	{};
	var _s:GoString = stdgo.fmt.Fmt.sprintf(("%s is %d years old.\n" : GoString), Go.toInterface(("Kim" : GoString)), Go.toInterface((22 : GoInt)));
	stdgo.io.Io.writeString(Go.asInterface(stdgo.os.Os.stdout), _s);
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1070"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-sprintln">function sprintln</a></h2>
<pre><code class="language-haxe">function sprintln(_a:haxe.Rest&lt;stdgo.AnyInterface&gt;):stdgo.GoString</code></pre>
<p>Sprintln formats using the default formats for its operands and returns the resulting string.  Spaces are always added between operands and a newline is appended. </p>
<h3><a name="examplesprintln">exampleSprintln</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleSprintln():Void {
	{};
	var _s:GoString = stdgo.fmt.Fmt.sprintln(Go.toInterface(("Kim" : GoString)), Go.toInterface(("is" : GoString)), Go.toInterface((22 : GoInt)),
		Go.toInterface(("years old." : GoString)));
	stdgo.io.Io.writeString(Go.asInterface(stdgo.os.Os.stdout), _s);
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1182"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-sscan">function sscan</a></h2>
<pre><code class="language-haxe">function sscan(_str:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Sscan scans the argument string, storing successive space-separated  values into successive arguments. Newlines count as space. It  returns the number of items successfully scanned. If that is less  than the number of arguments, err will report why. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1379"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-sscanf">function sscanf</a></h2>
<pre><code class="language-haxe">function sscanf(_str:stdgo.GoString, _format:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Sscanf scans the argument string, storing successive space-separated  values into successive arguments as determined by the format. It  returns the number of items successfully parsed.  Newlines in the input must match newlines in the format. </p>
<h3><a name="examplesscanf">exampleSscanf</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleSscanf():Void {
	var _name:GoString = ("" : GoString);
	var _age:GoInt = (0 : GoInt);
	var __tmp__ = stdgo.fmt.Fmt.sscanf(("Kim is 22 years old" : GoString), ("%s is %d years old" : GoString), Go.toInterface(Go.pointer(_name)),
		Go.toInterface(Go.pointer(_age))),
		_n:GoInt = __tmp__._0,
		_err:Error = __tmp__._1;
	if (_err != null) {
		throw Go.toInterface(_err);
	};
	stdgo.fmt.Fmt.printf(("%d: %s, %d\n" : GoString), Go.toInterface(_n), Go.toInterface(_name), Go.toInterface(_age));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1405"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-sscanln">function sscanln</a></h2>
<pre><code class="language-haxe">function sscanln(_str:stdgo.GoString, _a:haxe.Rest&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Sscanln is similar to Sscan, but stops scanning at a newline and  after the final item there must be a newline or EOF. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1391"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h1><a name="classes">Classes</a></h1>
<pre><code class="language-haxe">import stdgo.fmt.*</code></pre>
<h2>class T_buffer_static_extension</h2>
<h3>T_buffer_static_extension function _write</h3>
<pre><code class="language-haxe">function _write(_b:stdgo.Ref&lt;stdgo.fmt._Fmt.T_buffer&gt;, _p:stdgo.Slice&lt;stdgo.GoByte&gt;):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L5253"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_buffer_static_extension function _writeByte</h3>
<pre><code class="language-haxe">function _writeByte(_b:stdgo.Ref&lt;stdgo.fmt._Fmt.T_buffer&gt;, _c:stdgo.GoByte):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L5243"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_buffer_static_extension function _writeRune</h3>
<pre><code class="language-haxe">function _writeRune(_bp:stdgo.Ref&lt;stdgo.fmt._Fmt.T_buffer&gt;, _r:stdgo.GoRune):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L5228"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_buffer_static_extension function _writeString</h3>
<pre><code class="language-haxe">function _writeString(_b:stdgo.Ref&lt;stdgo.fmt._Fmt.T_buffer&gt;, _s:stdgo.GoString):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L5248"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class T_fmt_static_extension</h2>
<h3>T_fmt_static_extension function _clearflags</h3>
<pre><code class="language-haxe">function _clearflags(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2325"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _fmtBoolean</h3>
<pre><code class="language-haxe">function _fmtBoolean(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _v:Bool):Void</code></pre>
<p>fmtBoolean formats a boolean. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2244"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _fmtBs</h3>
<pre><code class="language-haxe">function _fmtBs(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _b:stdgo.Slice&lt;stdgo.GoByte&gt;):Void</code></pre>
<p>fmtBs formats the byte slice b as if it was formatted as string with fmtS. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2025"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _fmtBx</h3>
<pre><code class="language-haxe">function _fmtBx(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _b:stdgo.Slice&lt;stdgo.GoByte&gt;, _digits:stdgo.GoString):Void</code></pre>
<p>fmtBx formats a byte slice as a hexadecimal encoding of its bytes. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1950"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _fmtC</h3>
<pre><code class="language-haxe">function _fmtC(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _c:stdgo.GoUInt64):Void</code></pre>
<p>fmtC formats an integer as a Unicode character.   If the character is not valid Unicode, it will print '\ufffd'. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1916"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _fmtFloat</h3>
<pre><code class="language-haxe">function _fmtFloat(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _v:stdgo.GoFloat64, _size:stdgo.GoInt, _verb:stdgo.GoRune, _prec:stdgo.GoInt):Void</code></pre>
<p>fmtFloat formats a float64. It assumes that verb is a valid format specifier   for strconv.AppendFloat and therefore fits into a byte. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1789"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _fmtInteger</h3>
<pre><code class="language-haxe">function _fmtInteger(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _u:stdgo.GoUInt64, _base:stdgo.GoInt, _isSigned:Bool, _verb:stdgo.GoRune, _digits:stdgo.GoString):Void</code></pre>
<p>fmtInteger formats signed and unsigned integers. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2088"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _fmtQ</h3>
<pre><code class="language-haxe">function _fmtQ(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _s:stdgo.GoString):Void</code></pre>
<p>fmtQ formats a string as a double-quoted, escaped Go string constant.   If f.sharp is set a raw (backquoted) string may be returned instead   if the string does not contain any control characters other than tab. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1932"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _fmtQc</h3>
<pre><code class="language-haxe">function _fmtQc(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _c:stdgo.GoUInt64):Void</code></pre>
<p>fmtQc formats an integer as a single-quoted, escaped Go character constant.   If the character is not valid Unicode, it will print '\ufffd'. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1898"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _fmtS</h3>
<pre><code class="language-haxe">function _fmtS(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _s:stdgo.GoString):Void</code></pre>
<p>fmtS formats a string. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2034"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _fmtSbx</h3>
<pre><code class="language-haxe">function _fmtSbx(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _s:stdgo.GoString, _b:stdgo.Slice&lt;stdgo.GoByte&gt;, _digits:stdgo.GoString):Void</code></pre>
<p>fmtSbx formats a string or byte slice as a hexadecimal encoding of its bytes. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1966"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _fmtSx</h3>
<pre><code class="language-haxe">function _fmtSx(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _s:stdgo.GoString, _digits:stdgo.GoString):Void</code></pre>
<p>fmtSx formats a string as a hexadecimal encoding of its bytes. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1958"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _fmtUnicode</h3>
<pre><code class="language-haxe">function _fmtUnicode(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _u:stdgo.GoUInt64):Void</code></pre>
<p>fmtUnicode formats a uint64 as "U+0078" or with f.sharp set as "U+0078 'x'". </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2195"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _init</h3>
<pre><code class="language-haxe">function _init(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _buf:stdgo.Ref&lt;stdgo.fmt._Fmt.T_buffer&gt;):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2319"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _pad</h3>
<pre><code class="language-haxe">function _pad(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _b:stdgo.Slice&lt;stdgo.GoByte&gt;):Void</code></pre>
<p>pad appends b to f.buf, padded on left (!f.minus) or right (f.minus). </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2275"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _padString</h3>
<pre><code class="language-haxe">function _padString(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _s:stdgo.GoString):Void</code></pre>
<p>padString appends s to f.buf, padded on left (!f.minus) or right (f.minus). </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2256"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _truncate</h3>
<pre><code class="language-haxe">function _truncate(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _b:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>truncate truncates the byte slice b as a string of the specified precision, if present. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2043"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _truncateString</h3>
<pre><code class="language-haxe">function _truncateString(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _s:stdgo.GoString):stdgo.GoString</code></pre>
<p>truncateString truncates the string s to the specified precision, if present. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2071"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_fmt_static_extension function _writePadding</h3>
<pre><code class="language-haxe">function _writePadding(_f:stdgo.Ref&lt;stdgo.fmt._Fmt.T_fmt&gt;, _n:stdgo.GoInt):Void</code></pre>
<p>writePadding generates n bytes of padding. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2294"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class T_pp_static_extension</h2>
<h3>T_pp_static_extension function _argNumber</h3>
<pre><code class="language-haxe">function _argNumber(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _argNum:stdgo.GoInt, _format:stdgo.GoString, _i:stdgo.GoInt, _numArgs:stdgo.GoInt):{_2:Bool, _1:stdgo.GoInt, _0:stdgo.GoInt}</code></pre>
<p>argNumber returns the next argument to evaluate, which is either the value of the passed-in   argNum or the value of the bracketed integer that begins format[i:]. It also returns   the new value of i, that is, the index of the next byte of the format to process. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2755"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _badArgNum</h3>
<pre><code class="language-haxe">function _badArgNum(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _verb:stdgo.GoRune):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2743"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _badVerb</h3>
<pre><code class="language-haxe">function _badVerb(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _verb:stdgo.GoRune):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3509"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _catchPanic</h3>
<pre><code class="language-haxe">function _catchPanic(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _arg:stdgo.AnyInterface, _verb:stdgo.GoRune, _method:stdgo.GoString):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3275"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _doPrint</h3>
<pre><code class="language-haxe">function _doPrint(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _a:stdgo.Slice&lt;stdgo.AnyInterface&gt;):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2506"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _doPrintf</h3>
<pre><code class="language-haxe">function _doPrintf(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _format:stdgo.GoString, _a:stdgo.Slice&lt;stdgo.AnyInterface&gt;):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2520"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _doPrintln</h3>
<pre><code class="language-haxe">function _doPrintln(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _a:stdgo.Slice&lt;stdgo.AnyInterface&gt;):Void</code></pre>
<p>doPrintln is like doPrint but always adds a space between arguments   and a newline after the last argument. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2495"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _fmt0x64</h3>
<pre><code class="language-haxe">function _fmt0x64(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _v:stdgo.GoUInt64, _leading0x:Bool):Void</code></pre>
<p>fmt0x64 formats a uint64 in hexadecimal and prefixes it with 0x or   not, as requested, by temporarily setting the sharp flag. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3492"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _fmtBool</h3>
<pre><code class="language-haxe">function _fmtBool(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _v:Bool, _verb:stdgo.GoRune):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3500"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _fmtBytes</h3>
<pre><code class="language-haxe">function _fmtBytes(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _v:stdgo.Slice&lt;stdgo.GoByte&gt;, _verb:stdgo.GoRune, _typeString:stdgo.GoString):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3352"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _fmtComplex</h3>
<pre><code class="language-haxe">function _fmtComplex(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _v:stdgo.GoComplex128, _size:stdgo.GoInt, _verb:stdgo.GoRune):Void</code></pre>
<p>fmtComplex formats a complex number v with   r = real(v) and j = imag(v) as (r+ji) using   fmtFloat for r and j formatting. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3419"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _fmtFloat</h3>
<pre><code class="language-haxe">function _fmtFloat(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _v:stdgo.GoFloat64, _size:stdgo.GoInt, _verb:stdgo.GoRune):Void</code></pre>
<p>fmtFloat formats a float. The default precision for each verb   is specified as last argument in the call to fmt_float. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3440"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _fmtInteger</h3>
<pre><code class="language-haxe">function _fmtInteger(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _v:stdgo.GoUInt64, _isSigned:Bool, _verb:stdgo.GoRune):Void</code></pre>
<p>fmtInteger formats a signed or unsigned integer. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3459"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _fmtPointer</h3>
<pre><code class="language-haxe">function _fmtPointer(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _value:stdgo.reflect.Value, _verb:stdgo.GoRune):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3310"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _fmtString</h3>
<pre><code class="language-haxe">function _fmtString(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _v:stdgo.GoString, _verb:stdgo.GoRune):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3393"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _free</h3>
<pre><code class="language-haxe">function _free(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;):Void</code></pre>
<p>free saves used pp structs in ppFree; avoids an allocation per invocation. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3594"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _handleMethods</h3>
<pre><code class="language-haxe">function _handleMethods(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _verb:stdgo.GoRune):Bool</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3132"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _missingArg</h3>
<pre><code class="language-haxe">function _missingArg(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _verb:stdgo.GoRune):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2736"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _printArg</h3>
<pre><code class="language-haxe">function _printArg(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _arg:stdgo.AnyInterface, _verb:stdgo.GoRune):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3032"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _printValue</h3>
<pre><code class="language-haxe">function _printValue(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _value:stdgo.reflect.Value, _verb:stdgo.GoRune, _depth:stdgo.GoInt):Void</code></pre>
<p>printValue is similar to printArg but starts with a reflect value, not an interface{} value.   It does not handle 'p' and 'T' verbs because these should have been already handled by printArg. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L2779"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function _unknownType</h3>
<pre><code class="language-haxe">function _unknownType(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _v:stdgo.reflect.Value):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3530"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function flag</h3>
<pre><code class="language-haxe">function flag(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _b:stdgo.GoInt):Bool</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3563"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function precision</h3>
<pre><code class="language-haxe">function precision(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;):{_1:Bool, _0:stdgo.GoInt}</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3579"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function width</h3>
<pre><code class="language-haxe">function width(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;):{_1:Bool, _0:stdgo.GoInt}</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3585"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function write</h3>
<pre><code class="language-haxe">function write(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _b:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Implement Write so we can call Fprintf on a pp (through State), for   recursive use in custom verbs. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3556"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_pp_static_extension function writeString</h3>
<pre><code class="language-haxe">function writeString(_p:stdgo.Ref&lt;stdgo.fmt._Fmt.T_pp&gt;, _s:stdgo.GoString):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Implement WriteString so that we can call io.WriteString   on a pp (through state), for efficiency. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3545"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class T_readRune_static_extension</h2>
<h3>T_readRune_static_extension function _readByte</h3>
<pre><code class="language-haxe">function _readByte(_r:stdgo.Ref&lt;stdgo.fmt._Fmt.T_readRune&gt;):{_1:stdgo.Error, _0:stdgo.GoByte}</code></pre>
<p>readByte returns the next byte from the input, which may be   left over from a previous read if the UTF-8 was ill-formed. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L5177"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_readRune_static_extension function readRune</h3>
<pre><code class="language-haxe">function readRune(_r:stdgo.Ref&lt;stdgo.fmt._Fmt.T_readRune&gt;):{_2:stdgo.Error, _1:stdgo.GoInt, _0:stdgo.GoRune}</code></pre>
<p>ReadRune returns the next UTF-8 encoded code point from the   io.Reader inside r. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L5117"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_readRune_static_extension function unreadRune</h3>
<pre><code class="language-haxe">function unreadRune(_r:stdgo.Ref&lt;stdgo.fmt._Fmt.T_readRune&gt;):stdgo.Error</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L5104"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class T_ss_static_extension</h2>
<h3>T_ss_static_extension function _accept</h3>
<pre><code class="language-haxe">function _accept(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _ok:stdgo.GoString):Bool</code></pre>
<p>accept checks the next rune in the input. If it's a byte (sic) in the string, it puts it in the   buffer and returns true. Otherwise it return false. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4781"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _advance</h3>
<pre><code class="language-haxe">function _advance(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _format:stdgo.GoString):stdgo.GoInt</code></pre>
<p>advance determines whether the next characters in the input match   those of the format. It returns the number of bytes (sic) consumed   in the format. All runs of space characters in either input or   format behave as a single space. Newlines are special, though:   newlines in the format must match those in the input and vice versa.   This routine also handles the %% case. If the return value is zero,   either format starts with a % (with no following %) or the input   is empty. If it is negative, the input did not match the string. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4004"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _complexTokens</h3>
<pre><code class="language-haxe">function _complexTokens(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):{_1:stdgo.GoString, _0:stdgo.GoString}</code></pre>
<p>complexTokens returns the real and imaginary parts of the complex number starting here.   The number might be parenthesized and has the format (N+Ni) where N is a floating-point   number and there are no spaces within. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4515"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _consume</h3>
<pre><code class="language-haxe">function _consume(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _ok:stdgo.GoString, _accept:Bool):Bool</code></pre>
<p>consume reads the next rune in the input and reports whether it is in the ok string.   If accept is true, it puts the character into the input token. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4813"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _convertFloat</h3>
<pre><code class="language-haxe">function _convertFloat(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _str:stdgo.GoString, _n:stdgo.GoInt):stdgo.GoFloat64</code></pre>
<p>convertFloat converts the string to a float64value. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4459"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _convertString</h3>
<pre><code class="language-haxe">function _convertString(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _verb:stdgo.GoRune):stdgo.GoString</code></pre>
<p>convertString returns the string represented by the next input characters.   The format of the input is determined by the verb. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4417"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _doScan</h3>
<pre><code class="language-haxe">function _doScan(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _a:stdgo.Slice&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>doScan does the real work for scanning without a format string. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4084"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _doScanf</h3>
<pre><code class="language-haxe">function _doScanf(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _format:stdgo.GoString, _a:stdgo.Slice&lt;stdgo.AnyInterface&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>doScanf does the real work when scanning with a format string.   At the moment, it handles only pointers to basic types. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L3898"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _error</h3>
<pre><code class="language-haxe">function _error(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _err:stdgo.Error):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4973"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _errorString</h3>
<pre><code class="language-haxe">function _errorString(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _err:stdgo.GoString):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4968"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _floatToken</h3>
<pre><code class="language-haxe">function _floatToken(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):stdgo.GoString</code></pre>
<p>floatToken returns the floating-point number starting here, no longer than swid   if the width is specified. It's not rigorous about syntax because it doesn't check that   we have at least some digits, but Atof will do that. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4540"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _free</h3>
<pre><code class="language-haxe">function _free(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _old:stdgo.fmt._Fmt.T_ssave):Void</code></pre>
<p>free saves used ss structs in ssFree; avoid an allocation per invocation. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4887"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _getBase</h3>
<pre><code class="language-haxe">function _getBase(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _verb:stdgo.GoRune):{_1:stdgo.GoString, _0:stdgo.GoInt}</code></pre>
<p>getBase returns the numeric base represented by the verb and its digit string. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4715"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _getRune</h3>
<pre><code class="language-haxe">function _getRune(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):stdgo.GoRune</code></pre>
<p>The public method returns an error; this private one panics.   If getRune reaches EOF, the return value is EOF (-1). </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L5005"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _hexByte</h3>
<pre><code class="language-haxe">function _hexByte(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):{_1:Bool, _0:stdgo.GoByte}</code></pre>
<p>hexByte returns the next hex-encoded (two-character) byte from the input.   It returns ok==false if the next bytes in the input do not encode a hex byte.   If the first byte is hex and the second is not, processing stops. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4341"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _hexString</h3>
<pre><code class="language-haxe">function _hexString(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):stdgo.GoString</code></pre>
<p>hexString returns the space-delimited hexpair-encoded string. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4317"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _mustReadRune</h3>
<pre><code class="language-haxe">function _mustReadRune(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):stdgo.GoRune</code></pre>
<p>mustReadRune turns io.EOF into a panic(io.ErrUnexpectedEOF).   It is called in cases such as string scanning where an EOF is a   syntax error. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4991"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _notEOF</h3>
<pre><code class="language-haxe">function _notEOF(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4786"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _okVerb</h3>
<pre><code class="language-haxe">function _okVerb(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _verb:stdgo.GoRune, _okVerbs:stdgo.GoString, _typ:stdgo.GoString):Bool</code></pre>
<p>okVerb verifies that the verb is present in the list, setting s.err appropriately if not. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4766"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _peek</h3>
<pre><code class="language-haxe">function _peek(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _ok:stdgo.GoString):Bool</code></pre>
<p>peek reports whether the next character is in the ok string, without consuming it. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4800"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _quotedString</h3>
<pre><code class="language-haxe">function _quotedString(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):stdgo.GoString</code></pre>
<p>quotedString returns the double- or back-quoted string represented by the next input characters. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4368"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _scanBasePrefix</h3>
<pre><code class="language-haxe">function _scanBasePrefix(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):{_2:Bool, _1:stdgo.GoString, _0:stdgo.GoInt}</code></pre>
<p>scanBasePrefix reports whether the integer begins with a base prefix   and returns the base, digit string, and whether a zero was found.   It is called only if the verb is %v. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4659"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _scanBool</h3>
<pre><code class="language-haxe">function _scanBool(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _verb:stdgo.GoRune):Bool</code></pre>
<p>scanBool returns the value of the boolean represented by the next token. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4737"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _scanComplex</h3>
<pre><code class="language-haxe">function _scanComplex(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _verb:stdgo.GoRune, _n:stdgo.GoInt):stdgo.GoComplex128</code></pre>
<p>convertComplex converts the next token to a complex128 value.   The atof argument is a type-specific reader for the underlying type.   If we're reading complex64, atof will parse float32s and convert them   to float64's to avoid reproducing this code for each complex type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4441"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _scanInt</h3>
<pre><code class="language-haxe">function _scanInt(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _verb:stdgo.GoRune, _bitSize:stdgo.GoInt):stdgo.GoInt64</code></pre>
<p>scanInt returns the value of the integer represented by the next   token, checking for overflow. Any error is stored in s.err. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4613"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _scanNumber</h3>
<pre><code class="language-haxe">function _scanNumber(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _digits:stdgo.GoString, _haveDigits:Bool):stdgo.GoString</code></pre>
<p>scanNumber returns the numerical string with specified digits starting here. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4700"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _scanOne</h3>
<pre><code class="language-haxe">function _scanOne(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _verb:stdgo.GoRune, _arg:stdgo.AnyInterface):Void</code></pre>
<p>scanOne scans a single value, deriving the scanner from the type of the argument. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4142"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _scanPercent</h3>
<pre><code class="language-haxe">function _scanPercent(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):Void</code></pre>
<p>scanPercent scans a literal percent character. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4305"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _scanRune</h3>
<pre><code class="language-haxe">function _scanRune(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _bitSize:stdgo.GoInt):stdgo.GoInt64</code></pre>
<p>scanRune returns the next rune value in the input. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4685"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _scanUint</h3>
<pre><code class="language-haxe">function _scanUint(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _verb:stdgo.GoRune, _bitSize:stdgo.GoInt):stdgo.GoUInt64</code></pre>
<p>scanUint returns the value of the unsigned integer represented   by the next token, checking for overflow. Any error is stored in s.err. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4571"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function _token</h3>
<pre><code class="language-haxe">function _token(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _skipSpace:Bool, _f:()):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>token returns the next space-delimited string from the input. It   skips white space. For Scanln, it stops at newlines. For Scan,   newlines are treated as spaces. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4836"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function read</h3>
<pre><code class="language-haxe">function read(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _buf:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>The Read method is only in ScanState so that ScanState   satisfies io.Reader. It will never be called when used as   intended, so there is no need to make it actually work. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L5061"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function readRune</h3>
<pre><code class="language-haxe">function readRune(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):{_2:stdgo.Error, _1:stdgo.GoInt, _0:stdgo.GoRune}</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L5030"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function skipSpace</h3>
<pre><code class="language-haxe">function skipSpace(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):Void</code></pre>
<p>SkipSpace provides Scan methods the ability to skip space and newline   characters in keeping with the current scanning mode set by format strings   and Scan/Scanln. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4860"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function token</h3>
<pre><code class="language-haxe">function token(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;, _skipSpace:Bool, _f:()):{_1:stdgo.Error, _0:stdgo.Slice&lt;stdgo.GoByte&gt;}</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4901"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function unreadRune</h3>
<pre><code class="language-haxe">function unreadRune(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):stdgo.Error</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L4978"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_ss_static_extension function width</h3>
<pre><code class="language-haxe">function width(_s:stdgo.Ref&lt;stdgo.fmt._Fmt.T_ss&gt;):{_1:Bool, _0:stdgo.GoInt}</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L5021"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class T_stringReader_static_extension</h2>
<h3>T_stringReader_static_extension function read</h3>
<pre><code class="language-haxe">function read(____:stdgo.fmt._Fmt.T_stringReader, _r:stdgo.Pointer&lt;stdgo.fmt._Fmt.T_stringReader&gt;, _b:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L5281"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class T_wrapError_static_extension</h2>
<h3>T_wrapError_static_extension function error</h3>
<pre><code class="language-haxe">function error(_e:stdgo.Ref&lt;stdgo.fmt._Fmt.T_wrapError&gt;):stdgo.GoString</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1631"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>T_wrapError_static_extension function unwrap</h3>
<pre><code class="language-haxe">function unwrap(_e:stdgo.Ref&lt;stdgo.fmt._Fmt.T_wrapError&gt;):stdgo.Error</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/fmt//Fmt.hx#L1626"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h1><a name="typedefs">Typedefs</a></h1>
<pre><code class="language-haxe">import stdgo.fmt.*</code></pre>
<h2><a name="typedef-formatter">typedef Formatter</a></h2>
<pre><code class="language-haxe">typedef Formatter = var a:{&lt;__underlying__&gt; | (_f:stdgo.fmt.State, _verb:stdgo.GoRune):Void | ():stdgo.AnyInterface}</code></pre>
<p>Formatter is implemented by any value that has a Format method.  The implementation controls how State and rune are interpreted,  and may call Sprint(f) or Fprint(f) etc. to generate its output. </p>
<h2><a name="typedef-gostringer">typedef GoStringer</a></h2>
<pre><code class="language-haxe">typedef GoStringer = var a:{&lt;__underlying__&gt; | ():stdgo.GoString | ():stdgo.AnyInterface}</code></pre>
<p>GoStringer is implemented by any value that has a GoString method,  which defines the Go syntax for that value.  The GoString method is used to print values passed as an operand  to a %#v format. </p>
<h3><a name="examplegostringer">exampleGoStringer</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleGoStringer():Void {
	var _p1:stdgo.fmt_test.Fmt_test.Person = ({name: ("Warren" : GoString), age: ("31" : GoUInt), addr: (({city: ("Denver" : GoString),
		state: ("CO" : GoString), country: ("U.S.A." : GoString)} : Address) : Ref&lt;stdgo.fmt_test.Fmt_test.Address&gt;)} : Person);
	stdgo.fmt.Fmt.printf(("%#v\n" : GoString), Go.toInterface(Go.asInterface(_p1)));
	var _p2:stdgo.fmt_test.Fmt_test.Person = ({name: ("Theia" : GoString), age: ("4" : GoUInt)} : Person);
	stdgo.fmt.Fmt.printf(("%#v\n" : GoString), Go.toInterface(Go.asInterface(_p2)));
}</code></pre>
<p></p>
</details></p>
<h2><a name="typedef-scanstate">typedef ScanState</a></h2>
<pre><code class="language-haxe">typedef ScanState = var a:{&lt;__underlying__&gt; | ():{_1:Bool, _0:stdgo.GoInt} | {&lt;haxe_doc&gt;} | ():stdgo.Error | {&lt;haxe_doc&gt;} | (_skipSpace:Bool, _f:()):{_1:stdgo.Error, _0:stdgo.Slice&lt;stdgo.GoByte&gt;} | {&lt;haxe_doc&gt;} | ():Void | {&lt;haxe_doc&gt;} | ():{_2:stdgo.Error, _1:stdgo.GoInt, _0:stdgo.GoRune} | {&lt;haxe_doc&gt;} | (_buf:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt} | {&lt;haxe_doc&gt;} | ():stdgo.AnyInterface}</code></pre>
<p>ScanState represents the scanner state passed to custom scanners.  Scanners may do rune-at-a-time scanning or ask the ScanState  to discover the next space-delimited token. </p>
<h2><a name="typedef-scanner">typedef Scanner</a></h2>
<pre><code class="language-haxe">typedef Scanner = var a:{&lt;__underlying__&gt; | (_state:stdgo.fmt.ScanState, _verb:stdgo.GoRune):stdgo.Error | ():stdgo.AnyInterface}</code></pre>
<p>Scanner is implemented by any value that has a Scan method, which scans  the input for the representation of a value and stores the result in the  receiver, which must be a pointer to be useful. The Scan method is called  for any argument to Scan, Scanf, or Scanln that implements it. </p>
<h2><a name="typedef-state">typedef State</a></h2>
<pre><code class="language-haxe">typedef State = var a:{&lt;__underlying__&gt; | (_b:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt} | {&lt;haxe_doc&gt;} | ():{_1:Bool, _0:stdgo.GoInt} | {&lt;haxe_doc&gt;} | ():{_1:Bool, _0:stdgo.GoInt} | {&lt;haxe_doc&gt;} | (_c:stdgo.GoInt):Bool | {&lt;haxe_doc&gt;} | ():stdgo.AnyInterface}</code></pre>
<p>State represents the printer state passed to custom formatters.  It provides access to the io.Writer interface plus information about  the flags and options for the operand's format specifier. </p>
<h2><a name="typedef-stringer">typedef Stringer</a></h2>
<pre><code class="language-haxe">typedef Stringer = var a:{&lt;__underlying__&gt; | ():stdgo.GoString | ():stdgo.AnyInterface}</code></pre>
<p>Stringer is implemented by any value that has a String method,  which defines the native format for that value.  The String method is used to print values passed as an operand  to any format that accepts a string or to an unformatted printer  such as Print. </p>
<h3><a name="examplestringer">exampleStringer</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleStringer():Void {
	var _a:stdgo.fmt_test.Fmt_test.Animal = ({name: ("Gopher" : GoString), age: ("2" : GoUInt)} : Animal);
	stdgo.fmt.Fmt.println(Go.toInterface(Go.asInterface(_a)));
}</code></pre>
<p></p>
</details></p>
    </article>
</body>
</html>