<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>go2hx stdgo</title>
    <link rel="shortcut icon" href="logo.svg">
    <meta property="og:title" content="go2hx stdgo"/>
    <meta property="og:type" content="Website"/>
    <meta property="og:url" content="https://go2hx.github.io"/>
    <meta property="og:description" content="go2hx is a Go to Haxe compiler"/>
    <meta property="og:image" content="logo.png"/>
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:width" content="512">
    <meta property="og:image:height" content="512">
    <meta property="og:image:alt" content="go2hx logo">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="go2hx">
    <meta name="twitter:description" content="go2hx, The Go to Haxe compiler">
    <meta name="twitter:image" content="logo.png">
    <meta name="twitter:image:alt" content="go2hx logo">
    <link href="../../prism.css" rel="stylesheet" />
    <link rel="stylesheet" href="../../style.css" />
		<style>
			body {
				box-sizing: border-box;
				min-width: 200px;
				max-width: 980px;
				margin: 0 auto;
				padding: 45px;
			}
			@media (prefers-color-scheme: dark) {
				body {
					background-color: #0d1117;
				}
			}
		</style>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css">
		<style>
			.github-fork-ribbon:before {
				background-color: #121612;
			}
		</style>
</head>
<body>
    <a class="markdown-body"><div class="header">
    <table>
            <thead>
            <th><h2><a href="https://go2hx.github.io/"><font color="#357b99">go</font><font color="#cad0d8">2</font><font color="#e2ac3f">hx</font></a></h2></th>
            <th><h2><a href="https://go2hx.github.io/manual">manual</a></h2></th>
            <th><h2><a href="https://github.com/go2hx/go2hx">github</a></h2></th>
        </thead>
    </table>
</div></a>
    <script src="../../prism.js"></script>
    <article class="markdown-body">
        <h1>Module: <code>stdgo.bytes</code></h1>
<p><a href="../index.html">(view library index)</a></p>
<h1><a name="overview">Overview</a></h1>
<p>Package bytes implements functions for the manipulation of byte slices.  It is analogous to the facilities of the strings package. </p><details><summary>hl tests passed</summary>
<p>
<pre><code>=== RUN  TestNewBuffer
--- PASS: TestNewBuffer (%!s(float64=0.0007779598236083984))

=== RUN  TestNewBufferString
--- PASS: TestNewBufferString (%!s(float64=0.0016109943389892578))

=== RUN  TestBasicOperations
--- PASS: TestBasicOperations (%!s(float64=0.0003170967102050781))

=== RUN  TestLargeStringWrites
--- PASS: TestLargeStringWrites (%!s(float64=0.18320202827453613))

=== RUN  TestLargeByteWrites
--- PASS: TestLargeByteWrites (%!s(float64=0.20020699501037598))

=== RUN  TestLargeStringReads
--- PASS: TestLargeStringReads (%!s(float64=0.05422091484069824))

=== RUN  TestLargeByteReads
--- PASS: TestLargeByteReads (%!s(float64=0.0760200023651123))

=== RUN  TestMixedReadsAndWrites
--- PASS: TestMixedReadsAndWrites (%!s(float64=0.38822102546691895))

=== RUN  TestCapWithPreallocatedSlice
--- PASS: TestCapWithPreallocatedSlice (%!s(float64=1.811981201171875e-05))

=== RUN  TestCapWithSliceAndWrittenData
--- PASS: TestCapWithSliceAndWrittenData (%!s(float64=6.9141387939453125e-06))

=== RUN  TestNil
--- PASS: TestNil (%!s(float64=5.0067901611328125e-06))

=== RUN  TestReadFrom
--- PASS: TestReadFrom (%!s(float64=0.12381911277770996))

=== RUN  TestReadFromPanicReader
--- PASS: TestReadFromPanicReader (%!s(float64=0.0003039836883544922))

=== RUN  TestReadFromNegativeReader
--- PASS: TestReadFromNegativeReader (%!s(float64=0.0002498626708984375))

=== RUN  TestWriteTo
--- PASS: TestWriteTo (%!s(float64=0.1072089672088623))

=== RUN  TestRuneIO
--- PASS: TestRuneIO (%!s(float64=0.018937110900878906))

=== RUN  TestWriteInvalidRune
--- PASS: TestWriteInvalidRune (%!s(float64=0.0002980232238769531))

=== RUN  TestNext
--- PASS: TestNext (%!s(float64=0.00037407875061035156))

=== RUN  TestReadBytes
--- PASS: TestReadBytes (%!s(float64=7.987022399902344e-05))

=== RUN  TestReadString
--- PASS: TestReadString (%!s(float64=5.0067901611328125e-05))

=== RUN  TestGrow
bytes_test/Bytes_test.hx:2199: testGrow skip function
--- PASS: TestGrow (%!s(float64=7.319450378417969e-05))

=== RUN  TestGrowOverflow
--- PASS: TestGrowOverflow (%!s(float64=3.695487976074219e-05))

=== RUN  TestReadEmptyAtEOF
--- PASS: TestReadEmptyAtEOF (%!s(float64=5.0067901611328125e-06))

=== RUN  TestUnreadByte
--- PASS: TestUnreadByte (%!s(float64=1.7881393432617188e-05))

=== RUN  TestBufferGrowth
--- PASS: TestBufferGrowth (%!s(float64=1.6360740661621094))

=== RUN  TestEqual
--- PASS: TestEqual (%!s(float64=1.1920928955078125e-05))

=== RUN  TestEqualExhaustive
--- PASS: TestEqualExhaustive (%!s(float64=0.13262104988098145))

=== RUN  TestNotEqual
--- PASS: TestNotEqual (%!s(float64=0.4165501594543457))

=== RUN  TestIndex
--- PASS: TestIndex (%!s(float64=0.0013048648834228516))

=== RUN  TestLastIndex
--- PASS: TestLastIndex (%!s(float64=7.319450378417969e-05))

=== RUN  TestIndexAny
--- PASS: TestIndexAny (%!s(float64=0.00015807151794433594))

=== RUN  TestLastIndexAny
--- PASS: TestLastIndexAny (%!s(float64=0.00017499923706054688))

=== RUN  TestIndexByte
--- PASS: TestIndexByte (%!s(float64=3.409385681152344e-05))

=== RUN  TestLastIndexByte
--- PASS: TestLastIndexByte (%!s(float64=2.193450927734375e-05))

=== RUN  TestIndexByteBig
--- PASS: TestIndexByteBig (%!s(float64=0.07149410247802734))

=== RUN  TestIndexByteSmall
--- PASS: TestIndexByteSmall (%!s(float64=0.14675498008728027))

=== RUN  TestIndexRune
--- PASS: TestIndexRune (%!s(float64=0.0001621246337890625))

=== RUN  TestCountByte
--- PASS: TestCountByte (%!s(float64=2.355727195739746))

=== RUN  TestCountByteNoMatch
--- PASS: TestCountByteNoMatch (%!s(float64=0.8615601062774658))

=== RUN  TestSplit
--- PASS: TestSplit (%!s(float64=0.0014200210571289062))

=== RUN  TestSplitAfter
--- PASS: TestSplitAfter (%!s(float64=0.0015339851379394531))

=== RUN  TestFields
--- PASS: TestFields (%!s(float64=0.0001800060272216797))

=== RUN  TestFieldsFunc
--- PASS: TestFieldsFunc (%!s(float64=0.00018596649169921875))

=== RUN  TestMap
--- PASS: TestMap (%!s(float64=0.00025582313537597656))

=== RUN  TestToUpper
--- PASS: TestToUpper (%!s(float64=0.00030803680419921875))

=== RUN  TestToLower
--- PASS: TestToLower (%!s(float64=0.00025200843811035156))

=== RUN  TestToValidUTF8
--- PASS: TestToValidUTF8 (%!s(float64=0.00023293495178222656))

=== RUN  TestTrimSpace
--- PASS: TestTrimSpace (%!s(float64=0.0001900196075439453))

=== RUN  TestRepeat
--- PASS: TestRepeat (%!s(float64=2.8848648071289062e-05))

=== RUN  TestRepeatCatchesOverflow
--- PASS: TestRepeatCatchesOverflow (%!s(float64=0.0007719993591308594))

=== RUN  TestRunes
--- PASS: TestRunes (%!s(float64=0.00010609626770019531))

=== RUN  TestTrim
--- PASS: TestTrim (%!s(float64=0.0003178119659423828))

=== RUN  TestTrimFunc
--- PASS: TestTrimFunc (%!s(float64=0.00045299530029296875))

=== RUN  TestIndexFunc
--- PASS: TestIndexFunc (%!s(float64=0.00023698806762695312))

=== RUN  TestReplace
--- PASS: TestReplace (%!s(float64=0.0005249977111816406))

=== RUN  TestTitle
--- PASS: TestTitle (%!s(float64=0.00016999244689941406))

=== RUN  TestToTitle
--- PASS: TestToTitle (%!s(float64=0.00011086463928222656))

=== RUN  TestEqualFold
--- PASS: TestEqualFold (%!s(float64=0.00032806396484375))

=== RUN  TestCut
--- PASS: TestCut (%!s(float64=2.5033950805664062e-05))

=== RUN  TestBufferGrowNegative
--- PASS: TestBufferGrowNegative (%!s(float64=2.384185791015625e-05))

=== RUN  TestBufferTruncateNegative
--- PASS: TestBufferTruncateNegative (%!s(float64=1.5020370483398438e-05))

=== RUN  TestBufferTruncateOutOfRange
--- PASS: TestBufferTruncateOutOfRange (%!s(float64=2.002716064453125e-05))

=== RUN  TestContains
--- PASS: TestContains (%!s(float64=1.2159347534179688e-05))

=== RUN  TestContainsAny
--- PASS: TestContainsAny (%!s(float64=7.104873657226562e-05))

=== RUN  TestContainsRune
--- PASS: TestContainsRune (%!s(float64=2.09808349609375e-05))

=== RUN  TestCompare
--- PASS: TestCompare (%!s(float64=0.0007791519165039062))

=== RUN  TestCompareIdenticalSlice
--- PASS: TestCompareIdenticalSlice (%!s(float64=1.0013580322265625e-05))

=== RUN  TestCompareBytes
bytes_test/Bytes_test.hx:4449: testCompareBytes skip function
--- PASS: TestCompareBytes (%!s(float64=1.5020370483398438e-05))

=== RUN  TestEndianBaseCompare
--- PASS: TestEndianBaseCompare (%!s(float64=0.12215089797973633))

=== RUN  TestReader
--- PASS: TestReader (%!s(float64=0.00011420249938964844))

=== RUN  TestReadAfterBigSeek
--- PASS: TestReadAfterBigSeek (%!s(float64=2.002716064453125e-05))

=== RUN  TestReaderAt
--- PASS: TestReaderAt (%!s(float64=0.0018310546875))

=== RUN  TestReaderAtConcurrent
--- PASS: TestReaderAtConcurrent (%!s(float64=0.0008959770202636719))

=== RUN  TestEmptyReaderConcurrent
--- PASS: TestEmptyReaderConcurrent (%!s(float64=0.00023102760314941406))

=== RUN  TestReaderWriteTo
--- PASS: TestReaderWriteTo (%!s(float64=0.004093170166015625))

=== RUN  TestReaderLen
--- PASS: TestReaderLen (%!s(float64=1.71661376953125e-05))

=== RUN  TestUnreadRuneError
--- PASS: TestUnreadRuneError (%!s(float64=5.1975250244140625e-05))

=== RUN  TestReaderDoubleUnreadRune
--- PASS: TestReaderDoubleUnreadRune (%!s(float64=6.9141387939453125e-06))

=== RUN  TestReaderCopyNothing
--- PASS: TestReaderCopyNothing (%!s(float64=0.0037789344787597656))

=== RUN  TestReaderLenSize
bytes_test/Bytes_test.hx:5588: testReaderLenSize skip function
--- PASS: TestReaderLenSize (%!s(float64=6.508827209472656e-05))

=== RUN  TestReaderReset
--- PASS: TestReaderReset (%!s(float64=4.7206878662109375e-05))

=== RUN  TestReaderZero
--- PASS: TestReaderZero (%!s(float64=4.291534423828125e-05))
</code></pre>
<p></p>
</details></p><details><summary>interp tests failed</summary>
<p>
<pre><code>stdgo/reflect/Reflect.hx:2977: characters 28-35 : Warning : Potential typo detected (expected similar values are refType). Consider using `var keyType` instead
Invalid_argument("index out of bounds")
stdgo/internal/Macro.macro.hx:35: define
=== RUN  TestNewBuffer
--- PASS: TestNewBuffer (%!s(float64=0.010129928588867188))

=== RUN  TestNewBufferString
--- PASS: TestNewBufferString (%!s(float64=0.015202999114990234))

=== RUN  TestBasicOperations
--- PASS: TestBasicOperations (%!s(float64=0.0016951560974121094))

=== RUN  TestLargeStringWrites
--- PASS: TestLargeStringWrites (%!s(float64=1.752568006515503))

=== RUN  TestLargeByteWrites
--- PASS: TestLargeByteWrites (%!s(float64=1.870621919631958))

=== RUN  TestLargeStringReads
--- PASS: TestLargeStringReads (%!s(float64=0.4180018901824951))

=== RUN  TestLargeByteReads
--- PASS: TestLargeByteReads (%!s(float64=0.351193904876709))

=== RUN  TestMixedReadsAndWrites
--- PASS: TestMixedReadsAndWrites (%!s(float64=3.03971791267395))

=== RUN  TestCapWithPreallocatedSlice
--- PASS: TestCapWithPreallocatedSlice (%!s(float64=1.6927719116210938e-05))

=== RUN  TestCapWithSliceAndWrittenData
--- PASS: TestCapWithSliceAndWrittenData (%!s(float64=3.314018249511719e-05))

=== RUN  TestNil
--- PASS: TestNil (%!s(float64=1.2874603271484375e-05))

=== RUN  TestReadFrom
--- PASS: TestReadFrom (%!s(float64=0.5050539970397949))

=== RUN  TestReadFromPanicReader
--- PASS: TestReadFromPanicReader (%!s(float64=0.001600027084350586))

=== RUN  TestReadFromNegativeReader
--- PASS: TestReadFromNegativeReader (%!s(float64=0.0004589557647705078))

=== RUN  TestWriteTo
--- PASS: TestWriteTo (%!s(float64=0.3923170566558838))

=== RUN  TestRuneIO
--- PASS: TestRuneIO (%!s(float64=0.11020994186401367))

=== RUN  TestWriteInvalidRune
--- PASS: TestWriteInvalidRune (%!s(float64=0.0011267662048339844))

=== RUN  TestNext
--- PASS: TestNext (%!s(float64=0.0013859272003173828))

=== RUN  TestReadBytes
--- PASS: TestReadBytes (%!s(float64=0.0003199577331542969))

=== RUN  TestReadString
--- PASS: TestReadString (%!s(float64=0.0002498626708984375))

=== RUN  TestGrow
bytes_test/Bytes_test.hx:2199: testGrow skip function
--- PASS: TestGrow (%!s(float64=1.5974044799804688e-05))

=== RUN  TestGrowOverflow
--- PASS: TestGrowOverflow (%!s(float64=6.699562072753906e-05))

=== RUN  TestReadEmptyAtEOF
--- PASS: TestReadEmptyAtEOF (%!s(float64=1.2874603271484375e-05))

=== RUN  TestUnreadByte
--- PASS: TestUnreadByte (%!s(float64=7.200241088867188e-05))

=== RUN  TestBufferGrowth
--- PASS: TestBufferGrowth (%!s(float64=6.586874961853027))

=== RUN  TestEqual
--- PASS: TestEqual (%!s(float64=1.0967254638671875e-05))

=== RUN  TestEqualExhaustive
--- PASS: TestEqualExhaustive (%!s(float64=0.6220171451568604))

=== RUN  TestNotEqual
--- PASS: TestNotEqual (%!s(float64=2.9968321323394775))

=== RUN  TestIndex
--- PASS: TestIndex (%!s(float64=0.009174823760986328))

=== RUN  TestLastIndex
--- PASS: TestLastIndex (%!s(float64=0.0003681182861328125))

=== RUN  TestIndexAny
--- PASS: TestIndexAny (%!s(float64=0.0009860992431640625))

=== RUN  TestLastIndexAny
--- PASS: TestLastIndexAny (%!s(float64=0.0011570453643798828))

=== RUN  TestIndexByte
--- PASS: TestIndexByte (%!s(float64=0.00021004676818847656))

=== RUN  TestLastIndexByte
--- PASS: TestLastIndexByte (%!s(float64=7.891654968261719e-05))

=== RUN  TestIndexByteBig
--- PASS: TestIndexByteBig (%!s(float64=1.05228590965271))

=== RUN  TestIndexByteSmall
--- PASS: TestIndexByteSmall (%!s(float64=0.9513959884643555))

=== RUN  TestIndexRune
--- PASS: TestIndexRune (%!s(float64=0.0008909702301025391))

=== RUN  TestCountByte
--- PASS: TestCountByte (%!s(float64=24.80153799057007))

=== RUN  TestCountByteNoMatch
--- PASS: TestCountByteNoMatch (%!s(float64=3.983751058578491))

=== RUN  TestSplit
--- PASS: TestSplit (%!s(float64=0.0042572021484375))

=== RUN  TestSplitAfter
--- PASS: TestSplitAfter (%!s(float64=0.004359006881713867))

=== RUN  TestFields
--- PASS: TestFields (%!s(float64=0.001216888427734375))

=== RUN  TestFieldsFunc
--- PASS: TestFieldsFunc (%!s(float64=0.0011119842529296875))

=== RUN  TestMap
--- PASS: TestMap (%!s(float64=0.0016219615936279297))

=== RUN  TestToUpper
--- PASS: TestToUpper (%!s(float64=0.0016429424285888672))

=== RUN  TestToLower
--- PASS: TestToLower (%!s(float64=0.0013980865478515625))

=== RUN  TestToValidUTF8
--- PASS: TestToValidUTF8 (%!s(float64=0.0013990402221679688))

=== RUN  TestTrimSpace
--- PASS: TestTrimSpace (%!s(float64=0.0013871192932128906))

=== RUN  TestRepeat
--- PASS: TestRepeat (%!s(float64=0.0001327991485595703))

=== RUN  TestRepeatCatchesOverflow
--- PASS: TestRepeatCatchesOverflow (%!s(float64=0.001811981201171875))

=== RUN  TestRunes
--- PASS: TestRunes (%!s(float64=0.0006339550018310547))

=== RUN  TestTrim
--- PASS: TestTrim (%!s(float64=0.002034902572631836))

=== RUN  TestTrimFunc
--- PASS: TestTrimFunc (%!s(float64=0.0033998489379882812))

=== RUN  TestIndexFunc
--- PASS: TestIndexFunc (%!s(float64=0.0010378360748291016))

=== RUN  TestReplace
--- PASS: TestReplace (%!s(float64=0.002604961395263672))

=== RUN  TestTitle
--- PASS: TestTitle (%!s(float64=0.001110076904296875))

=== RUN  TestToTitle
--- PASS: TestToTitle (%!s(float64=0.0006418228149414062))

=== RUN  TestEqualFold
--- PASS: TestEqualFold (%!s(float64=0.0014600753784179688))

=== RUN  TestCut
--- PASS: TestCut (%!s(float64=0.00010800361633300781))

=== RUN  TestBufferGrowNegative
--- PASS: TestBufferGrowNegative (%!s(float64=3.409385681152344e-05))

=== RUN  TestBufferTruncateNegative
--- PASS: TestBufferTruncateNegative (%!s(float64=2.7894973754882812e-05))

=== RUN  TestBufferTruncateOutOfRange
--- PASS: TestBufferTruncateOutOfRange (%!s(float64=5.2928924560546875e-05))

=== RUN  TestContains
--- PASS: TestContains (%!s(float64=4.696846008300781e-05))

=== RUN  TestContainsAny
--- PASS: TestContainsAny (%!s(float64=0.00047588348388671875))

=== RUN  TestContainsRune
--- PASS: TestContainsRune (%!s(float64=0.0001220703125))

=== RUN  TestCompare
--- PASS: TestCompare (%!s(float64=0.0028829574584960938))

=== RUN  TestCompareIdenticalSlice
--- PASS: TestCompareIdenticalSlice (%!s(float64=2.9087066650390625e-05))

=== RUN  TestCompareBytes
bytes_test/Bytes_test.hx:4449: testCompareBytes skip function
--- PASS: TestCompareBytes (%!s(float64=1.5974044799804688e-05))

=== RUN  TestEndianBaseCompare
--- PASS: TestEndianBaseCompare (%!s(float64=0.3056049346923828))

=== RUN  TestReader
--- PASS: TestReader (%!s(float64=0.0005249977111816406))

=== RUN  TestReadAfterBigSeek
--- PASS: TestReadAfterBigSeek (%!s(float64=9.799003601074219e-05))

=== RUN  TestReaderAt
--- PASS: TestReaderAt (%!s(float64=0.003834962844848633))

=== RUN  TestReaderAtConcurrent
--- PASS: TestReaderAtConcurrent (%!s(float64=0.0007159709930419922))

=== RUN  TestEmptyReaderConcurrent
--- PASS: TestEmptyReaderConcurrent (%!s(float64=0.0016062259674072266))

=== RUN  TestReaderWriteTo
--- PASS: TestReaderWriteTo (%!s(float64=0.01949310302734375))

=== RUN  TestReaderLen
--- PASS: TestReaderLen (%!s(float64=8.106231689453125e-05))

=== RUN  TestUnreadRuneError
--- PASS: TestUnreadRuneError (%!s(float64=0.00018906593322753906))

=== RUN  TestReaderDoubleUnreadRune
--- PASS: TestReaderDoubleUnreadRune (%!s(float64=3.0040740966796875e-05))

=== RUN  TestReaderCopyNothing</code></pre>
<p></p>
</details></p><details><summary>jvm tests failed</summary>
<p>
<pre><code>stdgo/reflect/Reflect.hx:2977: characters 28-35 : Warning : Potential typo detected (expected similar values are refType). Consider using `var keyType` instead
IO.Overflow("write_ui16")
stdgo/internal/Macro.macro.hx:35: define</code></pre>
<p></p>
</details></p>
<h1><a name="index">Index</a></h1><ul><li>
<p><a href="#constants">Constants</a></p></li><li>
<p><a href="#variables">Variables</a></p></li><li>
<p><a href="#function-compare"><code>function compare(_a:stdgo.Slice&lt;stdgo.GoByte&gt;, _b:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-contains"><code>function contains(_b:stdgo.Slice&lt;stdgo.GoByte&gt;, _subslice:stdgo.Slice&lt;stdgo.GoByte&gt;):Bool</code></a></p></li><li>
<p><a href="#function-containsany"><code>function containsAny(_b:stdgo.Slice&lt;stdgo.GoByte&gt;, _chars:stdgo.GoString):Bool</code></a></p></li><li>
<p><a href="#function-containsrune"><code>function containsRune(_b:stdgo.Slice&lt;stdgo.GoByte&gt;, _r:stdgo.GoRune):Bool</code></a></p></li><li>
<p><a href="#function-count"><code>function count(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-cut"><code>function cut(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;):{_2:Bool, _1:stdgo.Slice&lt;stdgo.GoByte&gt;, _0:stdgo.Slice&lt;stdgo.GoByte&gt;}</code></a></p></li><li>
<p><a href="#function-equal"><code>function equal(_a:stdgo.Slice&lt;stdgo.GoByte&gt;, _b:stdgo.Slice&lt;stdgo.GoByte&gt;):Bool</code></a></p></li><li>
<p><a href="#function-equalfold"><code>function equalFold(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _t:stdgo.Slice&lt;stdgo.GoByte&gt;):Bool</code></a></p></li><li>
<p><a href="#function-fields"><code>function fields(_s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.Slice&lt;stdgo.GoByte&gt;&gt;</code></a></p></li><li>
<p><a href="#function-fieldsfunc"><code>function fieldsFunc(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _f:()):stdgo.Slice&lt;stdgo.Slice&lt;stdgo.GoByte&gt;&gt;</code></a></p></li><li>
<p><a href="#function-hasprefix"><code>function hasPrefix(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _prefix:stdgo.Slice&lt;stdgo.GoByte&gt;):Bool</code></a></p></li><li>
<p><a href="#function-hassuffix"><code>function hasSuffix(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _suffix:stdgo.Slice&lt;stdgo.GoByte&gt;):Bool</code></a></p></li><li>
<p><a href="#function-index"><code>function index(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-indexany"><code>function indexAny(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _chars:stdgo.GoString):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-indexbyte"><code>function indexByte(_b:stdgo.Slice&lt;stdgo.GoByte&gt;, _c:stdgo.GoByte):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-indexbyteportable"><code>function indexBytePortable(:stdgo.Slice&lt;stdgo.GoUInt8&gt;, :stdgo.GoUInt8):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-indexfunc"><code>function indexFunc(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _f:(_r:stdgo.GoRune):Bool):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-indexrune"><code>function indexRune(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _r:stdgo.GoRune):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-join"><code>function join(_s:stdgo.Slice&lt;stdgo.Slice&lt;stdgo.GoByte&gt;&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-lastindex"><code>function lastIndex(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-lastindexany"><code>function lastIndexAny(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _chars:stdgo.GoString):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-lastindexbyte"><code>function lastIndexByte(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _c:stdgo.GoByte):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-lastindexfunc"><code>function lastIndexFunc(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _f:(_r:stdgo.GoRune):Bool):stdgo.GoInt</code></a></p></li><li>
<p><a href="#function-map"><code>function map(_mapping:(_r:stdgo.GoRune):stdgo.GoRune, _s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-newbuffer"><code>function newBuffer(_buf:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Ref&lt;stdgo.bytes.Buffer&gt;</code></a></p></li><li>
<p><a href="#function-newbufferstring"><code>function newBufferString(_s:stdgo.GoString):stdgo.Ref&lt;stdgo.bytes.Buffer&gt;</code></a></p></li><li>
<p><a href="#function-newreader"><code>function newReader(_b:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Ref&lt;stdgo.bytes.Reader&gt;</code></a></p></li><li>
<p><a href="#function-repeat"><code>function repeat(_b:stdgo.Slice&lt;stdgo.GoByte&gt;, _count:stdgo.GoInt):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-replace"><code>function replace(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _old:stdgo.Slice&lt;stdgo.GoByte&gt;, _new:stdgo.Slice&lt;stdgo.GoByte&gt;, _n:stdgo.GoInt):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-replaceall"><code>function replaceAll(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _old:stdgo.Slice&lt;stdgo.GoByte&gt;, _new:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-runes"><code>function runes(_s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoRune&gt;</code></a></p></li><li>
<p><a href="#function-split"><code>function split(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.Slice&lt;stdgo.GoByte&gt;&gt;</code></a></p></li><li>
<p><a href="#function-splitafter"><code>function splitAfter(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.Slice&lt;stdgo.GoByte&gt;&gt;</code></a></p></li><li>
<p><a href="#function-splitaftern"><code>function splitAfterN(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;, _n:stdgo.GoInt):stdgo.Slice&lt;stdgo.Slice&lt;stdgo.GoByte&gt;&gt;</code></a></p></li><li>
<p><a href="#function-splitn"><code>function splitN(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;, _n:stdgo.GoInt):stdgo.Slice&lt;stdgo.Slice&lt;stdgo.GoByte&gt;&gt;</code></a></p></li><li>
<p><a href="#function-title"><code>function title(_s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-tolower"><code>function toLower(_s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-tolowerspecial"><code>function toLowerSpecial(_c:stdgo.unicode.SpecialCase, _s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-totitle"><code>function toTitle(_s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-totitlespecial"><code>function toTitleSpecial(_c:stdgo.unicode.SpecialCase, _s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-toupper"><code>function toUpper(_s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-toupperspecial"><code>function toUpperSpecial(_c:stdgo.unicode.SpecialCase, _s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-tovalidutf8"><code>function toValidUTF8(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _replacement:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-trim"><code>function trim(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _cutset:stdgo.GoString):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-trimfunc"><code>function trimFunc(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _f:(_r:stdgo.GoRune):Bool):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-trimleft"><code>function trimLeft(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _cutset:stdgo.GoString):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-trimleftfunc"><code>function trimLeftFunc(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _f:(_r:stdgo.GoRune):Bool):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-trimprefix"><code>function trimPrefix(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _prefix:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-trimright"><code>function trimRight(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _cutset:stdgo.GoString):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-trimrightfunc"><code>function trimRightFunc(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _f:(_r:stdgo.GoRune):Bool):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-trimspace"><code>function trimSpace(_s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#function-trimsuffix"><code>function trimSuffix(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _suffix:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#class-buffer">class Buffer</a></p></li><li>
<p><a href="#buffer-function-new"><code>function new(?_buf:stdgo.Slice&lt;stdgo.GoUInt8&gt;, ?_off:Null&lt;stdgo.GoInt&gt;, ?_lastRead:Null&lt;stdgo.bytes._Bytes.T_readOp&gt;):Void</code></a></p></li><li>
<p><a href="#buffer-function-_empty"><code>function _empty():Bool</code></a></p></li><li>
<p><a href="#buffer-function-_grow"><code>function _grow( _n:stdgo.GoInt):stdgo.GoInt</code></a></p></li><li>
<p><a href="#buffer-function-_readslice"><code>function _readSlice( _delim:stdgo.GoByte):{_1:stdgo.Error, _0:stdgo.Slice&lt;stdgo.GoByte&gt;}</code></a></p></li><li>
<p><a href="#buffer-function-_trygrowbyreslice"><code>function _tryGrowByReslice( _n:stdgo.GoInt):{_1:Bool, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#buffer-function-bytes"><code>function bytes():stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#buffer-function-cap"><code>function cap():stdgo.GoInt</code></a></p></li><li>
<p><a href="#buffer-function-grow"><code>function grow( _n:stdgo.GoInt):Void</code></a></p></li><li>
<p><a href="#buffer-function-len"><code>function len():stdgo.GoInt</code></a></p></li><li>
<p><a href="#buffer-function-next"><code>function next( _n:stdgo.GoInt):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#buffer-function-read"><code>function read( _p:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#buffer-function-readbyte"><code>function readByte():{_1:stdgo.Error, _0:stdgo.GoByte}</code></a></p></li><li>
<p><a href="#buffer-function-readbytes"><code>function readBytes( _delim:stdgo.GoByte):{_1:stdgo.Error, _0:stdgo.Slice&lt;stdgo.GoByte&gt;}</code></a></p></li><li>
<p><a href="#buffer-function-readfrom"><code>function readFrom( _r:stdgo.io.Reader):{_1:stdgo.Error, _0:stdgo.GoInt64}</code></a></p></li><li>
<p><a href="#buffer-function-readrune"><code>function readRune():{_2:stdgo.Error, _1:stdgo.GoInt, _0:stdgo.GoRune}</code></a></p></li><li>
<p><a href="#buffer-function-readstring"><code>function readString( _delim:stdgo.GoByte):{_1:stdgo.Error, _0:stdgo.GoString}</code></a></p></li><li>
<p><a href="#buffer-function-reset"><code>function reset():Void</code></a></p></li><li>
<p><a href="#buffer-function-string"><code>function string():stdgo.GoString</code></a></p></li><li>
<p><a href="#buffer-function-truncate"><code>function truncate( _n:stdgo.GoInt):Void</code></a></p></li><li>
<p><a href="#buffer-function-unreadbyte"><code>function unreadByte():stdgo.Error</code></a></p></li><li>
<p><a href="#buffer-function-unreadrune"><code>function unreadRune():stdgo.Error</code></a></p></li><li>
<p><a href="#buffer-function-write"><code>function write( _p:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#buffer-function-writebyte"><code>function writeByte( _c:stdgo.GoByte):stdgo.Error</code></a></p></li><li>
<p><a href="#buffer-function-writerune"><code>function writeRune( _r:stdgo.GoRune):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#buffer-function-writestring"><code>function writeString( _s:stdgo.GoString):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#buffer-function-writeto"><code>function writeTo( _w:stdgo.io.Writer):{_1:stdgo.Error, _0:stdgo.GoInt64}</code></a></p></li><li>
<p><a href="#class-buffer_static_extension">class Buffer_static_extension</a></p></li><li>
<p><a href="#buffer_static_extension-function-_empty"><code>function _empty():Bool</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-_grow"><code>function _grow( _n:stdgo.GoInt):stdgo.GoInt</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-_readslice"><code>function _readSlice( _delim:stdgo.GoByte):{_1:stdgo.Error, _0:stdgo.Slice&lt;stdgo.GoByte&gt;}</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-_trygrowbyreslice"><code>function _tryGrowByReslice( _n:stdgo.GoInt):{_1:Bool, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-bytes"><code>function bytes():stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-cap"><code>function cap():stdgo.GoInt</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-grow"><code>function grow( _n:stdgo.GoInt):Void</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-len"><code>function len():stdgo.GoInt</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-next"><code>function next( _n:stdgo.GoInt):stdgo.Slice&lt;stdgo.GoByte&gt;</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-read"><code>function read( _p:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-readbyte"><code>function readByte():{_1:stdgo.Error, _0:stdgo.GoByte}</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-readbytes"><code>function readBytes( _delim:stdgo.GoByte):{_1:stdgo.Error, _0:stdgo.Slice&lt;stdgo.GoByte&gt;}</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-readfrom"><code>function readFrom( _r:stdgo.io.Reader):{_1:stdgo.Error, _0:stdgo.GoInt64}</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-readrune"><code>function readRune():{_2:stdgo.Error, _1:stdgo.GoInt, _0:stdgo.GoRune}</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-readstring"><code>function readString( _delim:stdgo.GoByte):{_1:stdgo.Error, _0:stdgo.GoString}</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-reset"><code>function reset():Void</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-string"><code>function string():stdgo.GoString</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-truncate"><code>function truncate( _n:stdgo.GoInt):Void</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-unreadbyte"><code>function unreadByte():stdgo.Error</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-unreadrune"><code>function unreadRune():stdgo.Error</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-write"><code>function write( _p:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-writebyte"><code>function writeByte( _c:stdgo.GoByte):stdgo.Error</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-writerune"><code>function writeRune( _r:stdgo.GoRune):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-writestring"><code>function writeString( _s:stdgo.GoString):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#buffer_static_extension-function-writeto"><code>function writeTo( _w:stdgo.io.Writer):{_1:stdgo.Error, _0:stdgo.GoInt64}</code></a></p></li><li>
<p><a href="#class-reader">class Reader</a></p></li><li>
<p><a href="#reader-function-new"><code>function new(?_s:stdgo.Slice&lt;stdgo.GoUInt8&gt;, ?_i:stdgo.GoInt64, ?_prevRune:Null&lt;stdgo.GoInt&gt;):Void</code></a></p></li><li>
<p><a href="#reader-function-len"><code>function len():stdgo.GoInt</code></a></p></li><li>
<p><a href="#reader-function-read"><code>function read( _b:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#reader-function-readat"><code>function readAt( _b:stdgo.Slice&lt;stdgo.GoByte&gt;, _off:stdgo.GoInt64):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#reader-function-readbyte"><code>function readByte():{_1:stdgo.Error, _0:stdgo.GoByte}</code></a></p></li><li>
<p><a href="#reader-function-readrune"><code>function readRune():{_2:stdgo.Error, _1:stdgo.GoInt, _0:stdgo.GoRune}</code></a></p></li><li>
<p><a href="#reader-function-reset"><code>function reset( _b:stdgo.Slice&lt;stdgo.GoByte&gt;):Void</code></a></p></li><li>
<p><a href="#reader-function-seek"><code>function seek( _offset:stdgo.GoInt64, _whence:stdgo.GoInt):{_1:stdgo.Error, _0:stdgo.GoInt64}</code></a></p></li><li>
<p><a href="#reader-function-size"><code>function size():stdgo.GoInt64</code></a></p></li><li>
<p><a href="#reader-function-unreadbyte"><code>function unreadByte():stdgo.Error</code></a></p></li><li>
<p><a href="#reader-function-unreadrune"><code>function unreadRune():stdgo.Error</code></a></p></li><li>
<p><a href="#reader-function-writeto"><code>function writeTo( _w:stdgo.io.Writer):{_1:stdgo.Error, _0:stdgo.GoInt64}</code></a></p></li><li>
<p><a href="#class-reader_static_extension">class Reader_static_extension</a></p></li><li>
<p><a href="#reader_static_extension-function-len"><code>function len():stdgo.GoInt</code></a></p></li><li>
<p><a href="#reader_static_extension-function-read"><code>function read( _b:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#reader_static_extension-function-readat"><code>function readAt( _b:stdgo.Slice&lt;stdgo.GoByte&gt;, _off:stdgo.GoInt64):{_1:stdgo.Error, _0:stdgo.GoInt}</code></a></p></li><li>
<p><a href="#reader_static_extension-function-readbyte"><code>function readByte():{_1:stdgo.Error, _0:stdgo.GoByte}</code></a></p></li><li>
<p><a href="#reader_static_extension-function-readrune"><code>function readRune():{_2:stdgo.Error, _1:stdgo.GoInt, _0:stdgo.GoRune}</code></a></p></li><li>
<p><a href="#reader_static_extension-function-reset"><code>function reset( _b:stdgo.Slice&lt;stdgo.GoByte&gt;):Void</code></a></p></li><li>
<p><a href="#reader_static_extension-function-seek"><code>function seek( _offset:stdgo.GoInt64, _whence:stdgo.GoInt):{_1:stdgo.Error, _0:stdgo.GoInt64}</code></a></p></li><li>
<p><a href="#reader_static_extension-function-size"><code>function size():stdgo.GoInt64</code></a></p></li><li>
<p><a href="#reader_static_extension-function-unreadbyte"><code>function unreadByte():stdgo.Error</code></a></p></li><li>
<p><a href="#reader_static_extension-function-unreadrune"><code>function unreadRune():stdgo.Error</code></a></p></li><li>
<p><a href="#reader_static_extension-function-writeto"><code>function writeTo( _w:stdgo.io.Writer):{_1:stdgo.Error, _0:stdgo.GoInt64}</code></a></p></li><li>
<p><a href="#class-t_asciiset_static_extension">class T_asciiSet_static_extension</a></p></li><li>
<p><a href="#t_asciiset_static_extension-function-_contains"><code>function _contains(_as:stdgo.Ref&lt;stdgo.bytes._Bytes.T_asciiSet&gt;, _c:stdgo.GoByte):Bool</code></a></p></li></ul>
<h1><a name="examples">Examples</a></h1><ul><li>
<p><a href="#examplecompare"><code>exampleCompare</code></a></p></li><li>
<p><a href="#examplecompare_search"><code>exampleCompare_search</code></a></p></li><li>
<p><a href="#examplecontains"><code>exampleContains</code></a></p></li><li>
<p><a href="#examplecontainsany"><code>exampleContainsAny</code></a></p></li><li>
<p><a href="#examplecontainsrune"><code>exampleContainsRune</code></a></p></li><li>
<p><a href="#examplecount"><code>exampleCount</code></a></p></li><li>
<p><a href="#examplecut"><code>exampleCut</code></a></p></li><li>
<p><a href="#exampleequal"><code>exampleEqual</code></a></p></li><li>
<p><a href="#exampleequalfold"><code>exampleEqualFold</code></a></p></li><li>
<p><a href="#examplefields"><code>exampleFields</code></a></p></li><li>
<p><a href="#examplefieldsfunc"><code>exampleFieldsFunc</code></a></p></li><li>
<p><a href="#examplehasprefix"><code>exampleHasPrefix</code></a></p></li><li>
<p><a href="#examplehassuffix"><code>exampleHasSuffix</code></a></p></li><li>
<p><a href="#exampleindex"><code>exampleIndex</code></a></p></li><li>
<p><a href="#exampleindexany"><code>exampleIndexAny</code></a></p></li><li>
<p><a href="#exampleindexbyte"><code>exampleIndexByte</code></a></p></li><li>
<p><a href="#exampleindexfunc"><code>exampleIndexFunc</code></a></p></li><li>
<p><a href="#exampleindexrune"><code>exampleIndexRune</code></a></p></li><li>
<p><a href="#examplejoin"><code>exampleJoin</code></a></p></li><li>
<p><a href="#examplelastindex"><code>exampleLastIndex</code></a></p></li><li>
<p><a href="#examplelastindexany"><code>exampleLastIndexAny</code></a></p></li><li>
<p><a href="#examplelastindexbyte"><code>exampleLastIndexByte</code></a></p></li><li>
<p><a href="#examplelastindexfunc"><code>exampleLastIndexFunc</code></a></p></li><li>
<p><a href="#examplerepeat"><code>exampleRepeat</code></a></p></li><li>
<p><a href="#examplereplace"><code>exampleReplace</code></a></p></li><li>
<p><a href="#examplereplaceall"><code>exampleReplaceAll</code></a></p></li><li>
<p><a href="#examplerunes"><code>exampleRunes</code></a></p></li><li>
<p><a href="#examplesplit"><code>exampleSplit</code></a></p></li><li>
<p><a href="#examplesplitafter"><code>exampleSplitAfter</code></a></p></li><li>
<p><a href="#examplesplitaftern"><code>exampleSplitAfterN</code></a></p></li><li>
<p><a href="#examplesplitn"><code>exampleSplitN</code></a></p></li><li>
<p><a href="#exampletitle"><code>exampleTitle</code></a></p></li><li>
<p><a href="#exampletolower"><code>exampleToLower</code></a></p></li><li>
<p><a href="#exampletolowerspecial"><code>exampleToLowerSpecial</code></a></p></li><li>
<p><a href="#exampletotitle"><code>exampleToTitle</code></a></p></li><li>
<p><a href="#exampletotitlespecial"><code>exampleToTitleSpecial</code></a></p></li><li>
<p><a href="#exampletoupper"><code>exampleToUpper</code></a></p></li><li>
<p><a href="#exampletoupperspecial"><code>exampleToUpperSpecial</code></a></p></li><li>
<p><a href="#exampletrim"><code>exampleTrim</code></a></p></li><li>
<p><a href="#exampletrimfunc"><code>exampleTrimFunc</code></a></p></li><li>
<p><a href="#exampletrimleft"><code>exampleTrimLeft</code></a></p></li><li>
<p><a href="#exampletrimleftfunc"><code>exampleTrimLeftFunc</code></a></p></li><li>
<p><a href="#exampletrimprefix"><code>exampleTrimPrefix</code></a></p></li><li>
<p><a href="#exampletrimright"><code>exampleTrimRight</code></a></p></li><li>
<p><a href="#exampletrimrightfunc"><code>exampleTrimRightFunc</code></a></p></li><li>
<p><a href="#exampletrimspace"><code>exampleTrimSpace</code></a></p></li><li>
<p><a href="#exampletrimsuffix"><code>exampleTrimSuffix</code></a></p></li></ul>
<h1><a name="constants">Constants</a></h1>
<pre><code class="language-haxe">import stdgo.bytes.Bytes</code></pre>
<pre><code class="language-haxe">final minRead:stdgo.GoUInt64 = (("512" : GoUInt64))</code></pre>
<p>MinRead is the minimum slice size passed to a Read call by  Buffer.ReadFrom. As long as the Buffer has at least MinRead bytes beyond  what is required to hold the contents of r, ReadFrom will not grow the  underlying buffer. </p>
<h1><a name="variables">Variables</a></h1>
<pre><code class="language-haxe">import stdgo.bytes.Bytes</code></pre>
<pre><code class="language-haxe">var errTooLarge:stdgo.Error</code></pre>
<p>ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer. </p>
<h1><a name="functions">Functions</a></h1>
<pre><code class="language-haxe">import stdgo.bytes.Bytes</code></pre>
<h2><a name="function-compare">function compare</a></h2>
<pre><code class="language-haxe">function compare(_a:stdgo.Slice&lt;stdgo.GoByte&gt;, _b:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.GoInt</code></pre>
<p>Compare returns an integer comparing two byte slices lexicographically.  The result will be 0 if a == b, -1 if a \&lt; b, and +1 if a \> b.  A nil argument is equivalent to an empty slice. </p>
<h3><a name="examplecompare">exampleCompare</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleCompare():Void {
	var _0:Slice&lt;GoByte&gt; = (null : Slice&lt;GoUInt8&gt;),
		_1:Slice&lt;GoByte&gt; = (null : Slice&lt;GoUInt8&gt;),
		_b:Slice&lt;GoByte&gt; = _1,
		_a:Slice&lt;GoByte&gt; = _0;
	if (stdgo.bytes.Bytes.compare(_a, _b) &lt; (0:GoInt)) {};
	if (stdgo.bytes.Bytes.compare(_a, _b) &lt;= (0 : GoInt)) {};
	if (stdgo.bytes.Bytes.compare(_a, _b) &gt; (0 : GoInt)) {};
	if (stdgo.bytes.Bytes.compare(_a, _b) &gt;= (0 : GoInt)) {};
	if (stdgo.bytes.Bytes.equal(_a, _b)) {};
	if (!stdgo.bytes.Bytes.equal(_a, _b)) {};
}</code></pre>
<p></p>
</details></p>
<h3><a name="examplecompare_search">exampleCompare_search</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleCompare_search():Void {
	var _needle:Slice&lt;GoByte&gt; = (null : Slice&lt;GoUInt8&gt;);
	var _haystack:Slice&lt;Slice&lt;GoByte&gt;&gt; = (null : Slice&lt;Slice&lt;GoUInt8&gt;&gt;);
	var _i:GoInt = stdgo.sort.Sort.search((_haystack.length), function(_i:GoInt):Bool {
		return stdgo.bytes.Bytes.compare(_haystack[(_i : GoInt)], _needle) &gt;= (0 : GoInt);
	});
	if ((_i &lt; _haystack.length) &amp;&amp; stdgo.bytes.Bytes.equal(_haystack[(_i : GoInt)], _needle)) {};
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L266"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-contains">function contains</a></h2>
<pre><code class="language-haxe">function contains(_b:stdgo.Slice&lt;stdgo.GoByte&gt;, _subslice:stdgo.Slice&lt;stdgo.GoByte&gt;):Bool</code></pre>
<p>Contains reports whether subslice is within b. </p>
<h3><a name="examplecontains">exampleContains</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleContains():Void {
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.contains((("seafood" : GoString) : Slice&lt;GoByte&gt;), (("foo" : GoString) : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.contains((("seafood" : GoString) : Slice&lt;GoByte&gt;), (("bar" : GoString) : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.contains((("seafood" : GoString) : Slice&lt;GoByte&gt;), (Go.str() : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.contains((Go.str() : Slice&lt;GoByte&gt;), (Go.str() : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L323"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-containsany">function containsAny</a></h2>
<pre><code class="language-haxe">function containsAny(_b:stdgo.Slice&lt;stdgo.GoByte&gt;, _chars:stdgo.GoString):Bool</code></pre>
<p>ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b. </p>
<h3><a name="examplecontainsany">exampleContainsAny</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleContainsAny():Void {
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.containsAny((("I like seafood." : GoString) : Slice&lt;GoByte&gt;), ("fÄo!" : GoString))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.containsAny((("I like seafood." : GoString) : Slice&lt;GoByte&gt;), ("去是伟大的." : GoString))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.containsAny((("I like seafood." : GoString) : Slice&lt;GoByte&gt;), Go.str())));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.containsAny((Go.str() : Slice&lt;GoByte&gt;), Go.str())));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L330"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-containsrune">function containsRune</a></h2>
<pre><code class="language-haxe">function containsRune(_b:stdgo.Slice&lt;stdgo.GoByte&gt;, _r:stdgo.GoRune):Bool</code></pre>
<p>ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b. </p>
<h3><a name="examplecontainsrune">exampleContainsRune</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleContainsRune():Void {
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.containsRune((("I like seafood." : GoString) : Slice&lt;GoByte&gt;), (102 : GoInt32))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.containsRune((("I like seafood." : GoString) : Slice&lt;GoByte&gt;), (246 : GoInt32))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.containsRune((("去是伟大的!" : GoString) : Slice&lt;GoByte&gt;), (22823 : GoInt32))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.containsRune((("去是伟大的!" : GoString) : Slice&lt;GoByte&gt;), (33 : GoInt32))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.containsRune((Go.str() : Slice&lt;GoByte&gt;), (64 : GoInt32))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L337"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-count">function count</a></h2>
<pre><code class="language-haxe">function count(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.GoInt</code></pre>
<p>Count counts the number of non-overlapping instances of sep in s.  If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s. </p>
<h3><a name="examplecount">exampleCount</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleCount():Void {
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.count((("cheese" : GoString) : Slice&lt;GoByte&gt;), (("e" : GoString) : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.count((("five" : GoString) : Slice&lt;GoByte&gt;), (Go.str() : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L302"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-cut">function cut</a></h2>
<pre><code class="language-haxe">function cut(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;):{_2:Bool, _1:stdgo.Slice&lt;stdgo.GoByte&gt;, _0:stdgo.Slice&lt;stdgo.GoByte&gt;}</code></pre>
<p>Cut slices s around the first instance of sep,  returning the text before and after sep.  The found result reports whether sep appears in s.  If sep does not appear in s, cut returns s, nil, false.    Cut returns slices of the original slice s, not copies. </p>
<h3><a name="examplecut">exampleCut</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleCut():Void {
	var _show:(GoString, GoString) -&gt; Void = function(_s:GoString, _sep:GoString):Void {
		var __tmp__ = stdgo.bytes.Bytes.cut((_s : Slice&lt;GoByte&gt;),
			(_sep : Slice&lt;GoByte&gt;)), _before:Slice&lt;GoUInt8&gt; = __tmp__._0, _after:Slice&lt;GoUInt8&gt; = __tmp__._1, _found:Bool = __tmp__._2;
		stdgo.fmt.Fmt.printf(("Cut(%q, %q) = %q, %q, %v\n" : GoString), Go.toInterface(_s), Go.toInterface(_sep), Go.toInterface(_before),
			Go.toInterface(_after), Go.toInterface(_found));
	};
	_show(("Gopher" : GoString), ("Go" : GoString));
	_show(("Gopher" : GoString), ("ph" : GoString));
	_show(("Gopher" : GoString), ("er" : GoString));
	_show(("Gopher" : GoString), ("Badger" : GoString));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1732"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-equal">function equal</a></h2>
<pre><code class="language-haxe">function equal(_a:stdgo.Slice&lt;stdgo.GoByte&gt;, _b:stdgo.Slice&lt;stdgo.GoByte&gt;):Bool</code></pre>
<p>Equal reports whether a and b  are the same length and contain the same bytes.  A nil argument is equivalent to an empty slice. </p>
<h3><a name="exampleequal">exampleEqual</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleEqual():Void {
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.equal((("Go" : GoString) : Slice&lt;GoByte&gt;), (("Go" : GoString) : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.equal((("Go" : GoString) : Slice&lt;GoByte&gt;), (("C++" : GoString) : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L257"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-equalfold">function equalFold</a></h2>
<pre><code class="language-haxe">function equalFold(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _t:stdgo.Slice&lt;stdgo.GoByte&gt;):Bool</code></pre>
<p>EqualFold reports whether s and t, interpreted as UTF-8 strings,  are equal under simple Unicode case-folding, which is a more general  form of case-insensitivity. </p>
<h3><a name="exampleequalfold">exampleEqualFold</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleEqualFold():Void {
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.equalFold((("Go" : GoString) : Slice&lt;GoByte&gt;), (("go" : GoString) : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1576"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-fields">function fields</a></h2>
<pre><code class="language-haxe">function fields(_s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.Slice&lt;stdgo.GoByte&gt;&gt;</code></pre>
<p>Fields interprets s as a sequence of UTF-8-encoded code points.  It splits the slice s around each instance of one or more consecutive white space  characters, as defined by unicode.IsSpace, returning a slice of subslices of s or an  empty slice if s contains only white space. </p>
<h3><a name="examplefields">exampleFields</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleFields():Void {
	stdgo.fmt.Fmt.printf(("Fields are: %q" : GoString), Go.toInterface(stdgo.bytes.Bytes.fields((("  foo bar  baz   " : GoString) : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L732"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-fieldsfunc">function fieldsFunc</a></h2>
<pre><code class="language-haxe">function fieldsFunc(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _f:()):stdgo.Slice&lt;stdgo.Slice&lt;stdgo.GoByte&gt;&gt;</code></pre>
<p>FieldsFunc interprets s as a sequence of UTF-8-encoded code points.  It splits the slice s at each run of code points c satisfying f(c) and  returns a slice of subslices of s. If all code points in s satisfy f(c), or  len(s) == 0, an empty slice is returned.    FieldsFunc makes no guarantees about the order in which it calls f(c)  and assumes that f always returns the same value for a given c. </p>
<h3><a name="examplefieldsfunc">exampleFieldsFunc</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleFieldsFunc():Void {
	var _f:GoInt32-&gt;Bool = function(_c:GoRune):Bool {
		return !stdgo.unicode.Unicode.isLetter(_c) &amp;&amp; !stdgo.unicode.Unicode.isNumber(_c);
	};
	stdgo.fmt.Fmt.printf(("Fields are: %q" : GoString),
		Go.toInterface(stdgo.bytes.Bytes.fieldsFunc((("  foo1;bar2,baz3..." : GoString) : Slice&lt;GoByte&gt;), _f)));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L808"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-hasprefix">function hasPrefix</a></h2>
<pre><code class="language-haxe">function hasPrefix(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _prefix:stdgo.Slice&lt;stdgo.GoByte&gt;):Bool</code></pre>
<p>HasPrefix tests whether the byte slice s begins with prefix. </p>
<h3><a name="examplehasprefix">exampleHasPrefix</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleHasPrefix():Void {
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.hasPrefix((("Gopher" : GoString) : Slice&lt;GoByte&gt;), (("Go" : GoString) : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.hasPrefix((("Gopher" : GoString) : Slice&lt;GoByte&gt;), (("C" : GoString) : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.hasPrefix((("Gopher" : GoString) : Slice&lt;GoByte&gt;), (Go.str() : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L874"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-hassuffix">function hasSuffix</a></h2>
<pre><code class="language-haxe">function hasSuffix(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _suffix:stdgo.Slice&lt;stdgo.GoByte&gt;):Bool</code></pre>
<p>HasSuffix tests whether the byte slice s ends with suffix. </p>
<h3><a name="examplehassuffix">exampleHasSuffix</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleHasSuffix():Void {
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.hasSuffix((("Amigo" : GoString) : Slice&lt;GoByte&gt;), (("go" : GoString) : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.hasSuffix((("Amigo" : GoString) : Slice&lt;GoByte&gt;), (("O" : GoString) : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.hasSuffix((("Amigo" : GoString) : Slice&lt;GoByte&gt;), (("Ami" : GoString) : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.hasSuffix((("Amigo" : GoString) : Slice&lt;GoByte&gt;), (Go.str() : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L881"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-index">function index</a></h2>
<pre><code class="language-haxe">function index(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.GoInt</code></pre>
<p>Index returns the index of the first instance of sep in s, or -1 if sep is not present in s. </p>
<h3><a name="exampleindex">exampleIndex</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleIndex():Void {
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.index((("chicken" : GoString) : Slice&lt;GoByte&gt;), (("ken" : GoString) : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.index((("chicken" : GoString) : Slice&lt;GoByte&gt;), (("dmr" : GoString) : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1650"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-indexany">function indexAny</a></h2>
<pre><code class="language-haxe">function indexAny(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _chars:stdgo.GoString):stdgo.GoInt</code></pre>
<p>IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.  It returns the byte index of the first occurrence in s of any of the Unicode  code points in chars. It returns -1 if chars is empty or if there is no code  point in common. </p>
<h3><a name="exampleindexany">exampleIndexAny</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleIndexAny():Void {
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.indexAny((("chicken" : GoString) : Slice&lt;GoByte&gt;), ("aeiouy" : GoString))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.indexAny((("crwth" : GoString) : Slice&lt;GoByte&gt;), ("aeiouy" : GoString))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L456"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-indexbyte">function indexByte</a></h2>
<pre><code class="language-haxe">function indexByte(_b:stdgo.Slice&lt;stdgo.GoByte&gt;, _c:stdgo.GoByte):stdgo.GoInt</code></pre>
<p>IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b. </p>
<h3><a name="exampleindexbyte">exampleIndexByte</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleIndexByte():Void {
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.indexByte((("chicken" : GoString) : Slice&lt;GoByte&gt;), ((107 : GoUInt8) : GoByte))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.indexByte((("chicken" : GoString) : Slice&lt;GoByte&gt;), ((103 : GoUInt8) : GoByte))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L344"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-indexbyteportable">function indexBytePortable</a></h2>
<pre><code class="language-haxe">function indexBytePortable(:stdgo.Slice&lt;stdgo.GoUInt8&gt;, :stdgo.GoUInt8):stdgo.GoInt</code></pre>
<p>Export func for testing </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L41"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-indexfunc">function indexFunc</a></h2>
<pre><code class="language-haxe">function indexFunc(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _f:(_r:stdgo.GoRune):Bool):stdgo.GoInt</code></pre>
<p>IndexFunc interprets s as a sequence of UTF-8-encoded code points.  It returns the byte index in s of the first Unicode  code point satisfying f(c), or -1 if none do. </p>
<h3><a name="exampleindexfunc">exampleIndexFunc</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleIndexFunc():Void {
	var _f:GoInt32-&gt;Bool = function(_c:GoRune):Bool {
		return stdgo.unicode.Unicode.is_(stdgo.unicode.Unicode.han, _c);
	};
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.indexFunc((("Hello, 世界" : GoString) : Slice&lt;GoByte&gt;), _f)));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.indexFunc((("Hello, world" : GoString) : Slice&lt;GoByte&gt;), _f)));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1204"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-indexrune">function indexRune</a></h2>
<pre><code class="language-haxe">function indexRune(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _r:stdgo.GoRune):stdgo.GoInt</code></pre>
<p>IndexRune interprets s as a sequence of UTF-8-encoded code points.  It returns the byte index of the first occurrence in s of the given rune.  It returns -1 if rune is not present in s.  If r is utf8.RuneError, it returns the first instance of any  invalid UTF-8 byte sequence. </p>
<h3><a name="exampleindexrune">exampleIndexRune</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleIndexRune():Void {
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.indexRune((("chicken" : GoString) : Slice&lt;GoByte&gt;), (107 : GoInt32))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.indexRune((("chicken" : GoString) : Slice&lt;GoByte&gt;), (100 : GoInt32))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L424"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-join">function join</a></h2>
<pre><code class="language-haxe">function join(_s:stdgo.Slice&lt;stdgo.Slice&lt;stdgo.GoByte&gt;&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>Join concatenates the elements of s to create a new byte slice. The separator  sep is placed between elements in the resulting slice. </p>
<h3><a name="examplejoin">exampleJoin</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleJoin():Void {
	var _s = (new Slice&lt;Slice&lt;GoUInt8&gt;&gt;(0, 0, (("foo" : GoString) : Slice&lt;GoByte&gt;), (("bar" : GoString) : Slice&lt;GoByte&gt;),
		(("baz" : GoString) : Slice&lt;GoByte&gt;)) : Slice&lt;Slice&lt;GoUInt8&gt;&gt;);
	stdgo.fmt.Fmt.printf(("%s" : GoString), Go.toInterface(stdgo.bytes.Bytes.join(_s, ((", " : GoString) : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L851"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-lastindex">function lastIndex</a></h2>
<pre><code class="language-haxe">function lastIndex(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.GoInt</code></pre>
<p>LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s. </p>
<h3><a name="examplelastindex">exampleLastIndex</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleLastIndex():Void {
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.index((("go gopher" : GoString) : Slice&lt;GoByte&gt;), (("go" : GoString) : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.lastIndex((("go gopher" : GoString) : Slice&lt;GoByte&gt;), (("go" : GoString) : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.lastIndex((("go gopher" : GoString) : Slice&lt;GoByte&gt;), (("rodent" : GoString) : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L360"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-lastindexany">function lastIndexAny</a></h2>
<pre><code class="language-haxe">function lastIndexAny(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _chars:stdgo.GoString):stdgo.GoInt</code></pre>
<p>LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code  points. It returns the byte index of the last occurrence in s of any of  the Unicode code points in chars. It returns -1 if chars is empty or if  there is no code point in common. </p>
<h3><a name="examplelastindexany">exampleLastIndexAny</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleLastIndexAny():Void {
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.lastIndexAny((("go gopher" : GoString) : Slice&lt;GoByte&gt;), ("MüQp" : GoString))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.lastIndexAny((("go 地鼠" : GoString) : Slice&lt;GoByte&gt;), ("地大" : GoString))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.lastIndexAny((("go gopher" : GoString) : Slice&lt;GoByte&gt;), ("z,!." : GoString))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L545"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-lastindexbyte">function lastIndexByte</a></h2>
<pre><code class="language-haxe">function lastIndexByte(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _c:stdgo.GoByte):stdgo.GoInt</code></pre>
<p>LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s. </p>
<h3><a name="examplelastindexbyte">exampleLastIndexByte</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleLastIndexByte():Void {
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.lastIndexByte((("go gopher" : GoString) : Slice&lt;GoByte&gt;), ((103 : GoUInt8) : GoByte))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.lastIndexByte((("go gopher" : GoString) : Slice&lt;GoByte&gt;), ((114 : GoUInt8) : GoByte))));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.lastIndexByte((("go gopher" : GoString) : Slice&lt;GoByte&gt;), ((122 : GoUInt8) : GoByte))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L405"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-lastindexfunc">function lastIndexFunc</a></h2>
<pre><code class="language-haxe">function lastIndexFunc(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _f:(_r:stdgo.GoRune):Bool):stdgo.GoInt</code></pre>
<p>LastIndexFunc interprets s as a sequence of UTF-8-encoded code points.  It returns the byte index in s of the last Unicode  code point satisfying f(c), or -1 if none do. </p>
<h3><a name="examplelastindexfunc">exampleLastIndexFunc</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleLastIndexFunc():Void {
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.lastIndexFunc((("go gopher!" : GoString) : Slice&lt;GoByte&gt;), stdgo.unicode.Unicode.isLetter)));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.lastIndexFunc((("go gopher!" : GoString) : Slice&lt;GoByte&gt;), stdgo.unicode.Unicode.isPunct)));
	stdgo.fmt.Fmt.println(Go.toInterface(stdgo.bytes.Bytes.lastIndexFunc((("go gopher!" : GoString) : Slice&lt;GoByte&gt;), stdgo.unicode.Unicode.isNumber)));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1213"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-map">function map</a></h2>
<pre><code class="language-haxe">function map(_mapping:(_r:stdgo.GoRune):stdgo.GoRune, _s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>Map returns a copy of the byte slice s with all its characters modified  according to the mapping function. If mapping returns a negative value, the character is  dropped from the byte slice with no replacement. The characters in s and the  output are interpreted as UTF-8-encoded code points. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L891"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-newbuffer">function newBuffer</a></h2>
<pre><code class="language-haxe">function newBuffer(_buf:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Ref&lt;stdgo.bytes.Buffer&gt;</code></pre>
<p>NewBuffer creates and initializes a new Buffer using buf as its  initial contents. The new Buffer takes ownership of buf, and the  caller should not use buf after this call. NewBuffer is intended to  prepare a Buffer to read existing data. It can also be used to set  the initial size of the internal buffer for writing. To do that,  buf should have the desired capacity but a length of zero.    In most cases, new(Buffer) (or just declaring a Buffer variable) is  sufficient to initialize a Buffer. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L236"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-newbufferstring">function newBufferString</a></h2>
<pre><code class="language-haxe">function newBufferString(_s:stdgo.GoString):stdgo.Ref&lt;stdgo.bytes.Buffer&gt;</code></pre>
<p>NewBufferString creates and initializes a new Buffer using string s as its  initial contents. It is intended to prepare a buffer to read an existing  string.    In most cases, new(Buffer) (or just declaring a Buffer variable) is  sufficient to initialize a Buffer. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L248"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-newreader">function newReader</a></h2>
<pre><code class="language-haxe">function newReader(_b:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Ref&lt;stdgo.bytes.Reader&gt;</code></pre>
<p>NewReader returns a new Reader reading from b. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1748"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-repeat">function repeat</a></h2>
<pre><code class="language-haxe">function repeat(_b:stdgo.Slice&lt;stdgo.GoByte&gt;, _count:stdgo.GoInt):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>Repeat returns a new byte slice consisting of count copies of b.    It panics if count is negative or if  the result of (len(b) * count) overflows. </p>
<h3><a name="examplerepeat">exampleRepeat</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleRepeat():Void {
	stdgo.fmt.Fmt.printf(("ba%s" : GoString), Go.toInterface(stdgo.bytes.Bytes.repeat((("na" : GoString) : Slice&lt;GoByte&gt;), (2 : GoInt))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L933"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-replace">function replace</a></h2>
<pre><code class="language-haxe">function replace(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _old:stdgo.Slice&lt;stdgo.GoByte&gt;, _new:stdgo.Slice&lt;stdgo.GoByte&gt;, _n:stdgo.GoInt):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>Replace returns a copy of the slice s with the first n  non-overlapping instances of old replaced by new.  If old is empty, it matches at the beginning of the slice  and after each UTF-8 sequence, yielding up to k+1 replacements  for a k-rune slice.  If n \&lt; 0, there is no limit on the number of replacements. </p>
<h3><a name="examplereplace">exampleReplace</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleReplace():Void {
	stdgo.fmt.Fmt.printf(("%s\n" : GoString),
		Go.toInterface(stdgo.bytes.Bytes.replace((("oink oink oink" : GoString) : Slice&lt;GoByte&gt;), (("k" : GoString) : Slice&lt;GoByte&gt;),
			(("ky" : GoString) : Slice&lt;GoByte&gt;), (2 : GoInt))));
	stdgo.fmt.Fmt.printf(("%s\n" : GoString),
		Go.toInterface(stdgo.bytes.Bytes.replace((("oink oink oink" : GoString) : Slice&lt;GoByte&gt;), (("oink" : GoString) : Slice&lt;GoByte&gt;),
			(("moo" : GoString) : Slice&lt;GoByte&gt;), (-1 : GoInt))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1521"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-replaceall">function replaceAll</a></h2>
<pre><code class="language-haxe">function replaceAll(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _old:stdgo.Slice&lt;stdgo.GoByte&gt;, _new:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>ReplaceAll returns a copy of the slice s with all  non-overlapping instances of old replaced by new.  If old is empty, it matches at the beginning of the slice  and after each UTF-8 sequence, yielding up to k+1 replacements  for a k-rune slice. </p>
<h3><a name="examplereplaceall">exampleReplaceAll</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleReplaceAll():Void {
	stdgo.fmt.Fmt.printf(("%s\n" : GoString),
		Go.toInterface(stdgo.bytes.Bytes.replaceAll((("oink oink oink" : GoString) : Slice&lt;GoByte&gt;), (("oink" : GoString) : Slice&lt;GoByte&gt;),
			(("moo" : GoString) : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1567"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-runes">function runes</a></h2>
<pre><code class="language-haxe">function runes(_s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoRune&gt;</code></pre>
<p>Runes interprets s as a sequence of UTF-8-encoded code points.  It returns a slice of runes (Unicode code points) equivalent to s. </p>
<h3><a name="examplerunes">exampleRunes</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleRunes():Void {
	var _rs = stdgo.bytes.Bytes.runes((("go gopher" : GoString) : Slice&lt;GoByte&gt;));
	for (_0 =&gt; _r in _rs) {
		stdgo.fmt.Fmt.printf(("%#U\n" : GoString), Go.toInterface(_r));
	};
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1497"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-split">function split</a></h2>
<pre><code class="language-haxe">function split(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.Slice&lt;stdgo.GoByte&gt;&gt;</code></pre>
<p>Split slices s into all subslices separated by sep and returns a slice of  the subslices between those separators.  If sep is empty, Split splits after each UTF-8 sequence.  It is equivalent to SplitN with a count of -1.    To split around the first instance of a separator, see Cut. </p>
<h3><a name="examplesplit">exampleSplit</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleSplit():Void {
	stdgo.fmt.Fmt.printf(("%q\n" : GoString),
		Go.toInterface(stdgo.bytes.Bytes.split((("a,b,c" : GoString) : Slice&lt;GoByte&gt;), (("," : GoString) : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.printf(("%q\n" : GoString),
		Go.toInterface(stdgo.bytes.Bytes.split((("a man a plan a canal panama" : GoString) : Slice&lt;GoByte&gt;), (("a " : GoString) : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.printf(("%q\n" : GoString), Go.toInterface(stdgo.bytes.Bytes.split(((" xyz " : GoString) : Slice&lt;GoByte&gt;), (Go.str() : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.printf(("%q\n" : GoString),
		Go.toInterface(stdgo.bytes.Bytes.split((Go.str() : Slice&lt;GoByte&gt;), (("Bernardo O\'Higgins" : GoString) : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L712"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-splitafter">function splitAfter</a></h2>
<pre><code class="language-haxe">function splitAfter(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.Slice&lt;stdgo.GoByte&gt;&gt;</code></pre>
<p>SplitAfter slices s into all subslices after each instance of sep and  returns a slice of those subslices.  If sep is empty, SplitAfter splits after each UTF-8 sequence.  It is equivalent to SplitAfterN with a count of -1. </p>
<h3><a name="examplesplitafter">exampleSplitAfter</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleSplitAfter():Void {
	stdgo.fmt.Fmt.printf(("%q\n" : GoString),
		Go.toInterface(stdgo.bytes.Bytes.splitAfter((("a,b,c" : GoString) : Slice&lt;GoByte&gt;), (("," : GoString) : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L722"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-splitaftern">function splitAfterN</a></h2>
<pre><code class="language-haxe">function splitAfterN(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;, _n:stdgo.GoInt):stdgo.Slice&lt;stdgo.Slice&lt;stdgo.GoByte&gt;&gt;</code></pre>
<p>SplitAfterN slices s into subslices after each instance of sep and  returns a slice of those subslices.  If sep is empty, SplitAfterN splits after each UTF-8 sequence.  The count determines the number of subslices to return:     n \> 0: at most n subslices; the last subslice will be the unsplit remainder.   n == 0: the result is nil (zero subslices)   n \&lt; 0: all subslices </p>
<h3><a name="examplesplitaftern">exampleSplitAfterN</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleSplitAfterN():Void {
	stdgo.fmt.Fmt.printf(("%q\n" : GoString),
		Go.toInterface(stdgo.bytes.Bytes.splitAfterN((("a,b,c" : GoString) : Slice&lt;GoByte&gt;), (("," : GoString) : Slice&lt;GoByte&gt;), (2 : GoInt))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L700"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-splitn">function splitN</a></h2>
<pre><code class="language-haxe">function splitN(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _sep:stdgo.Slice&lt;stdgo.GoByte&gt;, _n:stdgo.GoInt):stdgo.Slice&lt;stdgo.Slice&lt;stdgo.GoByte&gt;&gt;</code></pre>
<p>SplitN slices s into subslices separated by sep and returns a slice of  the subslices between those separators.  If sep is empty, SplitN splits after each UTF-8 sequence.  The count determines the number of subslices to return:     n \> 0: at most n subslices; the last subslice will be the unsplit remainder.   n == 0: the result is nil (zero subslices)   n \&lt; 0: all subslices    To split around the first instance of a separator, see Cut. </p>
<h3><a name="examplesplitn">exampleSplitN</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleSplitN():Void {
	stdgo.fmt.Fmt.printf(("%q\n" : GoString),
		Go.toInterface(stdgo.bytes.Bytes.splitN((("a,b,c" : GoString) : Slice&lt;GoByte&gt;), (("," : GoString) : Slice&lt;GoByte&gt;), (2 : GoInt))));
	var _z = stdgo.bytes.Bytes.splitN((("a,b,c" : GoString) : Slice&lt;GoByte&gt;), (("," : GoString) : Slice&lt;GoByte&gt;), (0 : GoInt));
	stdgo.fmt.Fmt.printf(("%q (nil = %v)\n" : GoString), Go.toInterface(_z), Go.toInterface(_z == null));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L686"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-title">function title</a></h2>
<pre><code class="language-haxe">function title(_s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin  words mapped to their title case.    Deprecated: The rule Title uses for word boundaries does not handle Unicode  punctuation properly. Use golang.org/x/text/cases instead. </p>
<h3><a name="exampletitle">exampleTitle</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleTitle():Void {
	stdgo.fmt.Fmt.printf(("%s" : GoString), Go.toInterface(stdgo.bytes.Bytes.title((("her royal highness" : GoString) : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1128"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-tolower">function toLower</a></h2>
<pre><code class="language-haxe">function toLower(_s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>ToLower returns a copy of the byte slice s with all Unicode letters mapped to  their lower case. </p>
<h3><a name="exampletolower">exampleToLower</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleToLower():Void {
	stdgo.fmt.Fmt.printf(("%s" : GoString), Go.toInterface(stdgo.bytes.Bytes.toLower((("Gopher" : GoString) : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L995"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-tolowerspecial">function toLowerSpecial</a></h2>
<pre><code class="language-haxe">function toLowerSpecial(_c:stdgo.unicode.SpecialCase, _s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their  lower case, giving priority to the special casing rules. </p>
<h3><a name="exampletolowerspecial">exampleToLowerSpecial</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleToLowerSpecial():Void {
	var _str = (("AHOJ VÝVOJÁRİ GOLANG" : GoString) : Slice&lt;GoByte&gt;);
	var _totitle = stdgo.bytes.Bytes.toLowerSpecial(stdgo.unicode.Unicode.azeriCase, _str);
	stdgo.fmt.Fmt.println(Go.toInterface(("Original : " : GoString) + (_str : GoString)));
	stdgo.fmt.Fmt.println(Go.toInterface(("ToLower : " : GoString) + (_totitle : GoString)));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1050"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-totitle">function toTitle</a></h2>
<pre><code class="language-haxe">function toTitle(_s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case. </p>
<h3><a name="exampletotitle">exampleToTitle</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleToTitle():Void {
	stdgo.fmt.Fmt.printf(("%s\n" : GoString), Go.toInterface(stdgo.bytes.Bytes.toTitle((("loud noises" : GoString) : Slice&lt;GoByte&gt;))));
	stdgo.fmt.Fmt.printf(("%s\n" : GoString), Go.toInterface(stdgo.bytes.Bytes.toTitle((("хлеб" : GoString) : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1034"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-totitlespecial">function toTitleSpecial</a></h2>
<pre><code class="language-haxe">function toTitleSpecial(_c:stdgo.unicode.SpecialCase, _s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their  title case, giving priority to the special casing rules. </p>
<h3><a name="exampletotitlespecial">exampleToTitleSpecial</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleToTitleSpecial():Void {
	var _str = (("ahoj vývojári golang" : GoString) : Slice&lt;GoByte&gt;);
	var _totitle = stdgo.bytes.Bytes.toTitleSpecial(stdgo.unicode.Unicode.azeriCase, _str);
	stdgo.fmt.Fmt.println(Go.toInterface(("Original : " : GoString) + (_str : GoString)));
	stdgo.fmt.Fmt.println(Go.toInterface(("ToTitle : " : GoString) + (_totitle : GoString)));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1058"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-toupper">function toUpper</a></h2>
<pre><code class="language-haxe">function toUpper(_s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>ToUpper returns a copy of the byte slice s with all Unicode letters mapped to  their upper case. </p>
<h3><a name="exampletoupper">exampleToUpper</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleToUpper():Void {
	stdgo.fmt.Fmt.printf(("%s" : GoString), Go.toInterface(stdgo.bytes.Bytes.toUpper((("Gopher" : GoString) : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L955"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-toupperspecial">function toUpperSpecial</a></h2>
<pre><code class="language-haxe">function toUpperSpecial(_c:stdgo.unicode.SpecialCase, _s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their  upper case, giving priority to the special casing rules. </p>
<h3><a name="exampletoupperspecial">exampleToUpperSpecial</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleToUpperSpecial():Void {
	var _str = (("ahoj vývojári golang" : GoString) : Slice&lt;GoByte&gt;);
	var _totitle = stdgo.bytes.Bytes.toUpperSpecial(stdgo.unicode.Unicode.azeriCase, _str);
	stdgo.fmt.Fmt.println(Go.toInterface(("Original : " : GoString) + (_str : GoString)));
	stdgo.fmt.Fmt.println(Go.toInterface(("ToUpper : " : GoString) + (_totitle : GoString)));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1042"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-tovalidutf8">function toValidUTF8</a></h2>
<pre><code class="language-haxe">function toValidUTF8(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _replacement:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes  representing invalid UTF-8 replaced with the bytes in replacement, which may be empty. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1066"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-trim">function trim</a></h2>
<pre><code class="language-haxe">function trim(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _cutset:stdgo.GoString):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>Trim returns a subslice of s by slicing off all leading and  trailing UTF-8-encoded code points contained in cutset. </p>
<h3><a name="exampletrim">exampleTrim</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleTrim():Void {
	stdgo.fmt.Fmt.printf(("[%q]" : GoString),
		Go.toInterface(stdgo.bytes.Bytes.trim(((" !!! Achtung! Achtung! !!! " : GoString) : Slice&lt;GoByte&gt;), ("! " : GoString))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1309"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-trimfunc">function trimFunc</a></h2>
<pre><code class="language-haxe">function trimFunc(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _f:(_r:stdgo.GoRune):Bool):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>TrimFunc returns a subslice of s by slicing off all leading and trailing  UTF-8-encoded code points c that satisfy f(c). </p>
<h3><a name="exampletrimfunc">exampleTrimFunc</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleTrimFunc():Void {
	stdgo.fmt.Fmt.println(Go.toInterface((stdgo.bytes.Bytes.trimFunc((("go-gopher!" : GoString) : Slice&lt;GoByte&gt;),
		stdgo.unicode.Unicode.isLetter) : GoString)));
	stdgo.fmt.Fmt.println(Go.toInterface((stdgo.bytes.Bytes.trimFunc((("\"go-gopher!\"" : GoString) : Slice&lt;GoByte&gt;),
		stdgo.unicode.Unicode.isLetter) : GoString)));
	stdgo.fmt.Fmt.println(Go.toInterface((stdgo.bytes.Bytes.trimFunc((("go-gopher!" : GoString) : Slice&lt;GoByte&gt;), stdgo.unicode.Unicode.isPunct) : GoString)));
	stdgo.fmt.Fmt.println(Go.toInterface((stdgo.bytes.Bytes.trimFunc((("1234go-gopher!567" : GoString) : Slice&lt;GoByte&gt;),
		stdgo.unicode.Unicode.isNumber) : GoString)));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1173"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-trimleft">function trimLeft</a></h2>
<pre><code class="language-haxe">function trimLeft(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _cutset:stdgo.GoString):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>TrimLeft returns a subslice of s by slicing off all leading  UTF-8-encoded code points contained in cutset. </p>
<h3><a name="exampletrimleft">exampleTrimLeft</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleTrimLeft():Void {
	stdgo.fmt.Fmt.print(Go.toInterface((stdgo.bytes.Bytes.trimLeft((("453gopher8257" : GoString) : Slice&lt;GoByte&gt;), ("0123456789" : GoString)) : GoString)));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1334"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-trimleftfunc">function trimLeftFunc</a></h2>
<pre><code class="language-haxe">function trimLeftFunc(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _f:(_r:stdgo.GoRune):Bool):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off  all leading UTF-8-encoded code points c that satisfy f(c). </p>
<h3><a name="exampletrimleftfunc">exampleTrimLeftFunc</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleTrimLeftFunc():Void {
	stdgo.fmt.Fmt.println(Go.toInterface((stdgo.bytes.Bytes.trimLeftFunc((("go-gopher" : GoString) : Slice&lt;GoByte&gt;),
		stdgo.unicode.Unicode.isLetter) : GoString)));
	stdgo.fmt.Fmt.println(Go.toInterface((stdgo.bytes.Bytes.trimLeftFunc((("go-gopher!" : GoString) : Slice&lt;GoByte&gt;),
		stdgo.unicode.Unicode.isPunct) : GoString)));
	stdgo.fmt.Fmt.println(Go.toInterface((stdgo.bytes.Bytes.trimLeftFunc((("1234go-gopher!567" : GoString) : Slice&lt;GoByte&gt;),
		stdgo.unicode.Unicode.isNumber) : GoString)));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1144"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-trimprefix">function trimPrefix</a></h2>
<pre><code class="language-haxe">function trimPrefix(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _prefix:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>TrimPrefix returns s without the provided leading prefix string.  If s doesn't start with prefix, s is returned unchanged. </p>
<h3><a name="exampletrimprefix">exampleTrimPrefix</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleTrimPrefix():Void {
	var _b:Slice&lt;GoUInt8&gt; = (("Goodbye,, world!" : GoString) : Slice&lt;GoByte&gt;);
	_b = stdgo.bytes.Bytes.trimPrefix(_b, (("Goodbye," : GoString) : Slice&lt;GoByte&gt;));
	_b = stdgo.bytes.Bytes.trimPrefix(_b, (("See ya," : GoString) : Slice&lt;GoByte&gt;));
	stdgo.fmt.Fmt.printf(("Hello%s" : GoString), Go.toInterface(_b));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1181"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-trimright">function trimRight</a></h2>
<pre><code class="language-haxe">function trimRight(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _cutset:stdgo.GoString):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>TrimRight returns a subslice of s by slicing off all trailing  UTF-8-encoded code points that are contained in cutset. </p>
<h3><a name="exampletrimright">exampleTrimRight</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleTrimRight():Void {
	stdgo.fmt.Fmt.print(Go.toInterface((stdgo.bytes.Bytes.trimRight((("453gopher8257" : GoString) : Slice&lt;GoByte&gt;), ("0123456789" : GoString)) : GoString)));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1406"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-trimrightfunc">function trimRightFunc</a></h2>
<pre><code class="language-haxe">function trimRightFunc(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _f:(_r:stdgo.GoRune):Bool):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>TrimRightFunc returns a subslice of s by slicing off all trailing  UTF-8-encoded code points c that satisfy f(c). </p>
<h3><a name="exampletrimrightfunc">exampleTrimRightFunc</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleTrimRightFunc():Void {
	stdgo.fmt.Fmt.println(Go.toInterface((stdgo.bytes.Bytes.trimRightFunc((("go-gopher" : GoString) : Slice&lt;GoByte&gt;),
		stdgo.unicode.Unicode.isLetter) : GoString)));
	stdgo.fmt.Fmt.println(Go.toInterface((stdgo.bytes.Bytes.trimRightFunc((("go-gopher!" : GoString) : Slice&lt;GoByte&gt;),
		stdgo.unicode.Unicode.isPunct) : GoString)));
	stdgo.fmt.Fmt.println(Go.toInterface((stdgo.bytes.Bytes.trimRightFunc((("1234go-gopher!567" : GoString) : Slice&lt;GoByte&gt;),
		stdgo.unicode.Unicode.isNumber) : GoString)));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1156"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-trimspace">function trimSpace</a></h2>
<pre><code class="language-haxe">function trimSpace(_s:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>TrimSpace returns a subslice of s by slicing off all leading and  trailing white space, as defined by Unicode. </p>
<h3><a name="exampletrimspace">exampleTrimSpace</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleTrimSpace():Void {
	stdgo.fmt.Fmt.printf(("%s" : GoString), Go.toInterface(stdgo.bytes.Bytes.trimSpace(((" \t\n a lone gopher \n\t\r\n" : GoString) : Slice&lt;GoByte&gt;))));
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1466"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="function-trimsuffix">function trimSuffix</a></h2>
<pre><code class="language-haxe">function trimSuffix(_s:stdgo.Slice&lt;stdgo.GoByte&gt;, _suffix:stdgo.Slice&lt;stdgo.GoByte&gt;):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>TrimSuffix returns s without the provided trailing suffix string.  If s doesn't end with suffix, s is returned unchanged. </p>
<h3><a name="exampletrimsuffix">exampleTrimSuffix</a></h3><details><summary></summary>
<p>
<pre><code class="language-haxe">function exampleTrimSuffix():Void {
	var _b:Slice&lt;GoUInt8&gt; = (("Hello, goodbye, etc!" : GoString) : Slice&lt;GoByte&gt;);
	_b = stdgo.bytes.Bytes.trimSuffix(_b, (("goodbye, etc!" : GoString) : Slice&lt;GoByte&gt;));
	_b = stdgo.bytes.Bytes.trimSuffix(_b, (("gopher" : GoString) : Slice&lt;GoByte&gt;));
	_b = _b.__appendref__(...stdgo.bytes.Bytes.trimSuffix((("world!" : GoString) : Slice&lt;GoByte&gt;), (("x!" : GoString) : Slice&lt;GoByte&gt;)).__toArray__());
	stdgo.os.Os.stdout.write(_b);
}</code></pre>
<p></p>
</details></p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L1192"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h1><a name="classes">Classes</a></h1>
<pre><code class="language-haxe">import stdgo.bytes.*</code></pre>
<h2><a name="class-buffer">class Buffer</a></h2>
<p>A Buffer is a variable-sized buffer of bytes with Read and Write methods.  The zero value for Buffer is an empty buffer ready to use. </p>
<pre><code class="language-haxe">var _buf:stdgo.Slice&lt;stdgo.GoUInt8&gt;</code></pre>
<pre><code class="language-haxe">var _lastRead:stdgo.bytes._Bytes.T_readOp</code></pre>
<pre><code class="language-haxe">var _off:stdgo.GoInt</code></pre>
<h3><a name="buffer-function-new">Buffer function new</a></h3>
<pre><code class="language-haxe">function new(?_buf:stdgo.Slice&lt;stdgo.GoUInt8&gt;, ?_off:Null&lt;stdgo.GoInt&gt;, ?_lastRead:Null&lt;stdgo.bytes._Bytes.T_readOp&gt;):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L103"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-_empty">Buffer function _empty</a></h3>
<pre><code class="language-haxe">function _empty():Bool</code></pre>
<p>empty reports whether the unread portion of the buffer is empty. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2456"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-_grow">Buffer function _grow</a></h3>
<pre><code class="language-haxe">function _grow( _n:stdgo.GoInt):stdgo.GoInt</code></pre>
<p>grow grows the buffer to guarantee space for n more bytes.   It returns the index where bytes should be written.   If the buffer can't grow it will panic with ErrTooLarge. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2357"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-_readslice">Buffer function _readSlice</a></h3>
<pre><code class="language-haxe">function _readSlice( _delim:stdgo.GoByte):{_1:stdgo.Error, _0:stdgo.Slice&lt;stdgo.GoByte&gt;}</code></pre>
<p>readSlice is like ReadBytes but returns a reference to internal buffer data. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2029"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-_trygrowbyreslice">Buffer function _tryGrowByReslice</a></h3>
<pre><code class="language-haxe">function _tryGrowByReslice( _n:stdgo.GoInt):{_1:Bool, _0:stdgo.GoInt}</code></pre>
<p>tryGrowByReslice is a inlineable version of grow for the fast-case where the   internal buffer only needs to be resliced.   It returns the index where bytes should be written and whether it succeeded. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2393"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-bytes">Buffer function bytes</a></h3>
<pre><code class="language-haxe">function bytes():stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>Bytes returns a slice of length b.Len() holding the unread portion of the buffer.   The slice is valid for use only until the next buffer modification (that is,   only until the next call to a method like Read, Write, Reset, or Truncate).   The slice aliases the buffer content at least until the next buffer modification,   so immediate changes to the slice will affect the result of future reads. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2482"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-cap">Buffer function cap</a></h3>
<pre><code class="language-haxe">function cap():stdgo.GoInt</code></pre>
<p>Cap returns the capacity of the buffer's underlying byte slice, that is, the   total space allocated for the buffer's data. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2439"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-grow">Buffer function grow</a></h3>
<pre><code class="language-haxe">function grow( _n:stdgo.GoInt):Void</code></pre>
<p>Grow grows the buffer's capacity, if necessary, to guarantee space for   another n bytes. After Grow(n), at least n bytes can be written to the   buffer without another allocation.   If n is negative, Grow will panic.   If the buffer can't grow it will panic with ErrTooLarge. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2343"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-len">Buffer function len</a></h3>
<pre><code class="language-haxe">function len():stdgo.GoInt</code></pre>
<p>Len returns the number of bytes of the unread portion of the buffer;   b.Len() == len(b.Bytes()). </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2448"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-next">Buffer function next</a></h3>
<pre><code class="language-haxe">function next( _n:stdgo.GoInt):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>Next returns a slice containing the next n bytes from the buffer,   advancing the buffer as if the bytes had been returned by Read.   If there are fewer than n bytes in the buffer, Next returns the entire buffer.   The slice is only valid until the next call to a read or write method. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2153"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-read">Buffer function read</a></h3>
<pre><code class="language-haxe">function read( _p:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Read reads the next len(p) bytes from the buffer or until the buffer   is drained. The return value n is the number of bytes read. If the   buffer has no data to return, err is io.EOF (unless len(p) is zero);   otherwise it is nil. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2174"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-readbyte">Buffer function readByte</a></h3>
<pre><code class="language-haxe">function readByte():{_1:stdgo.Error, _0:stdgo.GoByte}</code></pre>
<p>ReadByte reads and returns the next byte from the buffer.   If no byte is available, it returns error io.EOF. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2135"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-readbytes">Buffer function readBytes</a></h3>
<pre><code class="language-haxe">function readBytes( _delim:stdgo.GoByte):{_1:stdgo.Error, _0:stdgo.Slice&lt;stdgo.GoByte&gt;}</code></pre>
<p>ReadBytes reads until the first occurrence of delim in the input,   returning a slice containing the data up to and including the delimiter.   If ReadBytes encounters an error before finding a delimiter,   it returns the data read before the error and the error itself (often io.EOF).   ReadBytes returns err != nil if and only if the returned data does not end in   delim. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2053"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-readfrom">Buffer function readFrom</a></h3>
<pre><code class="language-haxe">function readFrom( _r:stdgo.io.Reader):{_1:stdgo.Error, _0:stdgo.GoInt64}</code></pre>
<p>ReadFrom reads data from r until EOF and appends it to the buffer, growing   the buffer as needed. The return value n is the number of bytes read. Any   error except io.EOF encountered during the read is also returned. If the   buffer becomes too large, ReadFrom will panic with ErrTooLarge. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2276"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-readrune">Buffer function readRune</a></h3>
<pre><code class="language-haxe">function readRune():{_2:stdgo.Error, _1:stdgo.GoInt, _0:stdgo.GoRune}</code></pre>
<p>ReadRune reads and returns the next UTF-8-encoded   Unicode code point from the buffer.   If no bytes are available, the error returned is io.EOF.   If the bytes are an erroneous UTF-8 encoding, it   consumes one byte and returns U+FFFD, 1. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2108"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-readstring">Buffer function readString</a></h3>
<pre><code class="language-haxe">function readString( _delim:stdgo.GoByte):{_1:stdgo.Error, _0:stdgo.GoString}</code></pre>
<p>ReadString reads until the first occurrence of delim in the input,   returning a string containing the data up to and including the delimiter.   If ReadString encounters an error before finding a delimiter,   it returns the data read before the error and the error itself (often io.EOF).   ReadString returns err != nil if and only if the returned data does not end   in delim. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2017"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-reset">Buffer function reset</a></h3>
<pre><code class="language-haxe">function reset():Void</code></pre>
<p>Reset resets the buffer to be empty,   but it retains the underlying storage for use by future writes.   Reset is the same as Truncate(0). </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2410"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-string">Buffer function string</a></h3>
<pre><code class="language-haxe">function string():stdgo.GoString</code></pre>
<p>String returns the contents of the unread portion of the buffer   as a string. If the Buffer is a nil pointer, it returns "\<nil\>".      To build strings more efficiently, see the strings.Builder type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2467"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-truncate">Buffer function truncate</a></h3>
<pre><code class="language-haxe">function truncate( _n:stdgo.GoInt):Void</code></pre>
<p>Truncate discards all but the first n unread bytes from the buffer   but continues to use the same allocated storage.   It panics if n is negative or greater than the length of the buffer. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2422"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-unreadbyte">Buffer function unreadByte</a></h3>
<pre><code class="language-haxe">function unreadByte():stdgo.Error</code></pre>
<p>UnreadByte unreads the last byte returned by the most recent successful   read operation that read at least one byte. If a write has happened since   the last read, if the last read returned an error, or if the read read zero   bytes, UnreadByte returns an error. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2070"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-unreadrune">Buffer function unreadRune</a></h3>
<pre><code class="language-haxe">function unreadRune():stdgo.Error</code></pre>
<p>UnreadRune unreads the last rune returned by ReadRune.   If the most recent read or write operation on the buffer was   not a successful ReadRune, UnreadRune returns an error.  (In this regard   it is stricter than UnreadByte, which will unread the last byte   from any read operation.) </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2089"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-write">Buffer function write</a></h3>
<pre><code class="language-haxe">function write( _p:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Write appends the contents of p to the buffer, growing the buffer as   needed. The return value n is the length of p; err is always nil. If the   buffer becomes too large, Write will panic with ErrTooLarge. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2323"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-writebyte">Buffer function writeByte</a></h3>
<pre><code class="language-haxe">function writeByte( _c:stdgo.GoByte):stdgo.Error</code></pre>
<p>WriteByte appends the byte c to the buffer, growing the buffer as needed.   The returned error is always nil, but is included to match bufio.Writer's   WriteByte. If the buffer becomes too large, WriteByte will panic with   ErrTooLarge. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2224"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-writerune">Buffer function writeRune</a></h3>
<pre><code class="language-haxe">function writeRune( _r:stdgo.GoRune):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>WriteRune appends the UTF-8 encoding of Unicode code point r to the   buffer, returning its length and an error, which is always nil but is   included to match bufio.Writer's WriteRune. The buffer is grown as needed;   if it becomes too large, WriteRune will panic with ErrTooLarge. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2199"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-writestring">Buffer function writeString</a></h3>
<pre><code class="language-haxe">function writeString( _s:stdgo.GoString):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>WriteString appends the contents of s to the buffer, growing the buffer as   needed. The return value n is the length of s; err is always nil. If the   buffer becomes too large, WriteString will panic with ErrTooLarge. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2305"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="buffer-function-writeto">Buffer function writeTo</a></h3>
<pre><code class="language-haxe">function writeTo( _w:stdgo.io.Writer):{_1:stdgo.Error, _0:stdgo.GoInt64}</code></pre>
<p>WriteTo writes data to w until the buffer is drained or an error occurs.   The return value n is the number of bytes written; it always fits into an   int, but it is int64 to match the io.WriterTo interface. Any error   encountered during the write is also returned. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2243"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class Buffer_static_extension</h2>
<h3>Buffer_static_extension function _empty</h3>
<pre><code class="language-haxe">function _empty():Bool</code></pre>
<p>empty reports whether the unread portion of the buffer is empty. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2456"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function _grow</h3>
<pre><code class="language-haxe">function _grow( _n:stdgo.GoInt):stdgo.GoInt</code></pre>
<p>grow grows the buffer to guarantee space for n more bytes.   It returns the index where bytes should be written.   If the buffer can't grow it will panic with ErrTooLarge. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2357"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function _readSlice</h3>
<pre><code class="language-haxe">function _readSlice( _delim:stdgo.GoByte):{_1:stdgo.Error, _0:stdgo.Slice&lt;stdgo.GoByte&gt;}</code></pre>
<p>readSlice is like ReadBytes but returns a reference to internal buffer data. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2029"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function _tryGrowByReslice</h3>
<pre><code class="language-haxe">function _tryGrowByReslice( _n:stdgo.GoInt):{_1:Bool, _0:stdgo.GoInt}</code></pre>
<p>tryGrowByReslice is a inlineable version of grow for the fast-case where the   internal buffer only needs to be resliced.   It returns the index where bytes should be written and whether it succeeded. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2393"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function bytes</h3>
<pre><code class="language-haxe">function bytes():stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>Bytes returns a slice of length b.Len() holding the unread portion of the buffer.   The slice is valid for use only until the next buffer modification (that is,   only until the next call to a method like Read, Write, Reset, or Truncate).   The slice aliases the buffer content at least until the next buffer modification,   so immediate changes to the slice will affect the result of future reads. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2482"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function cap</h3>
<pre><code class="language-haxe">function cap():stdgo.GoInt</code></pre>
<p>Cap returns the capacity of the buffer's underlying byte slice, that is, the   total space allocated for the buffer's data. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2439"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function grow</h3>
<pre><code class="language-haxe">function grow( _n:stdgo.GoInt):Void</code></pre>
<p>Grow grows the buffer's capacity, if necessary, to guarantee space for   another n bytes. After Grow(n), at least n bytes can be written to the   buffer without another allocation.   If n is negative, Grow will panic.   If the buffer can't grow it will panic with ErrTooLarge. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2343"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function len</h3>
<pre><code class="language-haxe">function len():stdgo.GoInt</code></pre>
<p>Len returns the number of bytes of the unread portion of the buffer;   b.Len() == len(b.Bytes()). </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2448"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function next</h3>
<pre><code class="language-haxe">function next( _n:stdgo.GoInt):stdgo.Slice&lt;stdgo.GoByte&gt;</code></pre>
<p>Next returns a slice containing the next n bytes from the buffer,   advancing the buffer as if the bytes had been returned by Read.   If there are fewer than n bytes in the buffer, Next returns the entire buffer.   The slice is only valid until the next call to a read or write method. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2153"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function read</h3>
<pre><code class="language-haxe">function read( _p:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Read reads the next len(p) bytes from the buffer or until the buffer   is drained. The return value n is the number of bytes read. If the   buffer has no data to return, err is io.EOF (unless len(p) is zero);   otherwise it is nil. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2174"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function readByte</h3>
<pre><code class="language-haxe">function readByte():{_1:stdgo.Error, _0:stdgo.GoByte}</code></pre>
<p>ReadByte reads and returns the next byte from the buffer.   If no byte is available, it returns error io.EOF. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2135"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function readBytes</h3>
<pre><code class="language-haxe">function readBytes( _delim:stdgo.GoByte):{_1:stdgo.Error, _0:stdgo.Slice&lt;stdgo.GoByte&gt;}</code></pre>
<p>ReadBytes reads until the first occurrence of delim in the input,   returning a slice containing the data up to and including the delimiter.   If ReadBytes encounters an error before finding a delimiter,   it returns the data read before the error and the error itself (often io.EOF).   ReadBytes returns err != nil if and only if the returned data does not end in   delim. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2053"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function readFrom</h3>
<pre><code class="language-haxe">function readFrom( _r:stdgo.io.Reader):{_1:stdgo.Error, _0:stdgo.GoInt64}</code></pre>
<p>ReadFrom reads data from r until EOF and appends it to the buffer, growing   the buffer as needed. The return value n is the number of bytes read. Any   error except io.EOF encountered during the read is also returned. If the   buffer becomes too large, ReadFrom will panic with ErrTooLarge. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2276"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function readRune</h3>
<pre><code class="language-haxe">function readRune():{_2:stdgo.Error, _1:stdgo.GoInt, _0:stdgo.GoRune}</code></pre>
<p>ReadRune reads and returns the next UTF-8-encoded   Unicode code point from the buffer.   If no bytes are available, the error returned is io.EOF.   If the bytes are an erroneous UTF-8 encoding, it   consumes one byte and returns U+FFFD, 1. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2108"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function readString</h3>
<pre><code class="language-haxe">function readString( _delim:stdgo.GoByte):{_1:stdgo.Error, _0:stdgo.GoString}</code></pre>
<p>ReadString reads until the first occurrence of delim in the input,   returning a string containing the data up to and including the delimiter.   If ReadString encounters an error before finding a delimiter,   it returns the data read before the error and the error itself (often io.EOF).   ReadString returns err != nil if and only if the returned data does not end   in delim. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2017"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function reset</h3>
<pre><code class="language-haxe">function reset():Void</code></pre>
<p>Reset resets the buffer to be empty,   but it retains the underlying storage for use by future writes.   Reset is the same as Truncate(0). </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2410"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function string</h3>
<pre><code class="language-haxe">function string():stdgo.GoString</code></pre>
<p>String returns the contents of the unread portion of the buffer   as a string. If the Buffer is a nil pointer, it returns "\<nil\>".      To build strings more efficiently, see the strings.Builder type. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2467"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function truncate</h3>
<pre><code class="language-haxe">function truncate( _n:stdgo.GoInt):Void</code></pre>
<p>Truncate discards all but the first n unread bytes from the buffer   but continues to use the same allocated storage.   It panics if n is negative or greater than the length of the buffer. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2422"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function unreadByte</h3>
<pre><code class="language-haxe">function unreadByte():stdgo.Error</code></pre>
<p>UnreadByte unreads the last byte returned by the most recent successful   read operation that read at least one byte. If a write has happened since   the last read, if the last read returned an error, or if the read read zero   bytes, UnreadByte returns an error. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2070"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function unreadRune</h3>
<pre><code class="language-haxe">function unreadRune():stdgo.Error</code></pre>
<p>UnreadRune unreads the last rune returned by ReadRune.   If the most recent read or write operation on the buffer was   not a successful ReadRune, UnreadRune returns an error.  (In this regard   it is stricter than UnreadByte, which will unread the last byte   from any read operation.) </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2089"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function write</h3>
<pre><code class="language-haxe">function write( _p:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Write appends the contents of p to the buffer, growing the buffer as   needed. The return value n is the length of p; err is always nil. If the   buffer becomes too large, Write will panic with ErrTooLarge. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2323"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function writeByte</h3>
<pre><code class="language-haxe">function writeByte( _c:stdgo.GoByte):stdgo.Error</code></pre>
<p>WriteByte appends the byte c to the buffer, growing the buffer as needed.   The returned error is always nil, but is included to match bufio.Writer's   WriteByte. If the buffer becomes too large, WriteByte will panic with   ErrTooLarge. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2224"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function writeRune</h3>
<pre><code class="language-haxe">function writeRune( _r:stdgo.GoRune):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>WriteRune appends the UTF-8 encoding of Unicode code point r to the   buffer, returning its length and an error, which is always nil but is   included to match bufio.Writer's WriteRune. The buffer is grown as needed;   if it becomes too large, WriteRune will panic with ErrTooLarge. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2199"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function writeString</h3>
<pre><code class="language-haxe">function writeString( _s:stdgo.GoString):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>WriteString appends the contents of s to the buffer, growing the buffer as   needed. The return value n is the length of s; err is always nil. If the   buffer becomes too large, WriteString will panic with ErrTooLarge. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2305"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Buffer_static_extension function writeTo</h3>
<pre><code class="language-haxe">function writeTo( _w:stdgo.io.Writer):{_1:stdgo.Error, _0:stdgo.GoInt64}</code></pre>
<p>WriteTo writes data to w until the buffer is drained or an error occurs.   The return value n is the number of bytes written; it always fits into an   int, but it is int64 to match the io.WriterTo interface. Any error   encountered during the write is also returned. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2243"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2><a name="class-reader">class Reader</a></h2>
<p>A Reader implements the io.Reader, io.ReaderAt, io.WriterTo, io.Seeker,  io.ByteScanner, and io.RuneScanner interfaces by reading from  a byte slice.  Unlike a Buffer, a Reader is read-only and supports seeking.  The zero value for Reader operates like a Reader of an empty slice. </p>
<pre><code class="language-haxe">var _i:stdgo.GoInt64</code></pre>
<pre><code class="language-haxe">var _prevRune:stdgo.GoInt</code></pre>
<pre><code class="language-haxe">var _s:stdgo.Slice&lt;stdgo.GoUInt8&gt;</code></pre>
<h3><a name="reader-function-new">Reader function new</a></h3>
<pre><code class="language-haxe">function new(?_s:stdgo.Slice&lt;stdgo.GoUInt8&gt;, ?_i:stdgo.GoInt64, ?_prevRune:Null&lt;stdgo.GoInt&gt;):Void</code></pre>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L132"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="reader-function-len">Reader function len</a></h3>
<pre><code class="language-haxe">function len():stdgo.GoInt</code></pre>
<p>Len returns the number of bytes of the unread portion of the   slice. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2765"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="reader-function-read">Reader function read</a></h3>
<pre><code class="language-haxe">function read( _b:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Read implements the io.Reader interface. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2739"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="reader-function-readat">Reader function readAt</a></h3>
<pre><code class="language-haxe">function readAt( _b:stdgo.Slice&lt;stdgo.GoByte&gt;, _off:stdgo.GoInt64):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>ReadAt implements the io.ReaderAt interface. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2720"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="reader-function-readbyte">Reader function readByte</a></h3>
<pre><code class="language-haxe">function readByte():{_1:stdgo.Error, _0:stdgo.GoByte}</code></pre>
<p>ReadByte implements the io.ByteReader interface. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2706"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="reader-function-readrune">Reader function readRune</a></h3>
<pre><code class="language-haxe">function readRune():{_2:stdgo.Error, _1:stdgo.GoInt, _0:stdgo.GoRune}</code></pre>
<p>ReadRune implements the io.RuneReader interface. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2664"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="reader-function-reset">Reader function reset</a></h3>
<pre><code class="language-haxe">function reset( _b:stdgo.Slice&lt;stdgo.GoByte&gt;):Void</code></pre>
<p>Reset resets the Reader to be reading from b. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2587"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="reader-function-seek">Reader function seek</a></h3>
<pre><code class="language-haxe">function seek( _offset:stdgo.GoInt64, _whence:stdgo.GoInt):{_1:stdgo.Error, _0:stdgo.GoInt64}</code></pre>
<p>Seek implements the io.Seeker interface. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2625"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="reader-function-size">Reader function size</a></h3>
<pre><code class="language-haxe">function size():stdgo.GoInt64</code></pre>
<p>Size returns the original length of the underlying byte slice.   Size is the number of bytes available for reading via ReadAt.   The result is unaffected by any method calls except Reset. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2756"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="reader-function-unreadbyte">Reader function unreadByte</a></h3>
<pre><code class="language-haxe">function unreadByte():stdgo.Error</code></pre>
<p>UnreadByte complements ReadByte in implementing the io.ByteScanner interface. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2693"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="reader-function-unreadrune">Reader function unreadRune</a></h3>
<pre><code class="language-haxe">function unreadRune():stdgo.Error</code></pre>
<p>UnreadRune complements ReadRune in implementing the io.RuneScanner interface. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2648"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3><a name="reader-function-writeto">Reader function writeTo</a></h3>
<pre><code class="language-haxe">function writeTo( _w:stdgo.io.Writer):{_1:stdgo.Error, _0:stdgo.GoInt64}</code></pre>
<p>WriteTo implements the io.WriterTo interface. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2600"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class Reader_static_extension</h2>
<h3>Reader_static_extension function len</h3>
<pre><code class="language-haxe">function len():stdgo.GoInt</code></pre>
<p>Len returns the number of bytes of the unread portion of the   slice. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2765"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Reader_static_extension function read</h3>
<pre><code class="language-haxe">function read( _b:stdgo.Slice&lt;stdgo.GoByte&gt;):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>Read implements the io.Reader interface. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2739"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Reader_static_extension function readAt</h3>
<pre><code class="language-haxe">function readAt( _b:stdgo.Slice&lt;stdgo.GoByte&gt;, _off:stdgo.GoInt64):{_1:stdgo.Error, _0:stdgo.GoInt}</code></pre>
<p>ReadAt implements the io.ReaderAt interface. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2720"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Reader_static_extension function readByte</h3>
<pre><code class="language-haxe">function readByte():{_1:stdgo.Error, _0:stdgo.GoByte}</code></pre>
<p>ReadByte implements the io.ByteReader interface. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2706"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Reader_static_extension function readRune</h3>
<pre><code class="language-haxe">function readRune():{_2:stdgo.Error, _1:stdgo.GoInt, _0:stdgo.GoRune}</code></pre>
<p>ReadRune implements the io.RuneReader interface. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2664"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Reader_static_extension function reset</h3>
<pre><code class="language-haxe">function reset( _b:stdgo.Slice&lt;stdgo.GoByte&gt;):Void</code></pre>
<p>Reset resets the Reader to be reading from b. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2587"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Reader_static_extension function seek</h3>
<pre><code class="language-haxe">function seek( _offset:stdgo.GoInt64, _whence:stdgo.GoInt):{_1:stdgo.Error, _0:stdgo.GoInt64}</code></pre>
<p>Seek implements the io.Seeker interface. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2625"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Reader_static_extension function size</h3>
<pre><code class="language-haxe">function size():stdgo.GoInt64</code></pre>
<p>Size returns the original length of the underlying byte slice.   Size is the number of bytes available for reading via ReadAt.   The result is unaffected by any method calls except Reset. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2756"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Reader_static_extension function unreadByte</h3>
<pre><code class="language-haxe">function unreadByte():stdgo.Error</code></pre>
<p>UnreadByte complements ReadByte in implementing the io.ByteScanner interface. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2693"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Reader_static_extension function unreadRune</h3>
<pre><code class="language-haxe">function unreadRune():stdgo.Error</code></pre>
<p>UnreadRune complements ReadRune in implementing the io.RuneScanner interface. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2648"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h3>Reader_static_extension function writeTo</h3>
<pre><code class="language-haxe">function writeTo( _w:stdgo.io.Writer):{_1:stdgo.Error, _0:stdgo.GoInt64}</code></pre>
<p>WriteTo implements the io.WriterTo interface. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2600"target="_blank" rel="noopener noreferrer">(view code)</a></p>
<h2>class T_asciiSet_static_extension</h2>
<h3>T_asciiSet_static_extension function _contains</h3>
<pre><code class="language-haxe">function _contains(_as:stdgo.Ref&lt;stdgo.bytes._Bytes.T_asciiSet&gt;, _c:stdgo.GoByte):Bool</code></pre>
<p>contains reports whether c is inside the set. </p>
<p><a href="https://github.com/go2hx/go2hx/tree/master/stdgo/bytes//Bytes.hx#L2800"target="_blank" rel="noopener noreferrer">(view code)</a></p>
    </article>
</body>
</html>